<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unofficial Bevy Cheat Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<script async defer src="https://buttons.github.io/buttons.js"></script>
<meta name="robots" content="noindex">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="nagbar.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="cheatsheet.html"><strong aria-hidden="true">1.</strong> Quick Reference (Alphabetical Index / Glossary)</a></li><li class="chapter-item expanded "><a href="setup/_index.html"><strong aria-hidden="true">2.</strong> Bevy Setup Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/bevy-git.html"><strong aria-hidden="true">2.1.</strong> Using bleeding-edge Bevy (main)</a></li><li class="chapter-item expanded "><a href="setup/editor.html"><strong aria-hidden="true">2.2.</strong> Text Editor / IDE</a></li><li class="chapter-item expanded "><a href="setup/bevy-config.html"><strong aria-hidden="true">2.3.</strong> Customizing Bevy (features, modularity)</a></li><li class="chapter-item expanded "><a href="setup/bevy-tools.html"><strong aria-hidden="true">2.4.</strong> Dev Tools and Editors for Bevy</a></li><li class="chapter-item expanded "><a href="setup/unofficial-plugins.html"><strong aria-hidden="true">2.5.</strong> 3rd-party Plugins</a></li></ol></li><li class="chapter-item expanded "><a href="programming/_index.html"><strong aria-hidden="true">3.</strong> Bevy Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/_basics.html"><strong aria-hidden="true">3.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/ecs-intro.html"><strong aria-hidden="true">3.1.1.</strong> Intro to ECS</a></li><li class="chapter-item expanded "><a href="programming/ec.html"><strong aria-hidden="true">3.1.2.</strong> Entities and Components</a></li><li class="chapter-item expanded "><a href="programming/res.html"><strong aria-hidden="true">3.1.3.</strong> Resources</a></li><li class="chapter-item expanded "><a href="programming/systems.html"><strong aria-hidden="true">3.1.4.</strong> Systems</a></li><li class="chapter-item expanded "><a href="programming/queries.html"><strong aria-hidden="true">3.1.5.</strong> Queries</a></li><li class="chapter-item expanded "><a href="programming/commands.html"><strong aria-hidden="true">3.1.6.</strong> Commands</a></li><li class="chapter-item expanded "><a href="programming/events.html"><strong aria-hidden="true">3.1.7.</strong> Events</a></li><li class="chapter-item expanded "><a href="programming/app-builder.html"><strong aria-hidden="true">3.1.8.</strong> App Builder (fn main)</a></li></ol></li><li class="chapter-item expanded "><a href="programming/_next-steps.html"><strong aria-hidden="true">3.2.</strong> Next Steps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/local.html"><strong aria-hidden="true">3.2.1.</strong> Local Resources</a></li><li class="chapter-item expanded "><a href="programming/plugins.html"><strong aria-hidden="true">3.2.2.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="programming/system-order.html"><strong aria-hidden="true">3.2.3.</strong> System Order of Execution</a></li><li class="chapter-item expanded "><a href="programming/system-sets.html"><strong aria-hidden="true">3.2.4.</strong> System Sets</a></li><li class="chapter-item expanded "><a href="programming/parent-child.html"><strong aria-hidden="true">3.2.5.</strong> Hierarchical Entities</a></li><li class="chapter-item expanded "><a href="programming/change-detection.html"><strong aria-hidden="true">3.2.6.</strong> Change Detection</a></li><li class="chapter-item expanded "><a href="programming/system-chaining.html"><strong aria-hidden="true">3.2.7.</strong> System Chaining</a></li><li class="chapter-item expanded "><a href="programming/query-sets.html"><strong aria-hidden="true">3.2.8.</strong> Query Sets</a></li><li class="chapter-item expanded "><a href="programming/states.html"><strong aria-hidden="true">3.2.9.</strong> States</a></li><li class="chapter-item expanded "><a href="programming/run-criteria.html"><strong aria-hidden="true">3.2.10.</strong> Run Criteria</a></li><li class="chapter-item expanded "><a href="programming/labels.html"><strong aria-hidden="true">3.2.11.</strong> Labels</a></li></ol></li><li class="chapter-item expanded "><a href="programming/_advanced.html"><strong aria-hidden="true">3.3.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/stages.html"><strong aria-hidden="true">3.3.1.</strong> Stages</a></li><li class="chapter-item expanded "><a href="programming/removal-detection.html"><strong aria-hidden="true">3.3.2.</strong> Removal Detection</a></li><li class="chapter-item expanded "><a href="programming/world-exclusive.html"><strong aria-hidden="true">3.3.3.</strong> [WIP] Direct World/ECS Access</a></li><li class="chapter-item expanded "><a href="programming/system-tests.html"><strong aria-hidden="true">3.3.4.</strong> Writing Tests for Systems</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="features/_index.html"><strong aria-hidden="true">4.</strong> Bevy Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="features/transforms.html"><strong aria-hidden="true">4.1.</strong> Transforms and Coordinates</a></li><li class="chapter-item expanded "><a href="features/assets.html"><strong aria-hidden="true">4.2.</strong> Assets</a></li><li class="chapter-item expanded "><a href="features/hot-reload.html"><strong aria-hidden="true">4.3.</strong> Hot-Reloading Assets</a></li><li class="chapter-item expanded "><a href="features/input-handling.html"><strong aria-hidden="true">4.4.</strong> Input Handling</a></li><li class="chapter-item expanded "><a href="features/gltf.html"><strong aria-hidden="true">4.5.</strong> 3D Models (GLTF)</a></li><li class="chapter-item expanded "><a href="features/fixed-timestep.html"><strong aria-hidden="true">4.6.</strong> Fixed Timestep</a></li><li class="chapter-item expanded "><a href="features/audio.html"><strong aria-hidden="true">4.7.</strong> Audio</a></li></ol></li><li class="chapter-item expanded "><a href="pitfalls/_index.html"><strong aria-hidden="true">5.</strong> Common Pitfalls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pitfalls/build-errors.html"><strong aria-hidden="true">5.1.</strong> Strange build errors (like &quot;failed to select a version&quot;)</a></li><li class="chapter-item expanded "><a href="pitfalls/into-system.html"><strong aria-hidden="true">5.2.</strong> Error adding function as system</a></li><li class="chapter-item expanded "><a href="pitfalls/split-borrows.html"><strong aria-hidden="true">5.3.</strong> Borrow multiple fields from struct</a></li><li class="chapter-item expanded "><a href="pitfalls/performance.html"><strong aria-hidden="true">5.4.</strong> Slow Performance</a></li><li class="chapter-item expanded "><a href="pitfalls/ui-camera.html"><strong aria-hidden="true">5.5.</strong> UI is not displaying</a></li><li class="chapter-item expanded "><a href="pitfalls/2d-camera-z.html"><strong aria-hidden="true">5.6.</strong> Cannot see sprites in 2D</a></li><li class="chapter-item expanded "><a href="pitfalls/3d-not-rendering.html"><strong aria-hidden="true">5.7.</strong> Cannot see 3D model</a></li><li class="chapter-item expanded "><a href="pitfalls/file-formats.html"><strong aria-hidden="true">5.8.</strong> File Format Support</a></li><li class="chapter-item expanded "><a href="pitfalls/time.html"><strong aria-hidden="true">5.9.</strong> Bevy Time vs. Rust/OS time</a></li><li class="chapter-item expanded "><a href="pitfalls/ui-y-up.html"><strong aria-hidden="true">5.10.</strong> UI layout is inverted</a></li><li class="chapter-item expanded "><a href="pitfalls/uv-coordinates.html"><strong aria-hidden="true">5.11.</strong> Textures/Images are flipped</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/_index.html"><strong aria-hidden="true">6.</strong> Advanced Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/generic-systems.html"><strong aria-hidden="true">6.1.</strong> Generic Systems</a></li><li class="chapter-item expanded "><a href="patterns/manual-event-clear.html"><strong aria-hidden="true">6.2.</strong> Manual Event Clearing</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook/_index.html"><strong aria-hidden="true">7.</strong> Bevy Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/quit.html"><strong aria-hidden="true">7.1.</strong> Quit the App</a></li><li class="chapter-item expanded "><a href="cookbook/clear-color.html"><strong aria-hidden="true">7.2.</strong> Change the Background Color</a></li><li class="chapter-item expanded "><a href="cookbook/print-framerate.html"><strong aria-hidden="true">7.3.</strong> Show Framerate in Console</a></li><li class="chapter-item expanded "><a href="cookbook/mouse-grab.html"><strong aria-hidden="true">7.4.</strong> Grab the Mouse</a></li><li class="chapter-item expanded "><a href="cookbook/window-icon.html"><strong aria-hidden="true">7.5.</strong> Setting the Window Icon</a></li><li class="chapter-item expanded "><a href="cookbook/assets-ready.html"><strong aria-hidden="true">7.6.</strong> Track Assets Loading</a></li><li class="chapter-item expanded "><a href="cookbook/cursor2world.html"><strong aria-hidden="true">7.7.</strong> Convert cursor to world coordinates</a></li><li class="chapter-item expanded "><a href="cookbook/custom-projection.html"><strong aria-hidden="true">7.8.</strong> Custom Camera Projection</a></li><li class="chapter-item expanded "><a href="cookbook/pan-orbit-camera.html"><strong aria-hidden="true">7.9.</strong> Pan+Orbit Camera</a></li><li class="chapter-item expanded "><a href="cookbook/print-resources.html"><strong aria-hidden="true">7.10.</strong> List All Resource Types</a></li></ol></li><li class="chapter-item expanded "><a href="platforms/_index.html"><strong aria-hidden="true">8.</strong> Bevy on Different Platforms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/linux.html"><strong aria-hidden="true">8.1.</strong> Linux Desktop</a></li><li class="chapter-item expanded "><a href="platforms/macos.html"><strong aria-hidden="true">8.2.</strong> macOS Desktop</a></li><li class="chapter-item expanded "><a href="platforms/windows.html"><strong aria-hidden="true">8.3.</strong> Windows Desktop</a></li><li class="chapter-item expanded "><a href="platforms/wasm.html"><strong aria-hidden="true">8.4.</strong> Browser (WebAssembly)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/wasm/panic-console.html"><strong aria-hidden="true">8.4.1.</strong> Panic Messages</a></li><li class="chapter-item expanded "><a href="platforms/wasm/size-opt.html"><strong aria-hidden="true">8.4.2.</strong> Optimize for Size</a></li><li class="chapter-item expanded "><a href="platforms/wasm/gh-pages.html"><strong aria-hidden="true">8.4.3.</strong> Hosting on GitHub Pages</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="contributing.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Unofficial Bevy Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unofficial-bevy-cheat-book"><a class="header" href="#unofficial-bevy-cheat-book">Unofficial Bevy Cheat Book</a></h1>
<p>Concise practical reference to the
<a href="https://github.com/bevyengine/bevy">Bevy game engine</a>.</p>
<p>Covers useful syntax, features, programming patterns, and solutions for
common game development tasks.</p>
<p>Designed to be easy to read, straight to the point, using simple language
to focus on the important information.</p>
<p>While rich in content, this book does not aim to be exhaustive or complete. It
cannot feasibly cover every feature of bevy. It is my best attempt to teach
the most practically-relevant aspects.</p>
<p>The book has several sections:</p>
<ul>
<li><a href="./cheatsheet.html">Quick Reference</a>:
alphabetical listing of various Bevy and game dev jargon and concepts,
with quick definitions and links to relevant pages in the book</li>
<li><a href="./setup/_index.html">Bevy Setup Tips</a>:
Tips and tricks for your development tools (only some may be relevant to you)</li>
<li><a href="./programming/_index.html">Bevy Programming</a>:
overview of programming in Bevy</li>
<li><a href="./features/_index.html">Bevy Features</a>:
how to use various Bevy game engine features</li>
<li><a href="./pitfalls/_index.html">Common Pitfalls</a>:
common issues or surprises to watch out for</li>
<li><a href="./patterns/_index.html">Advanced Patterns</a>:
expert topics; non-obvious tricks or techniques; may be controversial</li>
<li><a href="./cookbook/_index.html">Bevy Cookbook</a>:
miscellaneous examples for specific common tasks</li>
<li><a href="./platforms/_index.html">Bevy on Different Platforms</a>:
information about using Bevy with different platforms and OSs</li>
</ul>
<p>Not intended to be read in order. Jump to whatever is useful to you!</p>
<p><em><strong>Welcome! May this book serve you well!</strong></em></p>
<p>(don't forget to
<a class="github-button" href="https://github.com/bevy-cheatbook/bevy-cheatbook" data-icon="octicon-star" aria-label="Star bevy-cheatbook/bevy-cheatbook on GitHub">Star</a>
the book's <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub repository</a>,
and consider <a href="https://github.com/sponsors/inodentry">donating</a> 🙂)</p>
<h2 id="recommended-additional-resources"><a class="header" href="#recommended-additional-resources">Recommended Additional Resources</a></h2>
<p>Bevy has a rich collection of <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official code
examples</a>.</p>
<p>Check out <a href="https://bevyengine.org/assets">bevy-assets</a>,
for community-made resources.</p>
<p>Our community is very friendly and helpful. Feel welcome to join the <a href="https://discord.gg/bevy">Bevy
Discord</a> to chat, ask questions, or get involved
in the project!</p>
<p>If you want to see some games made with Bevy, see
<a href="https://itch.io/games/tag-bevy">itch.io</a> or <a href="https://bevyengine.org/assets/#games">Bevy
Assets</a>.</p>
<h2 id="maintenance"><a class="header" href="#maintenance">Maintenance</a></h2>
<p>This version of the book is for Bevy release 0.6.</p>
<p>I intend to keep this book up-to-date and relevant with every new Bevy release.
I also try to regularly make improvements to it, when I can manage it.</p>
<h2 id="support-me"><a class="header" href="#support-me">Support Me</a></h2>
<p><a class="github-button" href="https://github.com/sponsors/inodentry" data-icon="octicon-heart" data-size="large" aria-label="Sponsor @inodentry on GitHub">GitHub Sponsors</a></p>
<p>I'd like to keep improving and maintaining this book, to provide a high-quality
independent learning resource for the Bevy community.</p>
<p>Your donation helps me work on such freely-available content. Thank you! ❤️</p>
<h2 id="support-bevy"><a class="header" href="#support-bevy">Support Bevy</a></h2>
<p>If you like the Bevy Game Engine, you should consider donating to the
official project.</p>
<p><a class="github-button" href="https://github.com/sponsors/cart" data-icon="octicon-heart" data-size="large" aria-label="Sponsor @cart on GitHub">GitHub Sponsors</a></p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright © 2021 Ida Iyes.</p>
<p>All code in the book is provided under the
<a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 License</a>.
At your option, you may also use it under the regular MIT License.</p>
<p>The text of the book is provided under the
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</p>
<p>Exception: If used for the purpose of contribution to the &quot;Official Bevy
Project&quot;, the entire content of the book may be used under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0
License</a>.</p>
<p>&quot;Official Bevy Project&quot; is defined as:</p>
<ul>
<li>Any files contained in the Git repository hosted at <a href="https://github.com/bevyengine/bevy">https://github.com/bevyengine/bevy</a></li>
<li>Any files contained in the Git repository hosted at <a href="https://github.com/bevyengine/bevy-website">https://github.com/bevyengine/bevy-website</a></li>
<li>Anything publicly visible on the <a href="https://bevyengine.org">bevyengine.org</a> website</li>
</ul>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Development of this book is hosted on
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<p>Please file GitHub Issues for any wrong/confusing/misleading information,
as well as suggestions for new content you'd like to be added to the book.</p>
<p>Contributions are accepted, with some limitations.</p>
<p>See the <a href="./contributing.html">Contributing</a> section for all the details.</p>
<h2 id="stability-warning"><a class="header" href="#stability-warning">Stability Warning</a></h2>
<p>Bevy is still a very new and experimental game engine! It has only been
public since August 2020!</p>
<p>While improvements have been happening at an incredible pace, and development
is active, Bevy simply hasn't yet had the time to mature.</p>
<p><em>There are no stability guarantees and breaking changes happen often!</em></p>
<p>Usually, it not hard to adapt to changes with new releases (or even track
the main git development branch), but you have been warned!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-reference-alphabetical-index--glossary"><a class="header" href="#quick-reference-alphabetical-index--glossary">Quick Reference: Alphabetical Index / Glossary</a></h1>
<p>This page lists many common terms and concepts that you may come across while working
with Bevy. It is in alphabetical order. Every entry has a brief definition, and links
to relevant places in this book, where it is explained, if any.</p>
<p>It contains both bevy-specific jargon (including advanced topics that might
not yet be covered by this book), as well as general game development or
computer graphics topics that are relevant to working with Bevy.</p>
<p>The list is not exhaustive. I try my best to expand it to include anything
that may be useful. If you notice any omissions / want something added,
file an issue on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>
or send me a message on <a href="https://discord.gg/bevy">Discord</a> (<code>Ida Iyes#0981</code>).</p>
<p>Bookmark this page in your browser, for a quick reference when working with Bevy!</p>
<p>(some of the links may be broken, as they refer to planned or unpublished
content. This book is WIP/incomplete; thank you for understanding! &lt;3 )</p>
<hr />
<h2 id="bevy-programming-jargon"><a class="header" href="#bevy-programming-jargon">Bevy Programming Jargon</a></h2>
<p>Terms and concepts related to Bevy-specific features and APIs.</p>
<table><thead><tr><th>Topic</th><th>Definition</th></tr></thead><tbody>
<tr><td><a href="./programming/app-builder.html">App / App Builder</a></td><td>Bevy entry point; setup all the things to run.</td></tr>
<tr><td><a href="./features/assets.html">Assets</a></td><td>The data used by your game. Typically loaded from external files, or generated procedurally using code.</td></tr>
<tr><td>Asset Loader</td><td>Implementation for loading a specific asset type from a specific file format.</td></tr>
<tr><td><a href="./features/assets.html#loading-using-assetserver"><code>AssetServer</code></a></td><td>Bevy API for accessing and loading assets from external data files.</td></tr>
<tr><td><a href="./programming/ec.html#component-bundles">Bundles</a></td><td>A &quot;template&quot; for easily spawning entities with a common set of component types.</td></tr>
<tr><td><a href="./programming/change-detection.html">Change Detection</a></td><td>Write logic that responds to data being changed.</td></tr>
<tr><td><a href="./programming/commands.html">Commands</a></td><td>Spawn/despawn entities, manage components and resources. Deferred until they can be safely applied.</td></tr>
<tr><td><a href="./programming/ec.html">Components</a></td><td>Per-entity data. Basic data primitive in Bevy.</td></tr>
<tr><td><a href="./programming/ec.html">Entities</a></td><td>ID for a set of component values. Often conceptually represents an &quot;object&quot;.</td></tr>
<tr><td><a href="./programming/events.html">Events</a></td><td>Communicate between systems. Send/receive data.</td></tr>
<tr><td><a href="./programming/world-exclusive.html">Exclusive Systems</a></td><td>Systems that have full access to the whole ECS world and do not run in parallel with any other systems.</td></tr>
<tr><td><a href="./features/fixed-timestep.html">Fixed Timestep</a></td><td>Run some logic at a fixed time interval. Important for physics and simulations.</td></tr>
<tr><td><a href="./features/assets.html#handles">Handles</a></td><td>ID for referring to an Asset in your game code. Reference counted (Bevy automatically unloads assets when there are no more handles).</td></tr>
<tr><td><a href="./features/assets.html#hot-reloading">Hot Reloading</a></td><td>Automatically reloading assets from files if they are changed while the game is running.</td></tr>
<tr><td><a href="./programming/labels.html">Labels</a></td><td>Names for systems, stages, and other things.</td></tr>
<tr><td><a href="./programming/local.html">Local Resources</a></td><td>Per-system data.</td></tr>
<tr><td><a href="./programming/non-send.html">Non-Send</a></td><td>Data that cannot be used in a multithreaded context, must be confined to a single thread.</td></tr>
<tr><td><a href="./programming/parent-child.html">Parent/Child Hierarchy</a></td><td>Entities in a hierarchical relationship.</td></tr>
<tr><td><a href="./programming/plugins.html">Plugins</a></td><td>Build the App in a modular way.</td></tr>
<tr><td><a href="./programming/queries.html">Queries</a></td><td>Find matching entities and access their component data.</td></tr>
<tr><td><a href="./programming/queries.html#query-filters">Query Filters</a></td><td>Criteria for narrowing down the entities to be accessed by a query.</td></tr>
<tr><td><a href="./programming/query-sets.html">Query Sets</a></td><td>Resolve query conflicts.</td></tr>
<tr><td><a href="./programming/removal-detection.html">Removal Detection</a></td><td>Write logic that responds to data being removed from the ECS.</td></tr>
<tr><td><a href="./programming/res.html">Resources</a></td><td>Global data for the whole app.</td></tr>
<tr><td><a href="./programming/run-criteria.html">Run Criteria</a></td><td>Low-level primitive for controlling if systems run.</td></tr>
<tr><td><a href="./features/scenes.html">Scenes</a></td><td>Collection of preconfigured entities that you can spawn into the world. Similar to &quot;prefabs&quot; in other game engines.</td></tr>
<tr><td><a href="./programming/system-order.html">Schedule (systems)</a></td><td>All the systems that Bevy runs every frame update, optimized to run on the task pool with maximum parallelism and performance.</td></tr>
<tr><td><a href="./programming/stages.html">Stages</a></td><td>Hard synchronization points for runtime scheduling.</td></tr>
<tr><td><a href="./programming/states.html">States</a></td><td>Control which systems run, by defining different &quot;modes&quot; your app can be in.</td></tr>
<tr><td><a href="./programming/systems.html">Systems</a></td><td>The functions that contain your game logic.</td></tr>
<tr><td><a href="./pitfalls/into-system.html#supported-types"><code>SystemParam</code>s</a></td><td>The acceptable Rust types to be used as function parameters in Bevy systems.</td></tr>
<tr><td><a href="./programming/system-chaining.html">System Chaining</a></td><td>Combine multiple Rust functions into one big system.</td></tr>
<tr><td><a href="./programming/system-order.html">System Order</a></td><td>Control the runtime order of execution of systems.</td></tr>
<tr><td><a href="./programming/system-sets.html">System Sets</a></td><td>Group multiple systems together to apply common properties (labels, ordering, states, run criteria).</td></tr>
<tr><td><a href="./features/textures.html">Texture</a></td><td>Asset type, typically an image (but more generally any data) that can be sampled by the GPU during rendering (in a shader).</td></tr>
<tr><td><a href="./features/transforms.html">Transforms</a></td><td>Position and orientation of an object. May be relative to a parent object.</td></tr>
<tr><td><a href="./features/assets.html#untyped-handles">Untyped Handles</a></td><td>Asset Handle that can refer to an asset regardless of the asset type.</td></tr>
<tr><td><a href="./features/assets.html#weak-handles">Weak Handles</a></td><td>Asset Handles that are not reference-counted (do not prevent the asset from being unloaded).</td></tr>
<tr><td><a href="./programming/world-exclusive.html">World</a></td><td>The underlying data structure / storage of the ECS. Contains all component and resource data.</td></tr>
</tbody></table>
<h2 id="ecosystem-jargon"><a class="header" href="#ecosystem-jargon">Ecosystem Jargon</a></h2>
<p>Terms and concepts related to the community and ecosystem around bevy and the
development of the project, such as libraries and technologies that bevy uses.</p>
<table><thead><tr><th>Topic</th><th>Definition</th></tr></thead><tbody>
<tr><td><a href="https://bevyengine.org/assets">Assets; Bevy Assets</a></td><td>Page on the Bevy Website listing community-made plugins and content (not to be confused with Assets, as in your game's data).</td></tr>
<tr><td>Data-driven</td><td>Programming style / paradigm, where functionality is thought of in terms of the data it works with. Bevy is based on this philosophy.</td></tr>
<tr><td><a href="./programming/ecs-intro.html">ECS</a></td><td>The data storage / programming paradigm Bevy uses. Conceptually like a database. Bevy is often compared to other ECS implementations.</td></tr>
<tr><td><a href="./setup/bevy-config.html#bevy-cargo-features">Features (cargo)</a></td><td>A way to configure what optional functionality is included in your build.</td></tr>
<tr><td>Flexbox</td><td>The layout model used in Bevy UI (originates from CSS in web browsers).</td></tr>
<tr><td><a href="./features/input-handling.html#controller--gamepad--joystick">GILRS</a></td><td>The library that Bevy uses for controller/joystick support.</td></tr>
<tr><td><a href="./features/gltf.html">GLTF</a></td><td>File format for 3D assets; can contain meshes, textures, materials, scenes.</td></tr>
<tr><td><a href="./features/audio.html">Kira</a></td><td>3rd-party audio library often used with Bevy (<code>bevy_kira_audio</code> plugin), much more feature-rich than Bevy's own audio.</td></tr>
<tr><td><a href="./setup/bevy-git.html">main (bevy main)</a></td><td>Development version of Bevy; git branch containing the latest unreleased changes.</td></tr>
<tr><td>Metal</td><td>Low-level system API for accessing GPU hardware on Apple systems (macOS/iOS).</td></tr>
<tr><td>OpenGL</td><td>Legacy GPU API for systems that do not support Vulkan. Not yet supported by Bevy.</td></tr>
<tr><td><a href="./setup/unofficial-plugins.html">Plugins (3rd-party crates)</a></td><td>Libraries made by the community that can be added to your Bevy App.</td></tr>
<tr><td>Vulkan</td><td>Low-level system API for accessing GPU hardware. The interface to the graphics driver. Available on most platforms except Apple.</td></tr>
<tr><td><a href="./platforms/wasm.html">WebAssembly (WASM)</a></td><td>New technology that allows running software like Bevy inside of a web browser.</td></tr>
<tr><td>WebGPU (WGPU)</td><td>The cross-platform GPU API that Bevy uses. Allows using modern GPU features safely across different platforms (desktop/mobile/web).</td></tr>
<tr><td><a href="./features/windowing.html">Winit</a></td><td>The library that Bevy uses for windowing (managing the OS windows to display in)</td></tr>
</tbody></table>
<h2 id="game-development-jargon"><a class="header" href="#game-development-jargon">Game Development Jargon</a></h2>
<p>General game development concepts that are applicable to working with Bevy.</p>
<table><thead><tr><th>Topic</th><th>Definition</th></tr></thead><tbody>
<tr><td><a href="./features/assets.html">Assets</a></td><td>The data used by your game. Typically loaded from external files, or generated procedurally using code.</td></tr>
<tr><td><a href="./features/camera.html">Camera</a></td><td>Entity representing a &quot;view&quot; into the game world, to be rendered.</td></tr>
<tr><td><a href="./features/transforms.html#bevys-coordinate-system">Coordinate System</a></td><td>Orientation of the X/Y/Z axes, defining the 3D space.</td></tr>
<tr><td><a href="./features/fixed-timestep.html">Fixed Timestep</a></td><td>Run some logic at a fixed time interval. Important for physics and simulations.</td></tr>
<tr><td><a href="./features/materials.html">Material</a></td><td>The shading properties for a surface to be drawn by the GPU, such as its color/texture, how shiny it is, ...</td></tr>
<tr><td><a href="./features/meshes.html">Mesh</a></td><td>3D geometry data, consists of vertices, typically arranged into many triangles. Required for the GPU to draw an object.</td></tr>
<tr><td><a href="./programming/parent-child.html">Parent/Child Hierarchy</a></td><td>Entities in a hierarchical relationship.</td></tr>
<tr><td>Procedural Generation</td><td>Creating game assets using code/math/algorithms (often done at runtime, instead of loading asset files).</td></tr>
<tr><td>Raycast</td><td>Calculating a simulated &quot;ray&quot; in the game world. Used, for example, for checking what object is under the mouse cursor.</td></tr>
<tr><td><a href="./features/scenes.html">Scenes</a></td><td>Collection of preconfigured entities that you can spawn into the world. Similar to &quot;prefabs&quot; in other game engines.</td></tr>
<tr><td>Shaders</td><td>Code that runs on the GPU. Typically for rendering graphics, but also for general computations.</td></tr>
<tr><td><a href="./features/sprites.html">Sprites</a></td><td>Game object that is a 2D rectangle displaying an image. Most 2D games are made from these.</td></tr>
<tr><td><a href="./features/textures.html">Texture</a></td><td>Typically an image (but more generally any data) that can be sampled by the GPU during rendering (in a shader).</td></tr>
<tr><td><a href="./features/transforms.html">Transforms</a></td><td>Position and orientation of an object. May be relative to a parent object.</td></tr>
<tr><td>UI</td><td>User Interfaces like menus and in-game HUDs, typically displayed as overlays on top.</td></tr>
</tbody></table>
<h2 id="rendering-jargon"><a class="header" href="#rendering-jargon">Rendering Jargon</a></h2>
<p>Concepts that come up when working with computer graphics and the GPU, as applicable to Bevy.</p>
<table><thead><tr><th>Topic</th><th>Definition</th></tr></thead><tbody>
<tr><td>Anisotropic Filtering</td><td>Method of sampling a texture that accounts for the angle between the surface and the camera, resulting in better visual quality.</td></tr>
<tr><td>Anti-Aliasing</td><td>Techniques to reduce aliasing artifacts (shimmering or jagged edges, when there is too much detail for the display resolution).</td></tr>
<tr><td>Batching</td><td>Combining compatible data from many meshes/entities together, so that it can be drawn by the GPU all at once.</td></tr>
<tr><td><a href="./features/camera.html">Camera</a></td><td>Entity representing a &quot;view&quot; into the game world, to be rendered.</td></tr>
<tr><td>Compute Shaders / GPU Compute</td><td>A way to use the GPU for general data processing.</td></tr>
<tr><td><a href="./features/transforms.html#bevys-coordinate-system">Coordinate System</a></td><td>Orientation of the X/Y/Z axes, defining the 3D space.</td></tr>
<tr><td>Culling</td><td>Figuring out which parts of the scene don't need to be drawn and skipping them to improve performance.</td></tr>
<tr><td>Directional Light</td><td>Global light source that illuminates the whole world, at a specified angle/direction. Typically models the sun in outdoor scenes.</td></tr>
<tr><td>Draw Call</td><td>Telling the GPU to render something. Expensive; for best performance, aim to draw everything you need with the fewest draw calls.</td></tr>
<tr><td>Frustum</td><td>The space/volume that is visible from a camera. Everything that the camera can see.</td></tr>
<tr><td><a href="./features/meshes.html">Indices / Index Buffer</a></td><td>A way to make mesh data more compact (to save memory) by deduplicating vertices.</td></tr>
<tr><td>Instancing</td><td>A way to tell the GPU to draw many copies of the same mesh efficiently. Useful for things like vegetation (lots of grass / trees).</td></tr>
<tr><td><a href="./features/materials.html">Material</a></td><td>The shading properties for a surface to be drawn by the GPU, such as its color/texture, how shiny it is, ...</td></tr>
<tr><td><a href="./features/meshes.html">Mesh</a></td><td>3D geometry data, consists of vertices, typically arranged into many triangles. Required for the GPU to draw an object.</td></tr>
<tr><td>Mipmaps</td><td>Textures with data available in many sizes (like 64x64, 32x32, 16x16, 8x8, ...). The GPU automatically uses the most appropriate.</td></tr>
<tr><td><a href="./cookbook/msaa.html">MSAA</a></td><td>Multi-Sample Anti-Aliasing: hardware AA method: for pixels along edges of meshes, the GPU will render multiple samples.</td></tr>
<tr><td>Normals / Normal Vectors</td><td>The direction perpendicular to a surface. Useful for shading, to compute how light interacts with the surface.</td></tr>
<tr><td>Normal Maps</td><td>A way to add extra detail to a 3D object, using a texture that changes the normals to affect how light interacts with it.</td></tr>
<tr><td><a href="./features/pbr.html">Physically-Based Rendering</a></td><td>Modern realistic 3D graphics technique that uses materials that model physical properties, like how rough or metallic a surface is.</td></tr>
<tr><td>Point Light</td><td>A light source that radiates in all directions from a given position, like a lamp or candle.</td></tr>
<tr><td>Post-Processing</td><td>After rendering (but before displaying), apply some visual effects to the whole image.</td></tr>
<tr><td>Render Graph</td><td>Bevy's abstraction for modular configurable rendering. Connects &quot;nodes&quot; together to enable various graphical features.</td></tr>
<tr><td>Render Pipeline</td><td>The procedure to be executed by the GPU to draw something. Includes the shaders to run, as well as setting fixed hardware parameters.</td></tr>
<tr><td>Sampler / Sampling (textures)</td><td>How the GPU picks a value (like a color) from a specific position on a texture.</td></tr>
<tr><td>Shaders</td><td>Code that runs on the GPU. Typically for rendering graphics, but also for general computations.</td></tr>
<tr><td><a href="./features/textures.html">Texture</a></td><td>Typically an image (but more generally any data) that can be sampled by the GPU during rendering (in a shader).</td></tr>
<tr><td>Texel</td><td>A pixel that is part of a texture.</td></tr>
<tr><td><a href="./features/transforms.html">Transforms</a></td><td>Position and orientation of an object. May be relative to a parent object.</td></tr>
<tr><td>Uniforms</td><td>Shader input data that is &quot;global&quot; for the whole mesh (unlike Vertex Attributes, which are per-vertex).</td></tr>
<tr><td>UVs / UV coordinates</td><td>Texture coordinates, used to map a texture to a mesh. The position on the texture that each vertex corresponds to.</td></tr>
<tr><td><a href="./features/meshes.html">Vertex / Vertices</a></td><td>Building block of Meshes, typically a point in 3D space, with associated vertex attributes.</td></tr>
<tr><td><a href="./features/meshes.html">Vertex Attributes</a></td><td>Data associated with each vertex in a mesh, such as its position, color, UVs, normals, etc.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-setup-tips"><a class="header" href="#bevy-setup-tips">Bevy Setup Tips</a></h1>
<p>This chapter is a collection of additional tips for configuring
your project or development tools, collected from the Bevy
community, beyond what is covered in Bevy's <a href="https://bevyengine.org/learn/book/getting-started">official setup
documentation</a>.</p>
<p>If you know of anything that would be nice to add, please file an issue on
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a> or ping me
on Discord (<code>@Ida Iyes#0981</code>).</p>
<hr />
<p>Also see the following other relevant content from this book:</p>
<ul>
<li><a href="setup/../platforms/_index.html">Platform-specific information</a></li>
<li><a href="setup/../pitfalls/performance.html">Configuration to fix slow performance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-bleeding-edge-bevy-bevy-main"><a class="header" href="#using-bleeding-edge-bevy-bevy-main">Using bleeding-edge Bevy (bevy main)</a></h1>
<p>Bevy development moves very fast, and there are often exciting new things that
are yet unreleased. This page will give you advice about using development
versions of bevy.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>If you are not using any 3rd-party plugins and just want to use the bevy
main development branch:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.6&quot;

[patch.crates-io]
bevy = { git = &quot;https://github.com/bevyengine/bevy&quot; }
</code></pre>
<p>For more info, read on.</p>
<h2 id="should-you-use-bleeding-edge-bevy"><a class="header" href="#should-you-use-bleeding-edge-bevy">Should you use bleeding-edge bevy?</a></h2>
<p>Currently, bevy does not make patch releases, only major releases when there
are enough exciting new changes for a flashy press release. The latest release
is often missing the latest bug fixes, usability improvements, and features. It
may be compelling to join in on the action!</p>
<p>If you are new to bevy, this might not be for you; you might be more
comfortable using the released version. It will have the best compatibility
with community plugins and documentation.</p>
<p>The biggest downside to using unreleased versions of bevy is 3rd-party plugin
compatibility. Bevy is unstable and breaking changes happen often. However,
many actively-maintained community plugins have branches for tracking the
latest bevy main branch, although they might not be fully up-to-date. It's
possible that a plugin you want to use does not work with the latest changes
in bevy main, and you may have to fix it yourself.</p>
<p>The frequent breaking changes might not be a problem for you, though. Thanks
to cargo, you can update bevy at your convenience, whenever you feel ready
to handle any possible breaking changes.</p>
<p>If you choose to use bevy main, you are highly encouraged to
interact with the Bevy community on <a href="https://discord.gg/bevy">Discord</a> and
<a href="https://github.com/bevyengine/bevy">GitHub</a>, so you can keep track of what's
going on, get help, or participate in discussions.</p>
<h2 id="common-pitfall-mysterious-compile-errors"><a class="header" href="#common-pitfall-mysterious-compile-errors">Common pitfall: mysterious compile errors</a></h2>
<p>When changing between different versions of Bevy (say, transitioning an existing
project from the released version to the git version), you might get lots of
strange unexpected build errors.</p>
<p>You can typically fix them by removing <code>Cargo.lock</code> and the <code>target</code> directory:</p>
<pre><code class="language-sh">rm -rf Cargo.lock target
</code></pre>
<p>See <a href="setup/../pitfalls/build-errors.html">this page</a> for more info. See this <a href="https://github.com/rust-lang/cargo/issues/9994">cargo
issue</a> about this bug.</p>
<p>If you are still getting errors, it is probably because cargo is trying
to use multiple different versions of bevy in your dependency tree
simultaneously. This can happen if some of the plugins you use have specified
a different bevy version from your project. This is annoying, but easy to
fix. Read the next section below for advice on how to configure your project
in a way that minimizes the chances of this happening.</p>
<h2 id="how-to-use-bleeding-edge-bevy"><a class="header" href="#how-to-use-bleeding-edge-bevy">How to use bleeding-edge bevy?</a></h2>
<p>The recommended way is using a cargo patch:</p>
<pre><code class="language-toml">[dependencies]
# keep this as normal
bevy = &quot;0.6&quot;

[patch.crates-io]
# override it with bevy from git
bevy = { git = &quot;https://github.com/bevyengine/bevy&quot; }
# or if you have it cloned locally:
#bevy = { path = &quot;../bevy&quot; }
</code></pre>
<p>Doing it this way will tell cargo to replace the version of bevy in your
entire dependency tree, including for 3rd-party plugins (assuming that they
also list the crates-io version (<code>bevy = &quot;0.6&quot;</code>) in their dependencies).</p>
<p>This works better than specifying the <code>git</code> or <code>path</code> directly in your
<code>[dependencies]</code>, because you avoid the risk of potentially having multiple
different versions of bevy in your dependency tree, if any 3rd-party plugins
you use have specified a different version.</p>
<p>Unfortunately, some plugin authors put the git version directly in their
<code>[dependencies]</code>, which breaks the above setup. This can be fixed by adding
another cargo patch, to also override the git repository:</p>
<pre><code class="language-toml">[patch.&quot;https://github.com/bevyengine/bevy&quot;]
bevy = { path = &quot;../bevy&quot; }
</code></pre>
<p>Some 3rd-party plugins depend on specific bevy sub-crates, rather than the
full bevy. You may additionally have to patch those individually:</p>
<pre><code class="language-toml">[patch.crates-io]
bevy = { path = &quot;../bevy&quot; }
# specific crates as needed by the plugins you use (check their `Cargo.toml`)
bevy_ecs = { path = &quot;../bevy/crates/bevy_ecs&quot; }
bevy_math = { path = &quot;../bevy/crates/bevy_math&quot; }
# ... and so on
</code></pre>
<h2 id="updating-bevy"><a class="header" href="#updating-bevy">Updating Bevy</a></h2>
<p>The <code>Cargo.lock</code> file keeps track of the exact version (including the git
commit) you are working with. You will not be affected by new changes in
upstream bevy, until you update manually.</p>
<p>To update, run:</p>
<pre><code class="language-sh">cargo update
</code></pre>
<p>If you delete or lose the <code>Cargo.lock</code> file, cargo will have to regenerate
it and update your bevy in the process. To prevent this, you should add it
to your git repository along with your source code. Alternatively, you can
be more explicit and require an exact git commit hash in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">bevy = { git = &quot;https://github.com/bevyengine/bevy&quot;, rev = &quot;7a1bd34e&quot; }
</code></pre>
<h2 id="advice-for-plugin-authors"><a class="header" href="#advice-for-plugin-authors">Advice for plugin authors</a></h2>
<p>If you are publishing a plugin for bevy, and you want to support bevy main,
it is recommended that you:</p>
<ul>
<li>Do it on a separate branch in your repository, to keep it separate from
your main version for the released version of bevy. </li>
<li>Put information in your README to tell people how to find it.</li>
<li>Configure your <code>Cargo.toml</code> as shown <a href="setup/bevy-git.html#how-to-use-bleeding-edge-bevy">above</a>.</li>
<li>Set up CI to notify you if your plugin is broken by new changes in bevy.</li>
</ul>
<h3 id="cargotoml-and-dependencies"><a class="header" href="#cargotoml-and-dependencies"><code>Cargo.toml</code> and dependencies</a></h3>
<p>Publish your plugin with a <code>Cargo.toml</code> as shown on this page.</p>
<p>By specifying the released version of bevy, even in your bevy main tracking
branch, you make life easier for your users. If they want to use a local clone,
a specific commit, or their own fork (instead of the upstream repository),
they can easily do it with a simple cargo patch in their project.</p>
<p>If you specify the bevy git repository directly in your dependencies, you
are making such workflows more difficult.</p>
<p>You can safely include the cargo patch, too. It would apply when you are
working on your plugin, so that you build against the correct version of bevy,
but it would not affect your users, letting them use whatever bevy they want.</p>
<h3 id="ci-setup"><a class="header" href="#ci-setup">CI Setup</a></h3>
<p>Here is an example for GitHub Actions. This will run at 8:00 AM (UTC) every day
to verify that your code still compiles. GitHub will notify you when it fails.</p>
<pre><code class="language-yaml">name: check if code still compiles

on:
  schedule:
    - cron: '0 8 * * *'

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Install Dependencies
        run: sudo apt-get update &amp;&amp; sudo apt-get install --no-install-recommends pkg-config libx11-dev libasound2-dev libudev-dev

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Check code
        run: cargo update &amp;&amp; cargo check --lib --examples
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-editor--ide"><a class="header" href="#text-editor--ide">Text Editor / IDE</a></h1>
<p>This page contains tips for different text editors and IDEs.</p>
<p>Bevy is, for the most part, like any other Rust project. If your editor/IDE
is set up for Rust, that might be all you need. This page contains additional
information that may be useful for Bevy specifically.</p>
<p>If you have any suggestions for how to improve this page, file an issue on
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a> or ping me on
Discord (<code>@Ida Iyes#0981</code>).
Your help collecting useful information would be much appreciated! &lt;3</p>
<h2 id="cargo_manifest_dir"><a class="header" href="#cargo_manifest_dir"><code>CARGO_MANIFEST_DIR</code></a></h2>
<p>When running your app/game, Bevy will search for the <code>assets</code> folder in
the path specified in the <code>CARGO_MANIFEST_DIR</code> environment variable. This
allows <code>cargo run</code> to work correctly from the terminal.</p>
<p>If you are using your editor/IDE to run your project in a non-standard way
(say, inside a debugger), you have to be sure to set that correctly.</p>
<h2 id="vscode"><a class="header" href="#vscode">VSCode</a></h2>
<p>Here is a snippet showing how to create a run configuration for debugging Bevy
(with lldb):</p>
<p>(this is for development on Bevy itself, and testing with the <code>breakout</code> example)</p>
<p>(adapt to your needs if using for your project)</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;lldb&quot;,
    &quot;request&quot;: &quot;launch&quot;,
    &quot;name&quot;: &quot;Debug example 'breakout'&quot;,
    &quot;cargo&quot;: {
        &quot;args&quot;: [
            &quot;build&quot;,
            &quot;--example=breakout&quot;,
            &quot;--package=bevy&quot;
        ],
        &quot;filter&quot;: {
            &quot;name&quot;: &quot;breakout&quot;,
            &quot;kind&quot;: &quot;example&quot;
        }
    },
    &quot;args&quot;: [],
    &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
    &quot;env&quot;: {
        &quot;CARGO_MANIFEST_DIR&quot;: &quot;${workspaceFolder}&quot;,
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-bevy"><a class="header" href="#configuring-bevy">Configuring Bevy</a></h1>
<p>Bevy is very modular and configurable. It is implemented as many separate
cargo crates, allowing you to remove the parts you don't need. Higher-level
functionality is built on top of lower-level foundational crates, and can
be disabled or replaced with alternatives.</p>
<p>The lower-level core crates (like the Bevy ECS) can also be used completely
standalone, or integrated into otherwise non-Bevy projects.</p>
<h2 id="bevy-cargo-features"><a class="header" href="#bevy-cargo-features">Bevy Cargo Features</a></h2>
<p>In Bevy projects, you can enable/disable various parts of Bevy using cargo features.</p>
<p>Here I will explain some of them and why you might want to change them.</p>
<p>Many common features are enabled by default. If you want to disable some of
them, note that, unfortunately, Cargo does not let you disable individual
default features, so you need to disable all default bevy features and
re-enable the ones you need.</p>
<p>Here is how you might configure your Bevy:</p>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.6&quot;
# Disable the default features if there are any that you do not want
default-features = false
features = [
  # These are the default features:
  # (keep whichever you like)
  &quot;render&quot;,
  &quot;bevy_winit&quot;,
  &quot;bevy_gilrs&quot;,
  &quot;bevy_audio&quot;,
  &quot;png&quot;,
  &quot;hdr&quot;,
  &quot;vorbis&quot;,
  &quot;x11&quot;,
  &quot;filesystem_watcher&quot;,
  # These are other features that may be of interest:
  # (add any of these that you need)
  &quot;bmp&quot;,
  &quot;tga&quot;,
  &quot;dds&quot;,
  &quot;jpeg&quot;,
  &quot;wav&quot;
  &quot;flac&quot;,
  &quot;mp3&quot;,
  &quot;subpixel_glyph_atlas&quot;,
  &quot;dynamic&quot;,
  &quot;serialize&quot;,
  &quot;trace&quot;,
  &quot;trace_tracy&quot;,
  &quot;trace_chrome&quot;,
  &quot;wgpu_trace&quot;,
  &quot;wayland&quot;
]
</code></pre>
<p>(See <a href="https://docs.rs/crate/bevy/0.6.0/features">here</a> for a full list of
Bevy's cargo features.)</p>
<h3 id="graphics--rendering"><a class="header" href="#graphics--rendering">Graphics / Rendering</a></h3>
<p>For a graphical application or game (most Bevy projects),
you need <code>render</code>, <code>bevy_winit</code>.</p>
<p>If you don't need graphics (like for a dedicated game server, scientific
simulation, etc.), you may remove these features.</p>
<p>There are also <a href="https://bevyengine.org/assets/#backends">community-made alternative backend
crates</a> that could replace Bevy's
default graphics, if you want that for any reason.</p>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<p>Bevy's audio is very limited in functionality and
somewhat broken. It is recommended that you use the
<a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a> plugin
instead. Disable <code>bevy_audio</code> and <code>vorbis</code>.</p>
<p>See <a href="setup/../features/audio.html">this page</a> for more information.</p>
<h3 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h3>
<p>You can use the relevant cargo features to enable/disable support for loading
assets (images/textures and audio) with various different file formats.</p>
<p>See <a href="setup/../pitfalls/file-formats.html">this page</a> for more information.</p>
<h3 id="input-devices"><a class="header" href="#input-devices">Input Devices</a></h3>
<p>If you do not care about controller/joystick support, you can disable <code>bevy_gilrs</code>.</p>
<h3 id="linux-windowing-backend"><a class="header" href="#linux-windowing-backend">Linux Windowing Backend</a></h3>
<p>On <a href="setup/../platforms/linux.html">Linux</a>, you can choose to support X11, Wayland,
or both. Only <code>x11</code> is enabled by default, as it is the legacy system
that should be compatible with most/all distributions, to make your builds
smaller and compile faster. You might want to additionally enable <code>wayland</code>,
to fully and natively support modern Linux environments. This will add a few
extra transitive dependencies to your project.</p>
<h3 id="development-features"><a class="header" href="#development-features">Development Features</a></h3>
<p>While you are developing your project, these features might be useful:</p>
<h4 id="dynamic-linking"><a class="header" href="#dynamic-linking">Dynamic Linking</a></h4>
<p><code>dynamic</code> causes Bevy to be built and linked as a shared/dynamic library
(<code>*.so</code> on Linux, <code>*.dylib</code> on macOS, <code>*.DLL</code> on Windows). This will make
incremental builds <em>much</em> faster, which can reduce frustration when you are
trying to test out changes to your code. On my machine, my projects recompile
in ~2 sec without this option, and in ~0.5 sec with it enabled. This makes
starting the game feel almost instant.</p>
<p>This is known to work very well on Linux, but you may encounter issues on
other platforms. YMMV. I've heard people have issues on Windows.</p>
<p>Do not enable this for release builds you intend to publish to other people;
it introduces unneeded complexity (you need to bundle extra files) and
potential for things to not work correctly. Use this only during development.</p>
<p>For this reason, it may be convenient to specify the feature as a commandline
option to cargo, instead of putting it in your <code>Cargo.toml</code>. Simply run your
project like this:</p>
<pre><code class="language-sh">cargo run --features bevy/dynamic
</code></pre>
<h4 id="tracing"><a class="header" href="#tracing">Tracing</a></h4>
<p>The features <code>trace</code> and <code>wgpu_trace</code> may be useful for profiling and
diagnosing performance issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dev-tools-and-editors-for-bevy"><a class="header" href="#dev-tools-and-editors-for-bevy">Dev Tools and Editors for Bevy</a></h1>
<p>Bevy does not yet have an official editor or other such tools. An official
editor is planned as a long-term future goal. In the meantime, here are
some community-made tools to help you.</p>
<hr />
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy-inspector-egui"><code>bevy_inspector_egui</code></a>
gives you a simple editor-like property inspector window in-game. It lets
you modify the values of your components and resources in real-time as the
game is running.</p>
<p><a href="https://github.com/jakobhellermann/bevy_editor_pls"><code>bevy_editor_pls</code></a>
is an editor-like interface that you can embed into your game. It has even
more features, like switching app states, fly camera, performance diagnostics,
and inspector panels.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy_mod_debugdump"><code>bevy_mod_debugdump</code></a>
is a tool to help visualize your <a href="setup/../programming/app-builder.html">App Schedule</a>
(all of the registered <a href="setup/../programming/systems.html">systems</a> with
their <a href="setup/../programming/system-order.html">ordering dependencies</a> and
<a href="setup/../programming/stages.html">stages</a>), and the Bevy Render Graph.</p>
<p><a href="https://github.com/MinerSebas/bevy_lint"><code>bevy_lint</code></a> is a linter (based on
<code>dylint</code>) that can automatically check your Bevy code for some common issues.</p>
<p>If you are getting confusing/cryptic compiler error messages (like
<a href="setup/../pitfalls/into-system.html">these</a>) and you cannot figure them out,
<a href="https://github.com/jakobhellermann/bevycheck"><code>bevycheck</code></a> is a tool you
could use to help diagnose them. It tries to provide more user-friendly
Bevy-specific error messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-3rd-party-plugins"><a class="header" href="#using-3rd-party-plugins">Using 3rd-party Plugins</a></h1>
<p>There is a growing ecosystem of unofficial community-made plugins for Bevy,
which provide a lot of functionality that is not officially included with
the engine. For many kinds/genres of games, you might greatly benefit from
using some of these.</p>
<p>To find such plugins, you should search the <a href="https://bevyengine.org/assets/">Bevy
Assets</a> page on the official Bevy website. This
is the official registry of known community-made things for Bevy. If you
publish your own plugins for Bevy, you should <a href="https://github.com/bevyengine/bevy-assets">contribute a link to be added
to that page</a>.</p>
<p>Please beware that some 3rd-party plugins may use unusual licenses. Be sure
to check the license before using a plugin in your project.</p>
<hr />
<p>Other pages in this book with valuable information when using 3rd-party plugins:</p>
<ul>
<li>Some plugins may require you to <a href="setup/./bevy-config.html">configure Bevy in some specific way</a>.</li>
<li>If you are <a href="setup/./bevy-git.html">using bleeding-edge unreleased Bevy (main)</a>, you may encounter difficulties with plugin compatibility.</li>
</ul>
<h2 id="plugin-recommendations"><a class="header" href="#plugin-recommendations">Plugin Recommendations</a></h2>
<p>This here is my personal, curated, opinionated list of recommendations,
featuring the most important plugins (in my opinion) in the Bevy ecosystem.</p>
<p>My goal here is to help direct new Bevy users to some known-good resources, so you can
start working on the kinds of games you want to make. :)</p>
<p>The plugins listed here are compatible with the latest Bevy release and use
permissive licenses (like Bevy itself).</p>
<p>This page is very limited. I can only recommend plugins I know enough
about. Please also check the <a href="https://bevyengine.org/assets">Bevy Assets</a>
page to find even more things. :)</p>
<h3 id="development-tools-and-editors"><a class="header" href="#development-tools-and-editors">Development Tools and Editors</a></h3>
<p><a href="setup/./bevy-tools.html">These are listed on a separate page.</a></p>
<h3 id="code-helpers"><a class="header" href="#code-helpers">Code Helpers</a></h3>
<p><a href="https://github.com/inodentry/bevy_loading"><code>bevy_loading</code></a> is a helper for
<a href="setup/../programming/states.html">state</a> transitions. It lets you register systems
that report their progress, tracks the progress, and transitions to the next
state when they are all ready. Most useful for loading screens, but can be used
more generally. Can also track the loading of <a href="setup/../features/assets.html">assets</a>.</p>
<p><a href="https://github.com/NiklasEi/bevy_asset_loader"><code>bevy_asset_loader</code></a> is a
more flexible and opinionated helper for managing and loading game assets.
Uses custom annotations to let you declare your assets more conveniently.</p>
<h3 id="audio-1"><a class="header" href="#audio-1">Audio</a></h3>
<p>Use <a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a> instead of the built-in <code>bevy_audio</code>.</p>
<p>The built-in audio is very limited in features, and you are likely going to
need this plugin for pretty much any game with audio.</p>
<p>See <a href="setup/../features/audio.html">this page</a> for help on how to set it up.</p>
<h3 id="camera"><a class="header" href="#camera">Camera</a></h3>
<p><a href="https://github.com/BlackPhlox/bevy_config_cam"><code>bevy_config_cam</code></a> is a nice
plugin for easily adding camera controls to your Bevy 3D project. It gives
you a a choice of various common camera behaviors (like follow, top-view,
FPS-style, free-roaming).</p>
<p>Cameras are something that can be very game-specific. As you progress with
your project, you would probably want to implement your own custom camera
control logic for your game. However, this plugin is amazing when you are
starting out on a new project.</p>
<h3 id="tilemap"><a class="header" href="#tilemap">Tilemap</a></h3>
<p>If you are making a 2D game based on a tile-map, there are plugins to
help do it efficiently with high performance. It is better to use one
of these plugins, instead of just spawning lots of individual Bevy
<a href="setup/../features/sprites.html">Sprites</a> for each tile.</p>
<ul>
<li><a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>
<ul>
<li>Uses one ECS Entity per tile, with efficient custom rendering.</li>
<li>Lets you work with the tilemap in an ECS-idiomatic way.</li>
<li>Can be a little complex to set up / configure / spawn the tilemap.</li>
<li>Lots of features: Square/Hexagon/Isometric grids, animation, layers, chunks, optional ldtk/tiled support, ...</li>
</ul>
</li>
<li><a href="https://github.com/joshuajbouw/bevy_tilemap"><code>bevy_tilemap</code></a>
<ul>
<li>Another feature-rich plugin, but this one is not ECS-idiomatic (the whole map is one entity).</li>
<li>Designed to work well for infinite/endless or dynamically-generated maps.</li>
<li>API is quite refined and stable, has good documentation.</li>
</ul>
</li>
<li><a href="https://github.com/forbjok/bevy_simple_tilemap"><code>bevy_simple_tilemap</code></a>
<ul>
<li>Limited in features, easy to use if you just need to efficiently render a grid of square tiles.</li>
</ul>
</li>
</ul>
<h3 id="shapes--vector-graphics--canvas"><a class="header" href="#shapes--vector-graphics--canvas">Shapes / Vector Graphics / Canvas</a></h3>
<p>If you want to draw 2D shapes, use the
<a href="https://github.com/Nilirad/bevy_prototype_lyon"><code>bevy_prototype_lyon</code></a> plugin.</p>
<h3 id="game-ai"><a class="header" href="#game-ai">Game AI</a></h3>
<p><a href="https://github.com/zkat/big-brain"><code>big-brain</code></a> is a fantastic plugin for game AI behaviors (Utility AI).</p>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<p>If you want an alternative to Bevy UI, see <a href="https://github.com/mvlabat/bevy_egui"><code>bevy_egui</code></a>.
This integrates the <a href="https://github.com/emilk/egui"><code>egui</code> toolkit</a> into Bevy.</p>
<p>It is an immediate-mode GUI library (like the popular Dear Imgui, but in Rust).</p>
<p>It is very feature-rich and contains lots of widgets.</p>
<p>It was not really designed for making flashy gamey UIs (though it may very
well be fine for your game). It's great for editor-like UIs, debug UIs,
or non-game applications.</p>
<h3 id="physics"><a class="header" href="#physics">Physics</a></h3>
<p>Bevy can integrate with the <a href="https://rapier.rs/">Rapier physics engine</a>.</p>
<p>There are two plugins you can choose from:</p>
<ul>
<li><a href="https://github.com/dimforge/bevy_rapier"><code>bevy_rapier</code></a>
<ul>
<li>Maintained officially by the Rapier project developers.</li>
<li>This is a &quot;raw&quot; plugin that gives you direct access to Rapier.</li>
<li>Gives you the most control, but is hard to use and not idiomatic-Bevy.</li>
<li>You will probably need to read a lot of documentation, hard to learn.</li>
</ul>
</li>
<li><a href="https://github.com/jcornaz/heron"><code>heron</code></a>
<ul>
<li>An attempt to make a plugin that is more idiomatic to Bevy. More opinionated.</li>
<li>Likely to be easier to use and more intuitive than <code>bevy_rapier</code>.</li>
<li>May have more limited functionality.</li>
</ul>
</li>
</ul>
<h3 id="animation"><a class="header" href="#animation">Animation</a></h3>
<p>For simple &quot;smooth motion&quot; (easing/tweening/interpolation), try
<a href="https://crates.io/crates/bevy_easings"><code>bevy_easings</code></a>. This might be good
enough for moving 2D objects around, moving the camera, or other such transitions.</p>
<p>For animating 2D sprites, try <a href="https://github.com/jcornaz/benimator"><code>benimator</code></a>.</p>
<p>For 3D skeletal animation, unfortunately, there do not seem to be plugins yet.</p>
<p>Also, a long time ago, there was <a href="https://github.com/bevyengine/bevy/pull/1429">this PR</a>
with an attempt to contribute a full-featured animation system to Bevy. To
my knowledge, it has not (yet) been made available as a separate plugin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-bevy-programming"><a class="header" href="#introduction-to-bevy-programming">Introduction to Bevy Programming</a></h1>
<p>Overview of programming in Bevy.</p>
<p>Includes concise explanations of each core concept, with code snippets to
show how it might be used in a game. Care is taken to point out any important
considerations for using each feature and to recommend known good practices.</p>
<p>Intended for people learning how to use Bevy.</p>
<p>This chapter is split into three sections:</p>
<ul>
<li><a href="programming/./_basics.html">Basics</a>:
Covers the absolute essentials you need to get started.</li>
<li><a href="programming/./_next-steps.html">Next Steps</a>:
The next steps. Things you will likely need for non-trivial projects.</li>
<li><a href="programming/./_advanced.html">Advanced</a>:
advanced topics, may be useful for specialized scenarios in complex projects.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-programming-basics"><a class="header" href="#bevy-programming-basics">Bevy Programming: Basics</a></h1>
<p>This sub-chapter covers the absolute essentials of Bevy programming --
the minimum concepts you need to get started.</p>
<p>Every Bevy project, no matter how simple, requires you to be familiar with
these concepts.</p>
<p>You could conceivably make something like a simple game-jam game or prototype
using just the concepts presented in this sub-chapter.</p>
<p>As your project grows, you will likely quickly run into the need for some
of the topics in the following <a href="programming/./_next-steps.html">Next Steps sub-chapter</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecs-as-a-data-structure"><a class="header" href="#ecs-as-a-data-structure">ECS as a Data Structure</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Bevy stores and manages all your data for you, using the Bevy ECS
(Entity-Component System).</p>
<p>Conceptually, you can think of it by analogy with tables, like in a database
or spreadsheet. Your different data types (Components) are like the &quot;columns&quot;
of a table, and there can be arbitrarily many &quot;rows&quot; (Entities) containing
values / instances of each component.</p>
<p>For example, you could create a <code>Health</code> component for your game. You could
then have many entities representing different things in your game, such
as the player, NPCs, or monsters, all of which can have a <code>Health</code> value
(as well as other relevant components).</p>
<p>This makes it easy to write game logic (<a href="programming/./systems.html">Systems</a>) that can
operate on any entity with the necessary components (such as a health/damage
system for anything that has <code>Health</code>), regardless of whether that's the
player, an NPC, or a monster (or anything else). This makes your game logic
very flexible and reusable.</p>
<p>The set / combination of components that a given entity has, is called the
entity's Archetype.</p>
<p>Note that entities aren't limited to just &quot;objects in the game world&quot;. The ECS
is a general-purpose data structure. You can create entities and components
to store any data.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Bevy has a smart scheduling algorithm that runs your systems in parallel
as much as possible. It does that automatically, when your functions don't
require conflicting access to the same data. Your game will scale to run on
multiple CPU cores &quot;for free&quot;; that is, without requiring extra development
effort from you.</p>
<p>To improve the chances for parallelism, you can make your data and code more
granular. Split your data into smaller types / <code>struct</code>s. Split your logic
into multiple smaller systems / functions. Have each system access only the
data that is relevant to it. The fewer access conflicts, the faster your
game will run.</p>
<p>The general rule of thumb for Bevy performance is: more granular is better.</p>
<h2 id="note-for-programmers-coming-from-object-oriented-languages"><a class="header" href="#note-for-programmers-coming-from-object-oriented-languages">Note for Programmers coming from Object-Oriented Languages</a></h2>
<p>You may be used to thinking in terms of &quot;object classes&quot;. For example, you
might be tempted to define a big monolithic <code>struct Player</code> containing all
the fields / properties of the player.</p>
<p>In Bevy, this is considered bad practice, because doing it that way can make
it more difficult to work with your data, and limit performance.</p>
<p>Instead, you should make things granular, when different pieces of data may
be accessed independently.</p>
<p>For example, represent the Player in your game as an entity, composed of
separate component types (separate <code>struct</code>s) for things like the health,
XP, or whatever is relevant to your game. You can also attach standard Bevy
components like <code>Transform</code> to it.</p>
<p>This will make it easier for you to develop your systems (game logic /
behaviors), as well as make your game's runtime performance better.</p>
<p>However, something like a <code>Transform</code>, or a set of coordinates, still makes
sense as a single <code>struct</code>, because its fields are not likely to be useful
independently.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>Entities are just a simple integer ID, that identifies a particular set of
component values.</p>
<h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components are the data associated with entities.</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a component.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Health {
    hp: f32,
    extra: f32,
}
</code></pre>
<p>Types must be unique -- an entity can only have one component per Rust type.</p>
<p>Use wrapper (newtype) structs to make unique components out of simpler types:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct PlayerXp(u32);

#[derive(Component)]
struct PlayerName(String);
</code></pre>
<p>You can use empty structs to mark specific entities. These are known as &quot;marker
components&quot;. Useful with <a href="programming/./queries.html#filter-by-component">query filters</a>.</p>
<pre><code class="language-rust no_run noplayground">/// Add this to all menu ui entities to help identify them
#[derive(Component)]
struct MainMenuUI;
/// Marker to help identify the player
#[derive(Component)]
struct Player;
/// Marker for hostiles
#[derive(Component)]
struct Enemy;
</code></pre>
<p>Components can be accessed from <a href="programming/./systems.html">systems</a>, using <a href="programming/./queries.html">queries</a>. </p>
<h1 id="component-bundles"><a class="header" href="#component-bundles">Component Bundles</a></h1>
<p>Bundles are like &quot;templates&quot;, to make it easy to create entities with a
common set of components.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Bundle)]
struct PlayerBundle {
    xp: PlayerXp,
    name: PlayerName,
    health: Health,
    _p: Player,

    // We can nest/include another bundle.
    // Add the components for a standard Bevy Sprite:
    #[bundle]
    sprite: SpriteSheetBundle,
}
</code></pre>
<p>Bevy also considers arbitrary tuples of components as bundles:</p>
<pre><code>(ComponentA, ComponentB, ComponentC)
</code></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p>Because both bundles and individual components are regular Rust structs,
Bevy / the Rust compiler often has no way to distinguish them.</p>
<p>If you accidentally use a bundle struct somewhere where Bevy expects a
component, you will not get an error. Bevy will just treat it as a component
of that struct type!</p>
<p>For example, this is why we needed the <code>#[bundle]</code> annotation to include a
sub-bundle in the example above.</p>
<p>Other places where this issue may come up are: when using
<a href="programming/./commands.html"><code>Commands</code></a>, and when <a href="programming/./queries.html">querying</a> (queries <em>only</em>
work with components!).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Resources allow you to store a single global instance of some data type,
independently of entities.</p>
<p>Use them for data that is truly global for your app, such as configuration
/ settings.</p>
<p>Similar to components, any Rust type (<code>struct</code> or <code>enum</code>) can be used as
a resource.</p>
<p>Types must be unique; there can only be one instance of a given type.</p>
<pre><code class="language-rust no_run noplayground">struct GoalsReached {
    main_goal: bool,
    bonus: bool,
}
</code></pre>
<p>Resources can be accessed from <a href="programming/./systems.html">systems</a>, using <code>Res</code>/<code>ResMut</code>.</p>
<h2 id="resource-initialization"><a class="header" href="#resource-initialization">Resource Initialization</a></h2>
<p>Implement <code>Default</code> for simple resources:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct StartingLevel(usize);
</code></pre>
<p>For resources that need complex initialization, implement <code>FromWorld</code>:</p>
<pre><code class="language-rust no_run noplayground">struct MyFancyResource { /* stuff */ }

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS from here.
        // For instance, you can mutate other resources:
        let mut x = world.get_resource_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
</code></pre>
<p>You can create your resources at <a href="programming/./app-builder.html"><code>App</code> creation</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...

        // if it implements `Default` or `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()
        // if not, or if you want to set a specific value
        .insert_resource(StartingLevel(3))

        // ...
        .run();
}
</code></pre>
<p>Or using <a href="programming/./commands.html"><code>Commands</code></a> from inside a system:</p>
<pre><code class="language-rust no_run noplayground">commands.insert_resource(GoalsReached { main_goal: false, bonus: false });
commands.remove_resource::&lt;MyResource&gt;();
</code></pre>
<p>If you insert a resource of a type that already exists, it will be overwritten.</p>
<h2 id="usage-advice"><a class="header" href="#usage-advice">Usage Advice</a></h2>
<p>The choice of when to use entities/components vs. resources is typically
about how you want to access the data: globally from anywhere (resources),
or using ECS patterns (entities/components).</p>
<p>Even if there is only one of a certain thing in your game (such as the
player in a single-player game), it can be a good fit to use an entity
instead of resources, because entities are composed of multiple components,
some of which can be common with other entities. This can make your game
logic more flexible.  For example, you could have a &quot;health/damage system&quot;
that works with both the player and enemies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/startup_system.rs"><code>startup_system</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/system_param.rs"><code>system_param</code></a>.</p>
<hr />
<p>Systems are functions you write, which are run by Bevy.</p>
<p>This is where you implement all your game logic.</p>
<p>These functions can only take special parameter types, to specify what you
need access to. <a href="programming/../pitfalls/into-system.html">If you use unsupported parameter types in your function,
you will get confusing compiler errors!</a></p>
<p>Some of the options are:</p>
<ul>
<li>accessing <a href="programming/./res.html">resources</a> using <code>Res</code>/<code>ResMut</code></li>
<li>accessing <a href="programming/./ec.html">components of entities</a> using <a href="programming/./queries.html">queries</a></li>
<li>creating/destroying entities, components, and resources using <a href="programming/./commands.html"><code>Commands</code></a></li>
<li>sending/receiving <a href="programming/./events.html">events</a> using <code>EventWriter</code>/<code>EventReader</code>.</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn debug_start(
    // access resource
    start: Res&lt;StartingLevel&gt;
) {
    eprintln!(&quot;Starting on level {:?}&quot;, *start);
}
</code></pre>
<p>System parameters can be grouped into tuples (which can be nested). This is
useful for organization.</p>
<pre><code class="language-rust no_run noplayground">fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    // this resource might not exist, so wrap it in an Option
    mut c: Option&lt;ResMut&lt;ResourceC&gt;&gt;,
) {
    if let Some(mut c) = c {
        // do something
    }
}
</code></pre>
<p>The maximum number of top-level system parameters, or tuple members, is 16. You
can group/nest them into tuples, if you need to work around that limitation.</p>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>To run your systems, you need to add them to Bevy via the <a href="programming/./app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...

        // run it only once at launch
        .add_startup_system(init_menu)
        .add_startup_system(debug_start)

        // run it every frame update
        .add_system(move_player)
        .add_system(enemies_ai)

        // ...
        .run();
}
</code></pre>
<p>The above is enough for simple projects.</p>
<p>As your project grows more complex, you might want to enhance your app builder
with some of the powerful tools that Bevy offers for managing when/how
your systems run, such as: <a href="programming/./system-order.html">explicit ordering</a> with
<a href="programming/./labels.html">labels</a>, <a href="programming/./system-sets.html">system sets</a>, <a href="programming/./states.html">states</a>,
<a href="programming/./run-criteria.html">run criteria</a>, and <a href="programming/./stages.html">stages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Queries let you access components of entities.</p>
<pre><code class="language-rust no_run noplayground">fn check_zero_health(
    // access entities that have `Health` and `Transform` components
    // get read-only access to `Health` and mutable access to `Transform`
    // optional component: get access to `Player` if it exists
    mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
    // get all matching entities
    for (health, mut transform, player) in query.iter_mut() {
        eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);

        // center if hp is zero
        if health.hp &lt;= 0.0 {
            transform.translation = Vec3::ZERO;
        }

        if let Some(player) = player {
            // the current entity is the player!
            // do something special!
        }
    }
}
</code></pre>
<p>Get the components associated with a specific entity:</p>
<pre><code class="language-rust no_run noplayground">    if let Ok((health, mut transform)) = query.get_mut(entity) {
        // do something with the components
    } else {
        // the entity does not have the components from the query
    }
</code></pre>
<p>Get the IDs of the entities you access with your queries:</p>
<pre><code class="language-rust no_run noplayground">// add `Entity` to `Query` to get Entity IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
    for (e, /* ... */) in q.iter() {
        // `e` is the Entity ID of the entity we are accessing
    }
}
</code></pre>
<p>If you know that the query should only ever match a single entity, you can
use <code>single</code>/<code>single_mut</code> (returns a <code>Result</code>), instead of iterating:</p>
<pre><code class="language-rust no_run noplayground">fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
    let (player, mut transform) = q.single_mut();

    // do something with the player and its transform
}
</code></pre>
<h2 id="bundles"><a class="header" href="#bundles">Bundles</a></h2>
<p>Queries work with individual components. If you created an entity using a
<a href="programming/./ec.html#component-bundles">bundle</a>, you need to query for the specific
components from that bundle that you care about.</p>
<p>A common beginner mistake is to query for the bundle type!</p>
<h2 id="query-filters"><a class="header" href="#query-filters">Query Filters</a></h2>
<p>Add query filters to narrow down the entities you get from the query.</p>
<p>Use <code>With</code>/<code>Without</code> to only get entities that have specific components.</p>
<pre><code class="language-rust no_run noplayground">fn debug_player_hp(
    // access the health, only for friendly players, optionally with name
    query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
    // get all matching entities
    for (health, name) in query.iter() {
        if let Some(name) = name {
            eprintln!(&quot;Player {} has {} HP.&quot;, name.0, health.hp);
        } else {
            eprintln!(&quot;Unknown player has {} HP.&quot;, health.hp);
        }
    }
}
</code></pre>
<p>Multiple filters can be combined:</p>
<ul>
<li>in a tuple to apply all of them (AND logic)</li>
<li>using the <code>Or&lt;(...)&gt;</code> wrapper to detect any of them (OR logic).
<ul>
<li>(note the tuple inside)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Use <code>Commands</code> to spawn/despawn entities, add/remove components on existing
entities, manage resources.</p>
<p>These actions do not take effect immediately; they are queued to be performed
later when it is safe to do so. See: <a href="programming/./stages.html">stages</a>.</p>
<p>(if you are not using stages, that means your systems will see them <a href="programming/../pitfalls/frame-delay.html">on the
next frame update</a>)</p>
<pre><code class="language-rust no_run noplayground">fn spawn_player(
    mut commands: Commands,
) {
    // manage resources
    commands.insert_resource(GoalsReached { main_goal: false, bonus: false });
    commands.remove_resource::&lt;MyResource&gt;();

    // create a new entity using `spawn`
    let entity_id = commands.spawn()
        // add a component
        .insert(ComponentA)
        // add a bundle
        .insert_bundle(MyBundle::default())
        // get the Entity ID
        .id();

    // shorthand for creating an entity with a bundle
    commands.spawn_bundle(PlayerBundle {
        name: PlayerName(&quot;Henry&quot;.into()),
        xp: PlayerXp(1000),
        health: Health {
            hp: 100.0, extra: 20.0
        },
        _p: Player,
        sprite: Default::default(),
    });

    // spawn another entity
    // NOTE: tuples of arbitrary components are valid bundles
    let other = commands.spawn_bundle((
        ComponentA::default(),
        ComponentB::default(),
        ComponentC::default(),
    )).id();

    // add/remove components of an existing entity
    commands.entity(entity_id)
        .insert(ComponentB)
        .remove::&lt;ComponentA&gt;()
        .remove_bundle::&lt;MyBundle&gt;();

    // despawn an entity
    commands.entity(other).despawn();
}

fn make_all_players_hostile(
    mut commands: Commands,
    query: Query&lt;Entity, With&lt;Player&gt;&gt;,
) {
    for entity in query.iter() {
        // add an `Enemy` component to the entity
        commands.entity(entity).insert(Enemy);
    }
}
</code></pre>
<p>Be careful not to confuse components and bundles. For example: <code>.insert_bundle</code>
is correct: it will add all the components from the bundle; if you instead
use <code>.insert</code> with a bundle type, the bundle struct will be added as a
single component!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/event.rs"><code>event</code></a>.</p>
<hr />
<p>Send data between systems! Let your systems communicate with each other!</p>
<p>To send events, use an <code>EventWriter&lt;T&gt;</code>.
To receive events, use an <code>EventReader&lt;T&gt;</code>.</p>
<p>Every reader tracks the events it has read independently, so you can handle
the same events from multiple systems.</p>
<pre><code class="language-rust no_run noplayground">struct LevelUpEvent(Entity);

fn player_level_up(
    mut ev_levelup: EventWriter&lt;LevelUpEvent&gt;,
    query: Query&lt;(Entity, &amp;PlayerXp)&gt;,
) {
    for (entity, xp) in query.iter() {
        if xp.0 &gt; 1000 {
            ev_levelup.send(LevelUpEvent(entity));
        }
    }
}

fn debug_levelups(
    mut ev_levelup: EventReader&lt;LevelUpEvent&gt;,
) {
    for ev in ev_levelup.iter() {
        eprintln!(&quot;Entity {:?} leveled up!&quot;, ev.0);
    }
}
</code></pre>
<p>You need to add your custom event types via the <a href="programming/./app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...
        .add_event::&lt;LevelUpEvent&gt;()
        .add_system(player_level_up)
        .add_system(debug_levelups)
        // ...
        .run();
}
</code></pre>
<p>Events should be your go-to data flow tool. As events can be sent from any
system and received by multiple systems, they are <em>extremely</em> versatile.</p>
<h2 id="possible-pitfalls"><a class="header" href="#possible-pitfalls">Possible Pitfalls</a></h2>
<p>Beware of <a href="programming/../pitfalls/frame-delay.html">frame delay / 1-frame-lag</a>. This
can occur if Bevy runs the receiving system before the sending system. The
receiving system will only get a chance to receive the events on the next frame
update. If you need to ensure that events are handled immediately / during
the same frame, you can use <a href="programming/./system-order.html">explicit system ordering</a>.</p>
<p>Events don't persist. They are stored until the end of the next frame,
after which they are lost. If your systems do not handle events every frame,
you could miss some.</p>
<p>The advantage of this design is that you don't have to worry about excessive
memory use from unhandled events.</p>
<p>If you don't like this, <a href="programming/../patterns/manual-event-clear.html">you can have manual control over when events
are cleared</a> (at the risk of leaking /
wasting memory if you forget to clear them).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-builder-main-function"><a class="header" href="#app-builder-main-function">App Builder (main function)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/hello_world.rs"><code>hello_world</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/app/empty.rs"><code>empty</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/app/empty_defaults.rs"><code>empty_defaults</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/app/headless.rs"><code>headless</code></a>.</p>
<hr />
<p>To enter the bevy runtime, you need to configure an <code>App</code>, composed of all
the <a href="programming/./systems.html">systems</a>, <a href="programming/./plugins.html">plugins</a>, <a href="programming/./events.html">event</a>
types, and <a href="programming/./res.html">resources</a>, that you want to use.</p>
<p>Everything must be registered in the <code>App</code>, or it will not work.</p>
<p>Component types and <a href="programming/./local.html">local resources</a> do not need to be registered.</p>
<p>Resources can also be created later, using <a href="programming/./commands.html"><code>Commands</code></a>.</p>
<p>You also need to add Bevy's built-in functionality: either <code>DefaultPlugins</code>
if you are making a full game/app, or <code>MinimalPlugins</code> for something like
a headless server.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // bevy
        .add_plugins(DefaultPlugins)

        // resources:
        .insert_resource(StartingLevel(3))
        // if it implements `Default` or `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()

        // events:
        .add_event::&lt;LevelUpEvent&gt;()

        // systems to run once at startup:
        .add_startup_system(spawn_player)

        // systems to run each frame:
        .add_system(player_level_up)
        .add_system(debug_levelups)
        .add_system(debug_stats_change)
        // ...

        // launch the app!
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-programming-next-steps"><a class="header" href="#bevy-programming-next-steps">Bevy Programming: Next Steps</a></h1>
<p>This sub-chapter covers aspects of Bevy programming beyond the absolute basics.</p>
<p>You could get started building simple things with Bevy before you have
familiarized yourself with these concepts.</p>
<p>However, they would probably become useful to you pretty quickly -- you
will likely need at least some of these features as your project grows
in complexity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-resources"><a class="header" href="#local-resources">Local Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p><code>Local&lt;T&gt;</code> is a system parameter similar to <code>ResMut&lt;T&gt;</code>, which gives you
full mutable access to an instance of some data type, that is independent
from entities and components.</p>
<p><code>Res&lt;T&gt;</code>/<code>ResMut&lt;T&gt;</code> refer to a single global instance of the type, shared
between all systems. On the other hand, every <code>Local&lt;T&gt;</code> parameter is a
separate instance, exclusively for that system.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyState;

fn my_system1(mut local: Local&lt;MyState&gt;) {
    // you can do anything you want with the local here
}

fn my_system2(mut local: Local&lt;MyState&gt;) {
    // the local in this system is a different instance
}
</code></pre>
<p>The type must implement <code>Default</code> or <code>FromWorld</code>. It is automatically
initialized.</p>
<p>A system can have multiple <code>Local</code>s of the same type.</p>
<h2 id="specify-an-initial-value"><a class="header" href="#specify-an-initial-value">Specify an initial value</a></h2>
<p>You can initialize a <code>Local</code> to a value other than the type's default, using
<code>.config</code>, when adding your system to your <code>App</code>.</p>
<p><code>.config</code> is Bevy's API for &quot;configuring&quot; specific system parameters. Most
other types of system parameters do not support configuration, but <code>Local</code>s
let you specify the initial value.</p>
<pre><code class="language-rust no_run noplayground">/// Configuration for `my_system`.
///
/// The system will access it using `Local&lt;MyConfig&gt;`.
/// It will be initialized with the correct value at App build time.
///
/// Must still impl `Default`, because of requirement for `Local`.
#[derive(Default)]
struct MyConfig {
    magic: usize,
}

fn my_system(
    mut cmd: Commands,
    my_res: Res&lt;MyStuff&gt;,
    config: Local&lt;MyConfig&gt;,
) {
    // TODO: do stuff
}

fn main() {
    App::new()
        .add_system(my_system.config(|params| {
            // our config is the third parameter in the system fn,
            // hence `.2`
            params.2 = Some(MyConfig {
                magic: 420,
            });
        }))
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/app/plugin.rs"><code>plugin</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/app/plugin_group.rs"><code>plugin_group</code></a>.</p>
<hr />
<p>As your project grows, it can be useful to make it more modular. You can
split it into plugins.</p>
<p>Plugins are simply collections of things to be added to the
<a href="programming/./app-builder.html">App Builder</a>.</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app
            .init_resource::&lt;MyOtherResource&gt;()
            .add_event::&lt;MyEvent&gt;()
            .add_startup_system(plugin_init)
            .add_system(my_system);
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugin(MyPlugin)
        .run();
}
</code></pre>
<p>For internal organization in your own project, the main value of plugins
comes from not having to declare all your Rust types and functions as
<code>pub</code>, just so they can be accessible from <code>main</code> to be added to the app
builder. Plugins let you add things to your app from multiple different
places, like separate Rust files / modules.</p>
<p>You can decide how plugins fit into the architecture of your game.</p>
<p>Some suggestions:</p>
<ul>
<li>Create plugins for different <a href="programming/./states.html">states</a>.</li>
<li>Create plugins for various sub-systems, like physics or input handling.</li>
</ul>
<h2 id="plugin-groups"><a class="header" href="#plugin-groups">Plugin groups</a></h2>
<p>Plugin groups register multiple plugins at once. Bevy's <code>DefaultPlugins</code>
and <code>MinimalPlugins</code> are examples of this. To create your own plugin group:</p>
<pre><code class="language-rust no_run noplayground">struct MyPluginGroup;

impl PluginGroup for MyPluginGroup {
    fn build(&amp;mut self, group: &amp;mut PluginGroupBuilder) {
        group
            .add(FooPlugin)
            .add(BarPlugin);
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MyPluginGroup)
        .run();
}
</code></pre>
<p>When adding a plugin group, you can disable some plugins while keeping
the rest.</p>
<p>For example, if you want to manually set up logging (with your own <code>tracing</code>
subscriber), you can disable <code>LogPlugin</code>:</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins_with(DefaultPlugins, |plugins| {
        plugins.disable::&lt;LogPlugin&gt;()
    })
    .run();
</code></pre>
<p>Note that this simply disables the functionality, but it cannot actually
remove the code to avoid binary bloat. The disabled plugins still have to
be compiled into your program.</p>
<p>If you want to slim down your build, you should look at disabling Bevy's
default cargo features, or depending on the various Bevy sub-crates
individually.</p>
<h2 id="publishing-crates"><a class="header" href="#publishing-crates">Publishing Crates</a></h2>
<p>Plugins give you a nice way to publish Bevy-based libraries for other people
to easily include into their projects.</p>
<p>If you intend to publish plugins as crates for public use, you should read
<a href="https://github.com/bevyengine/bevy/blob/main/docs/plugins_guidelines.md">the official guidelines for plugin authors</a>.</p>
<p>Don't forget to submit an entry to <a href="https://bevyengine.org/assets">Bevy Assets</a>
on the official website, so that people can find your plugin
more easily. You can do this by making a PR in <a href="https://github.com/bevyengine/bevy-assets">the Github
repo</a>.</p>
<p>If you are interested in supporting bleeding-edge Bevy (main), <a href="programming/../setup/bevy-git.html#advice-for-plugin-authors">see here
for advice</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-order-of-execution"><a class="header" href="#system-order-of-execution">System Order of Execution</a></h1>
<p>Bevy's scheduling algorithm is designed to deliver maximum performance
by running as many systems as possible in parallel across the available
CPU threads.</p>
<p>This is possible when the systems do not conflict over the data they need
to access. However, when a system needs to have mutable (exclusive) access
to a piece of data, other systems that need to access the same data cannot
be run at the same time. Bevy determines all of this information from the
system's function signature (the types of the parameters it takes).</p>
<p>In such situations, the order is <em>nondeterministic</em> by default. Bevy takes
no regard for when each system will run, and the order could even change
every frame!</p>
<h2 id="does-it-even-matter"><a class="header" href="#does-it-even-matter">Does it even matter?</a></h2>
<p>In many cases, you don't need to worry about this.</p>
<p>However, sometimes you need to rely on specific systems to run in a particular
order. For example:</p>
<ul>
<li>Maybe the logic you wrote in one of your systems needs any modifications
done to that data by another system to always happen first?</li>
<li>One system needs to receive <a href="programming/./events.html">events</a> sent by another system.</li>
<li>You are using <a href="programming/./change-detection.html">change detection</a>.</li>
</ul>
<p>In such situations, systems running in the wrong order typically causes their
behavior <a href="programming/../pitfalls/frame-delay.html">to be delayed until the next frame</a>. In
rare cases, depending on your game logic, it may even result in more serious
logic bugs!</p>
<p>It is up to you to decide if this is important.</p>
<p>With many things in typical games, such as juicy visual effects, it probably
doesn't matter if they get delayed by a frame. It might not be worthwhile
to bother with it. If you don't care, leaving the order ambiguous may also
result in better performance.</p>
<p>On the other hand, for things like handling the player input controls,
this would result in annoying lag, so you should probably fix it.</p>
<h2 id="explicit-system-ordering"><a class="header" href="#explicit-system-ordering">Explicit System Ordering</a></h2>
<p>The solution is to use system <a href="programming/./labels.html">labels</a> to explicitly specify
the order you want:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // order doesn't matter for these systems:
        .add_system(particle_effects)
        .add_system(npc_behaviors)
        .add_system(enemy_movement)

        // create labels, because we need to order other systems around these:
        .add_system(map_player_input.label(&quot;input&quot;))
        .add_system(update_map.label(&quot;map&quot;))

        // this will always run before anything labeled &quot;input&quot;
        .add_system(input_parameters.before(&quot;input&quot;))

        // this will always run after anything labeled &quot;input&quot; and &quot;map&quot;
        // also label it just in case
        .add_system(
            player_movement
                .label(&quot;player_movement&quot;)
                .after(&quot;input&quot;)
                .after(&quot;map&quot;)
        )
        .run();
}
</code></pre>
<p>Each label is a reference point that other systems can be ordered around.</p>
<p><code>.label</code>/<code>.before</code>/<code>.after</code> may be used as many times as you need on one system.</p>
<p>You can place multiple labels on one system.</p>
<p>You can also use the same label on multiple systems.</p>
<p>When you have multiple systems with common labels or ordering, it may be
convenient to use <a href="programming/./system-sets.html">system sets</a>.</p>
<h2 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h2>
<p>If you have multiple systems mutually depending on each other, then it is
clearly impossible to resolve the situation completely like that.</p>
<p>You should try to redesign your game to avoid such situations, or just accept
the consequences. You can at least make it behave predictably, using explicit
ordering to specify the order you prefer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-sets"><a class="header" href="#system-sets">System Sets</a></h1>
<p>System Sets allow you to easily apply common properties to multiple systems,
for purposes such as <a href="programming/./labels.html">labeling</a>, <a href="programming/./system-order.html">ordering</a>,
<a href="programming/./run-criteria.html">run criteria</a>, and <a href="programming/./states.html">states</a>.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // group our input handling systems into a set
        .add_system_set(
            SystemSet::new()
                .label(&quot;input&quot;)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )

        // our &quot;net&quot; systems should run before &quot;input&quot;
        .add_system_set(
            SystemSet::new()
                .label(&quot;net&quot;)
                .before(&quot;input&quot;)
                // individual systems can still have
                // their own labels (and ordering)
                .with_system(server_session.label(&quot;session&quot;))
                .with_system(server_updates.after(&quot;session&quot;))
        )

        // some ungrouped systems
        .add_system(player_movement.after(&quot;input&quot;))
        .add_system(session_ui.after(&quot;session&quot;))
        .add_system(smoke_particles)

        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchical-parentchild-entities"><a class="header" href="#hierarchical-parentchild-entities">Hierarchical (Parent/Child) Entities</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/hierarchy.rs"><code>hierarchy</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Technically, the Entities/Components themselves cannot form a hierarchy
(it is a flat data structure). However, logical hierarchies are a common
pattern in games.</p>
<p>Bevy supports creating such a logical link between entities, to form a
virtual &quot;hierarchy&quot;, by simply adding <code>Parent</code> and <code>Children</code> components
on the respective entities.</p>
<p><code>Commands</code> has methods for adding children to entities, which automatically
add the correct components:</p>
<pre><code class="language-rust no_run noplayground">// spawn the parent and get its Entity id
let parent = commands.spawn_bundle(MyParentBundle::default())
    .id();

// do the same for the child
let child = commands.spawn_bundle(MyChildBundle::default())
    .id();

// add the child to the parent
commands.entity(parent).push_children(&amp;[child]);

// you can also use `with_children`:
commands.spawn_bundle(MyParentBundle::default())
    .with_children(|parent| {
        parent.spawn_bundle(MyChildBundle::default());
    });
</code></pre>
<p>You can despawn an entire hierarchy with a single command:</p>
<pre><code class="language-rust no_run noplayground">fn close_menu(
    mut commands: Commands,
    query: Query&lt;Entity, With&lt;MainMenuUI&gt;&gt;,
) {
    for entity in query.iter() {
        // despawn the entity and its children
        commands.entity(entity).despawn_recursive();
    }
}
</code></pre>
<h2 id="accessing-the-parent-or-children"><a class="header" href="#accessing-the-parent-or-children">Accessing the Parent or Children</a></h2>
<p>To make a system that works with the hierarchy, you typically need two queries:</p>
<ul>
<li>one with the components you need from the child entities</li>
<li>one with the components you need from the parent entities</li>
</ul>
<p>One of the two queries should include the appropriate component, to obtain the
entity ids to use with the other one:</p>
<ul>
<li><code>Parent</code> in the child query, if you want to iterate entities and look up
their parents, or</li>
<li><code>Children</code> in the parent query, if you want to iterate entities and look up
their children</li>
</ul>
<p>For example, if we want to get the <code>Transform</code> of cameras that have a parent,
and the <code>GlobalTransform</code> of their parent:</p>
<pre><code class="language-rust no_run noplayground">fn camera_with_parent(
    q_child: Query&lt;(&amp;Parent, &amp;Transform), With&lt;Camera&gt;&gt;,
    q_parent: Query&lt;&amp;GlobalTransform&gt;,
) {
    for (parent, child_transform) in q_child.iter() {
        // `parent` contains the Entity ID we can use
        // to query components from the parent:
        let parent_global_transform = q_parent.get(parent.0);

        // do something with the components
    }
}
</code></pre>
<p>As another example, say we are making a strategy game, and we have Units
that are children of a Squad. Say we need to make a system that works on
each Squad, and it needs some information about the children:</p>
<pre><code class="language-rust no_run noplayground">fn process_squad_damage(
    q_parent: Query&lt;(&amp;MySquadDamage, &amp;Children)&gt;,
    q_child: Query&lt;&amp;MyUnitHealth&gt;,
) {
    // get the properties of each squad
    for (squad_dmg, children) in q_parent.iter() {
        // `children` is a collection of Entity IDs
        for &amp;child in children.iter() {
            // get the health of each child unit
            let health = q_child.get(child);

            // do something
        }
    }
}
</code></pre>
<h2 id="relative-transforms"><a class="header" href="#relative-transforms">Relative Transforms</a></h2>
<p>If your entities represent &quot;objects in the game world&quot;, you probably expect
the child to be positioned relative to the parent and move with it.</p>
<p>All Bundles that come with Bevy provide this behavior automatically.</p>
<p>If you are not using such a bundle, you need to make sure to add these
components to both the parent and the child: <code>GlobalTransform</code> and <code>Transform</code>.</p>
<p>The <code>Transform</code> represents the relative position.
You can manipulate it directly.</p>
<p>The <code>GlobalTransform</code> represents the absolute position.
It is managed by bevy internally; do not manipulate it yourself.</p>
<p>For more info, see the
<a href="programming/../features/transforms.html">dedicated page about transforms</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/change_detection.rs"><code>change_detection</code></a>.</p>
<hr />
<p>Bevy allows you to easily detect when data is changed. You can use this to
perform actions in response to changes.</p>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<p>Use <a href="programming/./queries.html#query-filters">query filters</a>:</p>
<ul>
<li><code>Added&lt;T&gt;</code>: detect new component instances
<ul>
<li>if the component was added to an existing entity</li>
<li>if a new entity with the component was spawned</li>
</ul>
</li>
<li><code>Changed&lt;T&gt;</code>: detect component instances that have been changed
<ul>
<li>triggers when the component is accessed mutably</li>
<li>also triggers if the component is newly-added (as per <code>Added</code>)</li>
</ul>
</li>
</ul>
<p>(If you want to react to removals, see the page on <a href="programming/./removal-detection.html">removal
detection</a>. It works differently and is much
trickier to use.)</p>
<pre><code class="language-rust no_run noplayground">/// Print the stats of friendly players when they change
fn debug_stats_change(
    query: Query&lt;
        // components
        (&amp;Health, &amp;PlayerXp),
        // filters
        (Without&lt;Enemy&gt;, Or&lt;(Changed&lt;Health&gt;, Changed&lt;PlayerXp&gt;)&gt;), 
    &gt;,
) {
    for (health, xp) in query.iter() {
        eprintln!(
            &quot;hp: {}+{}, xp: {}&quot;,
            health.hp, health.extra, xp.0
        );
    }
}

/// detect new enemies and print their health
fn debug_new_hostiles(
    query: Query&lt;(Entity, &amp;Health), Added&lt;Enemy&gt;&gt;,
) {
    for (entity, health) in query.iter() {
        eprintln!(&quot;Entity {:?} is now an enemy! HP: {}&quot;, entity, health.hp);
    }
}
</code></pre>
<p><code>Changed</code> detection is triggered by <code>DerefMut</code>. Simply accessing components
via a mutable query, without actually performing a <code>&amp;mut</code> access, will <em>not</em>
trigger it.</p>
<p>This makes change detection quite accurate. You can rely on it to optimize
your game's performance, or to otherwise trigger things to happen.</p>
<p>Also note that when you mutate a component, Bevy does not track if the new
value is actually different from the old value. It will always trigger the
change detection. If you want to avoid that, simply check it yourself:</p>
<pre><code class="language-rust no_run noplayground">fn update_player_xp(
    mut query: Query&lt;&amp;mut PlayerXp&gt;,
) {
    for mut xp in query.iter_mut() {
        let new_xp = maybe_lvl_up(&amp;xp);

        // avoid triggering change detection if the value is the same
        if new_xp != *xp {
            *xp = new_xp;
        }
    }
}
</code></pre>
<p>Change detection is reliable -- it will detect any changes that
have occured since the last time your detecting system ran. If your
system only runs sometimes (such as with <a href="programming/./states.html">states</a> or <a href="programming/./run-criteria.html">run
criteria</a>), you <em>do not</em> have to worry about missing
changes.</p>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>For resources, change detection is provided via methods on the
<code>Res</code>/<code>ResMut</code> system parameters.</p>
<pre><code class="language-rust no_run noplayground">fn check_res_changed(
    my_res: Res&lt;MyResource&gt;,
) {
    if my_res.is_changed() {
        // do something
    }
}

fn check_res_added(
    // use Option, not to panic if the resource doesn't exist yet
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists

        if my_res.is_added() {
            // it was just added
            // do something
        }
    }
}
</code></pre>
<p>This works the same way as change detection for components.</p>
<h2 id="possible-pitfalls-1"><a class="header" href="#possible-pitfalls-1">Possible Pitfalls</a></h2>
<p>Beware of <a href="programming/../pitfalls/frame-delay.html">frame delay / 1-frame-lag</a>. This can
occur if Bevy runs the detecting system before the changing system. The
detecting system will see the change the next time it runs, typically on
the next frame update.</p>
<p>If you need to ensure that changes are handled immediately / during the same
frame, you can use <a href="programming/./system-order.html">explicit system ordering</a>.</p>
<p>However, when detecting component additions with <code>Added&lt;T&gt;</code> (which are
typically done using <a href="programming/./commands.html"><code>Commands</code></a>), this is not enough;
you need <a href="programming/./stages.html">stages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-chaining"><a class="header" href="#system-chaining">System Chaining</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/system_chaining.rs"><code>system_chaining</code></a>.</p>
<hr />
<p>Systems can take an input and produce an output, and be connected together
to run as a single larger system (chain).</p>
<p>Think of this as &quot;glue&quot;, for constructing a larger system out of multiple
Rust functions.</p>
<p>One useful application is to be able to return errors from systems (allowing
the use of Rust's <code>?</code> operator) and handle them elsewhere:</p>
<pre><code class="language-rust no_run noplayground">fn net_receive(mut netcode: ResMut&lt;MyNetProto&gt;) -&gt; std::io::Result&lt;()&gt; {
    netcode.receive_updates()?;

    Ok(())
}

fn handle_io_errors(In(result): In&lt;std::io::Result&lt;()&gt;&gt;) {
    if let Err(e) = result {
        eprintln!(&quot;I/O error occurred: {}&quot;, e);
    }
}
</code></pre>
<p>Such systems cannot be registered individually (Bevy doesn't know what to
do with the input/output). You have to connect them in a chain:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...
        .add_system(net_receive.chain(handle_io_errors))
        // ...
        .run();
}
</code></pre>
<p>Chaining effectively constructs a single large system out of modular parts. It
is <em>not</em> a channel for passing data around. If you want to pass data between
systems, you probably want to use <a href="programming/./events.html">Events</a> instead.</p>
<h2 id="performance-warning"><a class="header" href="#performance-warning">Performance Warning</a></h2>
<p>Beware that Bevy treats the whole chain as if it was a single big system,
with all the combined resources and queries. This implies that parallelism
could be limited, affecting performance.</p>
<p>Avoid adding a system that requires mutable access to anything, as part
of multiple chains. It would block all affected chains (and other systems
accessing the same data) from running in parallel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-sets"><a class="header" href="#query-sets">Query Sets</a></h1>
<p>For safety reasons, a system cannot have multiple queries with mutability
conflicts on the same components.</p>
<p>Bevy provides a solution: wrap them in a <code>QuerySet</code>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    // access the health of enemies and the health of players
    // (note: some entities could be both!)
    mut q: QuerySet&lt;(
        QueryState&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
        QueryState&lt;&amp;mut Health, With&lt;Player&gt;&gt;
    )&gt;,
) {
    // set health of enemies
    for mut health in q.q0().iter_mut() {
        health.hp = 50.0;
    }

    // set health of players
    for mut health in q.q1().iter_mut() {
        health.hp = 100.0;
    }
}
</code></pre>
<p>This ensures only one of the conflicting queries can be used at the same time.</p>
<p>The maximum number of queries in a query set is 4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="states"><a class="header" href="#states">States</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/state.rs"><code>state</code></a>.</p>
<hr />
<p>States allow you to structure the runtime &quot;flow&quot; of your app.</p>
<p>This is how you can implement things like:</p>
<ul>
<li>A menu screen or a loading screen</li>
<li>Pausing / unpausing the game</li>
<li>Different game modes</li>
<li>...</li>
</ul>
<p>In every state, you can have different systems running. You can also add
one-shot setup and cleanup systems to run when entering or exiting a state.</p>
<p>To use states, define an enum type and add <a href="programming/./system-sets.html">system sets</a>
to your <a href="programming/./app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
    Paused,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // add the app state type
        .add_state(AppState::MainMenu)

        // add systems to run regardless of state, as usual
        .add_system(play_music)

        // systems to run only in the main menu
        .add_system_set(
            SystemSet::on_update(AppState::MainMenu)
                .with_system(handle_ui_buttons)
        )

        // setup when entering the state
        .add_system_set(
            SystemSet::on_enter(AppState::MainMenu)
                .with_system(setup_menu)
        )

        // cleanup when exiting the state
        .add_system_set(
            SystemSet::on_exit(AppState::MainMenu)
                .with_system(close_menu)
        )
        .run();
}
</code></pre>
<p>It is OK to have multiple system sets for the same state.</p>
<p>This is useful when you want to place <a href="programming/./labels.html">labels</a> and use <a href="programming/./system-order.html">explicit
system ordering</a>.</p>
<p>This can also be useful with <a href="programming/./plugins.html">Plugins</a>. Each plugin can add
its own set of systems to the same state.</p>
<p>States are implemented using <a href="programming/./run-criteria.html">run criteria</a> under the hood.
These special system set constructors are really just helpers to automatically
add the state management run criteria.</p>
<h2 id="controlling-states"><a class="header" href="#controlling-states">Controlling States</a></h2>
<p>Inside of systems, you can check and control the state using the <code>State&lt;T&gt;</code>
resource:</p>
<pre><code class="language-rust no_run noplayground">fn play_music(
    app_state: Res&lt;State&lt;AppState&gt;&gt;,
    // ...
) {
    match app_state.current() {
        AppState::MainMenu =&gt; {
            // TODO: play menu music
        }
        AppState::InGame =&gt; {
            // TODO: play game music
        }
        AppState::Paused =&gt; {
            // TODO: play pause screen music
        }
    }
}
</code></pre>
<p>To change to another state:</p>
<pre><code class="language-rust no_run noplayground">fn enter_game(mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;) {
    app_state.set(AppState::InGame).unwrap();
    // ^ this can fail if we are already in the target state
    // or if another state change is already queued
}
</code></pre>
<p>After the systems of the current state complete, Bevy will transition to
the next state you set.</p>
<p>You can do arbitrarily many state transitions in a single frame update. Bevy
will handle all of them and execute all the relevant systems (before moving
on to the next <a href="programming/./stages.html">stage</a>).</p>
<h2 id="state-stack"><a class="header" href="#state-stack">State Stack</a></h2>
<p>Instead of completely transitioning from one state to another, you can also
overlay states, forming a stack.</p>
<p>This is how you can implement things like a &quot;game paused&quot; screen, or an
overlay menu, with the game world still visible / running in the background.</p>
<p>You can have some systems that are still running even when the state is
&quot;inactive&quot; (that is, in the background, with other states running on top). You
can also add one-shot systems to run when &quot;pausing&quot; or &quot;resuming&quot; the state.</p>
<p>In your <a href="programming/./app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">        // player movement only when actively playing
        .add_system_set(
            SystemSet::on_update(AppState::InGame)
                .with_system(player_movement)
        )
        // player idle animation while paused
        .add_system_set(
            SystemSet::on_inactive_update(AppState::InGame)
                .with_system(player_idle)
        )
        // animations both while paused and while active
        .add_system_set(
            SystemSet::on_in_stack_update(AppState::InGame)
                .with_system(animate_trees)
                .with_system(animate_water)
        )
        // things to do when becoming inactive
        .add_system_set(
            SystemSet::on_pause(AppState::InGame)
                .with_system(hide_enemies)
        )
        // things to do when becoming active again
        .add_system_set(
            SystemSet::on_resume(AppState::InGame)
                .with_system(reset_player)
        )
        // setup when first entering the game
        .add_system_set(
            SystemSet::on_enter(AppState::InGame)
                .with_system(setup_player)
                .with_system(setup_map)
        )
        // cleanup when finally exiting the game
        .add_system_set(
            SystemSet::on_exit(AppState::InGame)
                .with_system(despawn_player)
                .with_system(despawn_map)
        )
</code></pre>
<p>To manage states like this, use <code>push</code>/<code>pop</code>:</p>
<pre><code class="language-rust no_run noplayground">    // to go into the pause screen
    app_state.push(AppState::Paused).unwrap();
    // to go back into the game
    app_state.pop().unwrap();
</code></pre>
<p>(using <code>.set</code> as shown before replaces the active state at the top of the stack)</p>
<h2 id="known-pitfalls-and-limitations"><a class="header" href="#known-pitfalls-and-limitations">Known Pitfalls and Limitations</a></h2>
<h3 id="events-1"><a class="header" href="#events-1">Events</a></h3>
<p>When receiving <a href="programming/./events.html">events</a> in systems that don't run all the time, such
as during a pause state, you will miss any events that are sent during the frames
when the receiving systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming/../patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime
of the relevant event types.</p>
<h3 id="combining-with-other-run-criteria"><a class="header" href="#combining-with-other-run-criteria">Combining with Other Run Criteria</a></h3>
<p>Because states are implemented using run criteria, it is tricky
to combine them with other uses of run criteria, such as <a href="programming/../features/fixed-timestep.html">fixed
timestep</a>.</p>
<p>If you try to add another run criteria to your system set, it would replace
Bevy's state-management run criteria! This would make the system set no
longer constrained to run as part of a state!</p>
<p>It may still be possible to accomplish such use cases using some trickery.</p>
<p>(TODO) show an example of how it could be done.</p>
<h3 id="with-input"><a class="header" href="#with-input">With Input</a></h3>
<p>If you want to use <code>Input&lt;T&gt;</code> to trigger state transitions using a button/key
press, you need to clear the input manually by calling <code>.reset</code>:</p>
<pre><code class="language-rust no_run noplayground">fn esc_to_menu(
    mut keys: ResMut&lt;Input&lt;KeyCode&gt;&gt;,
    mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Escape) {
        app_state.set(AppState::MainMenu).unwrap();
        keys.reset(KeyCode::Escape);
    }
}
</code></pre>
<p>(note that this requires <code>ResMut</code>)</p>
<p>Not doing this can cause <a href="https://github.com/bevyengine/bevy/issues/1700">issues</a>.</p>
<h3 id="multiple-stages"><a class="header" href="#multiple-stages">Multiple Stages</a></h3>
<p>(TODO) move this under the <a href="programming/../patterns/_index.html">Advanced Patterns</a> chapter.</p>
<p>If you need state-dependent systems in multiple <a href="programming/./stages.html">stages</a>,
a workaround is required.</p>
<p>You must add the state to one stage only, and then call <code>.get_driver()</code>
and add that to the other stages before any state-dependent system sets in
those stages.</p>
<p>(TODO) example</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-criteria"><a class="header" href="#run-criteria">Run Criteria</a></h1>
<p>Run Criteria are a mechanism for controlling if Bevy should run specific
systems, at runtime. This is how you can make functionality that only runs
under certain conditions.</p>
<p>Run Criteria are a lower-level primitive. Bevy provides higher-level
abstractions on top, such as <a href="programming/./states.html">States</a>. You can use Run Criteria
without such abstractions, if you really need more direct control.</p>
<p>Run Criteria can be applied to individual <a href="programming/./systems.html">systems</a>, <a href="programming/./system-sets.html">system
sets</a>, and <a href="programming/./stages.html">stages</a>.</p>
<p>Run Criteria are Bevy systems that return a value of type <code>enum ShouldRun</code>. They can accept any system parameters, like a normal system.</p>
<p>This example shows how run criteria might be used to implement different
multiplayer modes:</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::schedule::ShouldRun;

#[derive(Debug, PartialEq, Eq)]
enum MultiplayerKind {
    Client,
    Host,
    Local,
}

fn run_if_connected(
    mode: Res&lt;MultiplayerKind&gt;,
    session: Res&lt;MyNetworkSession&gt;,
) -&gt; ShouldRun
{
    if *mode == MultiplayerKind::Client &amp;&amp; session.is_connected() {
        ShouldRun::Yes
    } else {
        ShouldRun::No
    }
}

fn run_if_host(
    mode: Res&lt;MultiplayerKind&gt;,
) -&gt; ShouldRun
{
    if *mode == MultiplayerKind::Host || *mode == MultiplayerKind::Local {
        ShouldRun::Yes
    } else {
        ShouldRun::No
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // if we are currently connected to a server,
        // activate our client systems
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(run_if_connected)
                .before(&quot;input&quot;)
                .with_system(server_session)
                .with_system(fetch_server_updates)
        )

        // if we are hosting the game,
        // activate our game hosting systems
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(run_if_host)
                .before(&quot;input&quot;)
                .with_system(host_session)
                .with_system(host_player_movement)
                .with_system(host_enemy_ai)
        )

        // other systems in our game
        .add_system(smoke_particles)
        .add_system(water_animation)
        .add_system_set(
            SystemSet::new()
                .label(&quot;input&quot;)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )
        .run();
}
</code></pre>
<h2 id="run-criteria-labels"><a class="header" href="#run-criteria-labels">Run Criteria Labels</a></h2>
<p>If you have multiple systems or system sets that you want to share the same
run criteria, you can give it a <a href="programming/./labels.html">label</a>.</p>
<p>When you use a label, Bevy will only execute the run criteria once, remember
its output, and apply it to everything with the label.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[derive(RunCriteriaLabel)]
enum MyRunCriteria {
    Client,
    Host,
}

fn main() {
    App::new()
        // ...
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(
                    // assign it a label
                    run_if_host
                        .label(MyRunCriteria::Host)
                )
                .with_system(host_session)
                .with_system(host_player_movement)
                .with_system(host_enemy_ai)
        )

        // extra system for debugging the host
        // it can share our previously-registered run criteria
        .add_system(host_debug
            .with_run_criteria(MyRunCriteria::Host)
        )
        .run();
}

</code></pre>
<p>The run-once property is especially important if you have a complex run
criteria system that performs mutations or is otherwise non-idempotent.</p>
<h2 id="known-pitfalls"><a class="header" href="#known-pitfalls">Known Pitfalls</a></h2>
<p>When receiving <a href="programming/./events.html">events</a> in systems that don't run every frame,
you will miss any events that are sent during the frames when the receiving
systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming/../patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime
of the relevant event types.</p>
<hr />
<p>Bevy's <a href="programming/../features/fixed-timestep.html">fixed timestep</a> is also implemented
using run criteria under the hood.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labels"><a class="header" href="#labels">Labels</a></h1>
<p>You need labels to name various things in your app, such as
<a href="programming/./system-order.html">systems</a>, <a href="programming/./run-criteria.html">run criteria</a>,
<a href="programming/./stages.html">stages</a>, and ambiguity sets<!-- TODO: add a link -->.</p>
<p>Bevy uses some clever Rust type system magic, to allow you to use strings
as well as your own custom types for labels, and even mix them!</p>
<p>You may use a value of any type as a label, as long as it has the following
standard Rust traits: <code>Clone + Eq + Hash + Debug</code> (and the implied <code>+ Send + Sync + 'static</code>).</p>
<p>You need to derive the appropriate trait: <code>StageLabel</code>, <code>SystemLabel</code>,
<code>RunCriteriaLabel</code>, or <code>AmbiguitySetLabel</code>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[derive(SystemLabel)]
enum MySystems {
    InputSet,
    Movement,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[derive(StageLabel)]
enum MyStages {
    Prepare,
    Cleanup,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[derive(StageLabel)]
struct DebugStage;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // Add our game systems:
        .add_system_set(
            SystemSet::new()
                .label(MySystems::InputSet)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )
        .add_system(player_movement.label(MySystems::Movement))

        // temporary debug system, let's just use a string label
        .add_system(debug_movement.label(&quot;temp-debug&quot;))

        // Add our custom stages:
        // note that Bevy's `CoreStage` is an enum just like ours!
        .add_stage_before(CoreStage::Update, MyStages::Prepare, SystemStage::parallel())
        .add_stage_after(CoreStage::Update, MyStages::Cleanup, SystemStage::parallel())

        .add_stage_after(CoreStage::Update, DebugStage, SystemStage::parallel())

        // we can just use a string for this one:
        .add_stage_before(CoreStage::PostUpdate, &quot;temp-debug-hack&quot;, SystemStage::parallel())

        .run();
}
</code></pre>
<p>For quick prototyping, it is convenient to just use strings as labels.</p>
<p>However, by defining your labels as custom types, the Rust compiler can check
them for you, and your IDE can auto-complete them. It is the recommended way,
as it prevents mistakes, and helps you stay organized in larger projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-programming-advanced"><a class="header" href="#bevy-programming-advanced">Bevy Programming: Advanced</a></h1>
<p>This sub-chapter covers advanced Bevy programming.</p>
<p>These topics may be useful for specialized scenarios in complex projects.</p>
<p>Most typical Bevy users are unlikely to need these features.</p>
<p>Also see the <a href="programming/../patterns/_index.html">Advanced Patterns</a> chapter, for further
information on various advanced techniques and use cases in Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stages"><a class="header" href="#stages">Stages</a></h1>
<p>All systems to be run by Bevy are contained in stages. Every frame update,
Bevy executes each stage, in order. Within each stage, Bevy's scheduling
algorithm can run many systems in parallel, using multiple CPU cores for
good performance.</p>
<p>The boundaries between stages are effectively hard synchronization points.
They ensure that all systems of the previous stage have completed before any
systems of the next stage begin, and that there is a moment in time when no
systems are in-progress.</p>
<p>This makes it possible/safe to apply <a href="programming/./commands.html"><code>Commands</code></a>. Any
operations performed by systems using <code>Commands</code> are applied at the end of
each stage.</p>
<p>Internally, Bevy has at least these built-in stages: <code>First</code>, <code>PreUpdate</code>,
<code>Update</code>, <code>PostUpdate</code>, <code>Last</code>.</p>
<p>(<a href="programming/./labels.html">labeled</a> with <code>enum CoreStage</code>)</p>
<p>By default, when you add your systems, they are added to <code>CoreStage::Update</code>.</p>
<p>Bevy's internal systems are in the other stages, to ensure they are ordered
correctly relative to your game logic.</p>
<p>If you want to add your own systems to any of Bevy's internal stages, you
need to beware of potential unexpected interactions with Bevy's own internal
systems.  Remember: Bevy's internals are implemented using ordinary systems
and ECS, just like your own stuff!</p>
<p>You can add your own additional stages. For example, if we want our debug
systems to run after our game logic:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    // label for our debug stage
    static DEBUG: &amp;str = &quot;debug&quot;;

    App::new()
        .add_plugins(DefaultPlugins)

        // add DEBUG stage after Bevy's Update
        // also make it single-threaded
        .add_stage_after(CoreStage::Update, DEBUG, SystemStage::single_threaded())

        // systems are added to the `CoreStage::Update` stage by default
        .add_system(player_gather_xp)
        .add_system(player_take_damage)

        // add our debug systems
        .add_system_to_stage(DEBUG, debug_player_hp)
        .add_system_to_stage(DEBUG, debug_stats_change)
        .add_system_to_stage(DEBUG, debug_new_hostiles)

        .run();
}
</code></pre>
<p>If you need to manage when your systems run, relative to one another, it
is generally preferable to avoid using stages, and to use <a href="programming/./system-order.html">explicit system
ordering</a> instead. Stages limit parallel execution and
the performance of your game.</p>
<p>However, stages can make it easier to organize things, when you really want
to be sure that all previous systems have completed. Stages are also the
only way to apply <code>Commands</code>.</p>
<p>If you have systems that need to rely on the actions that other systems
have performed by using <code>Commands</code>, and need to do so during the same frame,
placing those systems into separate stages is the only way to accomplish that.</p>
<p><a href="programming/../pitfalls/frame-delay.html#commands">More information on avoiding frame delays / 1-frame-lag, when using <code>Commands</code>.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removal-detection"><a class="header" href="#removal-detection">Removal Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/removal_detection.rs"><code>removal_detection</code></a>.</p>
<hr />
<p>Removal detection is special. This is because, unlike with <a href="programming/./change-detection.html">change
detection</a>, the data does not exist in the ECS anymore
(obviously), so Bevy cannot keep tracking metadata for it.</p>
<p>Nevertheless, being able to respond to removals is important for some
applications, so Bevy offers a limited form of it.</p>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<p>You can check for components that have been removed during the current
frame. The data is cleared at the end of every frame update. Note that
this makes this feature tricky to use, and requires you to use multiple
<a href="programming/./stages.html">stages</a>.</p>
<p>When you remove a component (using <a href="programming/./commands.html"><code>Commands</code></a>), the operation
is applied at the end of the stage. The system that checks for the removal
must run in a later stage during the same frame update. Otherwise, it will
not detect the removal.</p>
<p>Use the <code>RemovedComponents&lt;T&gt;</code> special system parameter type, to get an
iterator for the <code>Entity</code> IDs of all the entities that had a component of type
<code>T</code> that was removed earlier this frame.</p>
<pre><code class="language-rust no_run noplayground">/// Some component type for the sake of this example.
#[derive(Component)]
struct Seen;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // we could add our system to Bevy's `PreUpdate` stage
        // (alternatively, you could create your own stage)
        .add_system_to_stage(CoreStage::PreUpdate, remove_components)
        // our detection system runs in a later stage
        // (in this case: Bevy's default `Update` stage)
        .add_system(detect_removals)
        .run();
}

fn remove_components(
    mut commands: Commands,
    q: Query&lt;(Entity, &amp;Transform), With&lt;Seen&gt;&gt;,
) {
    for (e, transform) in q.iter() {
        if transform.translation.y &lt; -10.0 {
            // remove the `Seen` component from the entity
            commands.entity(e)
                .remove::&lt;Seen&gt;();
        }
    }
}

fn detect_removals(
    removals: RemovedComponents&lt;Seen&gt;,
    // ... (maybe Commands or a Query ?) ...
) {
    for entity in removals.iter() {
        // do something with the entity
    }
}
</code></pre>
<p>(To do things with these entities, you can just use the <code>Entity</code> IDs with
<a href="programming/./commands.html"><code>Commands::entity()</code></a> or <a href="programming/./queries.html"><code>Query::get()</code></a>.)</p>
<h2 id="resources-2"><a class="header" href="#resources-2">Resources</a></h2>
<p>Bevy does not provide any API for detecting when resources are removed.</p>
<p>You can work around this using <code>Option</code> and a separate <a href="programming/./local.html"><code>Local</code></a>
system parameter, effectively implementing your own detection.</p>
<pre><code class="language-rust no_run noplayground">fn detect_removed_res(
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
    mut my_res_existed: Local&lt;bool&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists!

        // remember that!
        *my_res_existed = true;

        // (... you can do something with the resource here if you want ...)
    } else if *my_res_existed {
        // the resource does not exist, but we remember it existed!
        // (it was removed)

        // forget about it!
        *my_res_existed = false;

        // ... do something now that it is gone ...
    }
}
</code></pre>
<p>Note that, since this detection is local to your system, it does not have
to happen during the same frame update.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-world-access"><a class="header" href="#direct-world-access">Direct World Access</a></h1>
<p>(This page hasn't been written yet...)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests-for-systems"><a class="header" href="#writing-tests-for-systems">Writing Tests for Systems</a></h1>
<p>You might want to write and run automated tests for your <a href="programming/./systems.html">systems</a>.</p>
<p>You can use the regular Rust testing features (<code>cargo test</code>) with Bevy.</p>
<p>To do this, you can create an ECS World in your tests, and then, using
<a href="programming/./world-exclusive.html">direct World access</a>, insert whatever entities and
resources you need for testing. Create a standalone <a href="programming/./stages.html">stage</a>
with the systems you want to run, and manually run it on the World.</p>
<p>Bevy's official repository has a fantastic <a href="https://github.com/bevyengine/bevy/blob/main/tests/how_to_test_systems.rs">example of how to do
this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-features"><a class="header" href="#bevy-features">Bevy Features</a></h1>
<p>This chapter covers the various features of Bevy as a Game Engine. Here you
will learn how various common Game Development concepts work in Bevy.</p>
<p>Intended for people learning how to use Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transforms-and-coordinates"><a class="header" href="#transforms-and-coordinates">Transforms and Coordinates</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>First, a quick definition, if you are new to game development:</p>
<p>a Transform is what allows you to place an object in the game world. It
is a combination of the object's &quot;translation&quot; (position/coordinates),
&quot;rotation&quot;, and &quot;scale&quot; (size adjustment).</p>
<p>You move objects around by modifying the translation, rotate them by modifying
the rotation, and make them larger or smaller by modifying the scale.</p>
<h2 id="bevys-coordinate-system"><a class="header" href="#bevys-coordinate-system">Bevy's Coordinate System</a></h2>
<p>Bevy uses the same coordinate system for 3D, 2D, and UI, for consistency.</p>
<p>It is easiest to explain in terms of 2D:</p>
<ul>
<li>The X axis goes from left to right (+X points right).</li>
<li>The Y axis goes from bottom to top (+Y points up).</li>
<li>The Z axis goes from far to near (+Z points towards you, out of the screen).</li>
<li>For 2D, the origin (X=0.0; Y=0.0) is at the <em>center of the screen</em> by default.
<ul>
<li>For UI, the origin is at the <em>bottom left</em> corner.</li>
</ul>
</li>
</ul>
<p>When you are working with 2D sprites, you can put the background on Z=0.0, and
place other sprites at increasing positive Z coordinates to layer them on top.</p>
<p>In 3D, the axes are oriented the same way.</p>
<p>This is a right-handed coordinate system.</p>
<p>It is the same as Godot, Maya, and OpenGL. Compared to Unity, the Z axis
is inverted.</p>
<p>Note: In Bevy, the Y axis always points <em>UP</em>.</p>
<p>This may feel <a href="features/../pitfalls/ui-y-up.html">unintuitive when working with UI</a>
(as it is the opposite from web pages), or if you are used to working with
2D libraries where the Y axis points down.</p>
<p>Also beware of a common pitfall when working in 2D: <a href="features/../pitfalls/2d-camera-z.html">the camera must be
positioned at a far away Z coordinate (=999.9 by default), or you might not
be able to see your sprites!</a></p>
<h2 id="bevys-transforms"><a class="header" href="#bevys-transforms">Bevy's Transforms</a></h2>
<p>In Bevy, transforms are represented by <em>two</em> <a href="features/../programming/ec.html">components</a>:
<code>Transform</code> and <code>GlobalTransform</code>. Any <a href="features/../programming/ecs-intro.html">Entity</a>
that represents an object in the game world needs to have both.</p>
<p><code>Transform</code> is what you typically work with. It is a <code>struct</code> containing
the translation, rotation, and scale. To read or manipulate these values,
access them from your <a href="features/../programming/systems.html">systems</a> using a
<a href="features/../programming/queries.html">query</a>.</p>
<p>If the entity has a <a href="features/../programming/parent-child.html">parent</a>, the <code>Transform</code>
component is relative to the parent. This means that the child object will
move/rotate/scale along with the parent.</p>
<p><code>GlobalTransform</code> represents the absolute global position in the world. If
the entity does not have a parent, then this will have the same value as the
<code>Transform</code>. The value of <code>GlobalTransform</code> is calculated/managed internally
by Bevy. You should treat it as read-only; do not mutate it.</p>
<p>Beware: The two components are synchronized by a bevy-internal system
(the &quot;transform propagation system&quot;), which runs in the PostUpdate
<a href="features/../programming/stages.html">stage</a>. This is somewhat finnicky and can result
in tricky pitfalls if you are trying to do advanced things that rely on both
the relative/local and the absolute/global transforms of entities. When you
mutate the <code>Transform</code>, the <code>GlobalTransform</code> is not updated immediately. They
will be out-of-sync until the transform propagation system runs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets"><a class="header" href="#assets">Assets</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/asset/asset_loading.rs"><code>asset_loading</code></a>.</p>
<hr />
<p>Bevy has a flexible system for loading and managing your game assets
asynchronously (in the background, without causing lag spikes in your game).</p>
<p>The data of your loaded assets is stored in <code>Assets&lt;T&gt;</code> resources.</p>
<p>Assets are tracked using handles. Handles are just lightweight IDs for
specific assets.</p>
<h2 id="loading-using-assetserver"><a class="header" href="#loading-using-assetserver">Loading using AssetServer</a></h2>
<p>To load assets from files, use the <code>AssetServer</code> resource.</p>
<pre><code class="language-rust no_run noplayground">struct UiFont(Handle&lt;Font&gt;);

fn load_ui_font(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;
) {
    let handle: Handle&lt;Font&gt; = server.load(&quot;font.ttf&quot;);

    // we can store the handle in a resource:
    //  - to prevent the asset from being unloaded
    //  - if we want to use it to access the asset later
    commands.insert_resource(UiFont(handle));
}
</code></pre>
<p>This queues the asset loading to happen in the background. The asset will take
some time to become available. You cannot access the actual data immediately
in the same system, but you can use the handle.</p>
<p>You can spawn your 2D sprites, 3D models, and UI, using the handle, even
before the asset has loaded. They will just &quot;pop in&quot; later, when the asset
becomes ready.</p>
<p>Note that it is OK to call <code>asset_server.load</code> as many times as you want, even
if the asset is currently loading, or already loaded. It will just provide
you with the same handle. If the asset is unavailable, it will begin loading.</p>
<h2 id="creating-your-own-assets"><a class="header" href="#creating-your-own-assets">Creating your own assets</a></h2>
<p>You can also add assets to <code>Assets&lt;T&gt;</code> manually.</p>
<p>This is useful if you want to create them using code (such as for procedural
generation), or if you have gotten the data in some other way.</p>
<pre><code class="language-rust no_run noplayground">fn add_material(
    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,
) {
    let new_mat = StandardMaterial {
        base_color: Color::rgba(0.25, 0.50, 0.75, 1.0),
        unlit: true,
        ..Default::default()
    };

    materials.add(new_mat);
}
</code></pre>
<h2 id="hot-reloading"><a class="header" href="#hot-reloading">Hot-Reloading</a></h2>
<p>Bevy can detect when you modify your asset files and reload them live while
the game is running. <a href="features/./hot-reload.html">See this page for more info.</a></p>
<h2 id="handles"><a class="header" href="#handles">Handles</a></h2>
<p>Handles are the typical way to refer to a particular asset. When you spawn
things into your game, such as 2D sprites, 3D models, or UI, their respective
components will need handles for the assets they use.</p>
<p>You could store your handles somewhere that is convenient for you (such as in
<a href="features/../programming/res.html">resources</a>).</p>
<p>If you don't have your handle stored anywhere, you can always generate one
from a path by calling <code>asset_server.load</code>. You could simply do that whenever
you need, and not bother storing handles.</p>
<h2 id="accessing-the-assets"><a class="header" href="#accessing-the-assets">Accessing the Assets</a></h2>
<p>To access the actual asset data from systems, use the <code>Assets&lt;T&gt;</code> resource.</p>
<p>You can identify your desired asset, using either the handle or the asset path:</p>
<pre><code class="language-rust no_run noplayground">struct SpriteSheets {
    map_tiles: Handle&lt;TextureAtlas&gt;,
}

fn use_sprites(
    handles: Res&lt;SpriteSheets&gt;,
    atlases: Res&lt;Assets&lt;TextureAtlas&gt;&gt;,
    images: Res&lt;Assets&lt;Image&gt;&gt;,
) {
    // Could be `None` if the asset isn't loaded yet
    if let Some(atlas) = atlases.get(&amp;handles.map_tiles) {
        // do something with the texture atlas
    }

    // Can use a path instead of a handle
    if let Some(map_tex) = images.get(&quot;map.png&quot;) {
        // if &quot;map.png&quot; was loaded, we can use it!
    }
}
</code></pre>
<h2 id="assetpath-and-labels"><a class="header" href="#assetpath-and-labels">AssetPath and Labels</a></h2>
<p>Assets from the filesystem can be identified by an <code>AssetPath</code>, which consists
of the file path + a label. Labels are used in situations where multiple
assets are contained in the same file. An example of this are GLTF files,
which can contain meshes, scenes, textures, materials, etc.</p>
<p>Asset paths can be created from a string, with the label (if any) attached
after a <code>#</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">fn load_gltf_things(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;
) {
    // get a specific mesh
    let my_mesh: Handle&lt;Mesh&gt; = server.load(&quot;my_scene.gltf#Mesh0/Primitive0&quot;);

    // spawn a whole scene
    let my_scene: Handle&lt;Scene&gt; = server.load(&quot;my_scene.gltf#Scene0&quot;);
    commands.spawn_scene(my_scene);
}
</code></pre>
<p>See the <a href="features/./gltf.html">GLTF page</a> for more info about working with 3D models.</p>
<h2 id="handles-and-asset-lifetime-garbage-collection"><a class="header" href="#handles-and-asset-lifetime-garbage-collection">Handles and Asset Lifetime (Garbage Collection)</a></h2>
<p>Handles have built-in reference counting (similar to <code>Rc</code>/<code>Arc</code> in Rust). This
allows Bevy to track if an asset is still needed, and automatically unload it
when it no longer is.</p>
<p>You can use <code>.clone()</code> to create multiple handles to the same asset. The
clone is a cheap operation, but it is explicit, to ensure that you are aware
of the places in your code that create additional handles and may affect
the lifetime of assets.</p>
<h3 id="weak-handles"><a class="header" href="#weak-handles">Weak Handles</a></h3>
<p>Handles can be &quot;strong&quot; (the default) or &quot;weak&quot;. Only strong handles are
counted and cause the asset to remain loaded. Weak handles let you refer
to an asset, while allowing it to be garbage-collected when no more strong
handles remain.</p>
<p>You can create weak handles using <code>.clone_weak()</code> instead of <code>.clone()</code>.</p>
<h2 id="untyped-handles"><a class="header" href="#untyped-handles">Untyped Handles</a></h2>
<p>Bevy also has a <code>HandleUntyped</code> type. Use this type of handle if you need
to be able to refer to any asset, regardless of the asset type.</p>
<p>This allows you to store a collection (such as <code>Vec</code> or <code>HashMap</code>) containing
assets of mixed types.</p>
<p>You can create an untyped handle using <code>.clone_untyped()</code>.</p>
<h3 id="untyped-loading"><a class="header" href="#untyped-loading">Untyped Loading</a></h3>
<p>Conveniently, the <code>AssetServer</code> supports untyped loading, if you don't know
what asset type the files are. You can also load an entire folder:</p>
<pre><code class="language-rust no_run noplayground">struct ExtraAssets(Vec&lt;HandleUntyped&gt;);

fn load_extra_assets(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
) {
    if let Ok(handles) = server.load_folder(&quot;extra&quot;) {
        commands.insert_resource(ExtraAssets(handles));
    }
}
</code></pre>
<p>It will try to detect the format of each asset based on the file extension.</p>
<h2 id="assetevent"><a class="header" href="#assetevent">AssetEvent</a></h2>
<p>If you need to perform specific actions when an asset is created,
modified, or removed, you can react to <code>AssetEvent</code>s.</p>
<pre><code class="language-rust no_run noplayground">struct MyMapImage {
    handle: Handle&lt;Image&gt;,
}

fn fixup_images(
    mut ev_asset: EventReader&lt;AssetEvent&lt;Image&gt;&gt;,
    mut assets: ResMut&lt;Assets&lt;Image&gt;&gt;,
    map_img: Res&lt;MyMapImage&gt;,
) {
    for ev in ev_asset.iter() {
        match ev {
            AssetEvent::Created { handle } |
            AssetEvent::Modified { handle } =&gt; {
                // a texture was just loaded or changed!

                let texture = assets.get_mut(handle).unwrap();
                // ^ unwrap is OK, because we know it is loaded now

                if *handle == map_img.handle {
                    // it is our special map image!
                } else {
                    // it is some other image
                }
            }
            AssetEvent::Removed { handle } =&gt; {
                // an image was unloaded
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hot-reloading-assets"><a class="header" href="#hot-reloading-assets">Hot-Reloading Assets</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/asset/hot_asset_reloading.rs"><code>hot_asset_reloading</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/shader/hot_shader_reloading.rs"><code>hot_shader_reloading</code></a>.</p>
<hr />
<p>At runtime, if you modify the file of an <a href="features/./assets.html">asset</a> that is loaded
into the game (via the <code>AssetServer</code>), Bevy will detect that and reload the
asset automatically. This is very useful for quick iteration. You can edit
your assets while the game is running and see the changes instantly in-game.</p>
<p>Not all file formats and use cases are supported equally well. Typical asset
types like textures / images should work without issues, but complex GLTF or
scene files, or assets involving custom logic, might not.</p>
<p>If you need to run custom logic as part of your hot-reloading workflow, you
could implement it in a system, using <a href="features/./assets.html#assetevent"><code>AssetEvent</code></a>.</p>
<p>Hot reloading is opt-in and has to be enabled in order to work. You can do
this in a <a href="features/../programming/app-builder.html">startup system</a>:</p>
<pre><code class="language-rust no_run noplayground">    asset_server.watch_for_changes().unwrap();
</code></pre>
<h2 id="shaders"><a class="header" href="#shaders">Shaders</a></h2>
<p>Bevy also supports hot-reloading for shaders. You can edit your custom shader
code and see the changes immediately. This only works if you are loading
your shaders through the bevy asset system (via the <code>AssetServer</code>). See the
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/shader/hot_shader_reloading.rs">official example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h1>
<p>Relevant official examples: <a href="https://github.com/bevyengine/bevy/tree/latest/examples#input">everything in the &quot;Input&quot; category</a>.</p>
<hr />
<p><a href="features/../code/examples/input.rs">Click here to download the example code.</a></p>
<p>This is a complete example that you can run. It will print all input activity
to the console.</p>
<hr />
<p>Bevy supports the following inputs:</p>
<ul>
<li>Keyboard</li>
<li>Mouse (relative motion, buttons, scrolling)</li>
<li>Cursor (absolute pointer position)</li>
<li>Touchscreen (with multi-touch)</li>
<li>Most controllers/gamepads/joysticks (via the <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> library)</li>
</ul>
<p>Sensors like accelerometers, gyroscopes, VR head tracking, are not supported yet.</p>
<p>For most input types (where it makes sense), Bevy provides two ways of
dealing with them:</p>
<ul>
<li>by checking the current state via <a href="features/../programming/res.html">resources</a>,</li>
<li>or via <a href="features/../programming/events.html">events</a>.</li>
</ul>
<p>Some inputs are only provided as events.</p>
<p>Checking state is done using <a href="features/../programming/res.html">resources</a> such as
<code>Input</code> (for binary inputs like keys or buttons), <code>Axis</code> (for analog inputs),
<code>Touches</code> (for fingers on a touchscreen), etc. This way of handling input is
very convenient for implementing game logic. In these scenarios, you typically
only care about the specific inputs mapped to actions in your game. You can
check specific buttons/keys to see when they get pressed/released, or what
their current state is.</p>
<p>Events are a lower-level, more all-encompassing approach. Use them if you
want to get all activity from that class of input device, rather than only
checking for specific inputs. For example, if you are implementing text
input / typing, you probably want to receive all keyboard activity.</p>
<p>Since bevy resources and events are global and accessible from any system,
you don't need to centralize your input handling code in one place. You can
check any inputs you care about, from any system.</p>
<h2 id="input-mapping"><a class="header" href="#input-mapping">Input Mapping</a></h2>
<p>Bevy does not yet offer a built-in way to do input mapping (configure key
bindings, etc). You need to come up with your own way of translating the
inputs into logical actions in your game/app.</p>
<p>There are some community-made plugins that may help with that: <a href="https://bevyengine.org/assets/#input">see the
input-section on bevy-assets</a>.</p>
<p>It may be a good idea to build your own abstractions specific to your
game. For example, if you need to handle player movement, you might want to
have a system for reading inputs and converting them to your own internal
&quot;movement intent/action events&quot;, and then another system acting on those
internal events, to actually move the player. Make sure to use <a href="features/../programming/system-order.html">explicit
system ordering</a> to avoid <a href="features/../pitfalls/frame-delay.html">lag / frame
delays</a>.</p>
<h2 id="how-to-work-with-different-input-devices"><a class="header" href="#how-to-work-with-different-input-devices">How to work with different input devices</a></h2>
<h3 id="keyboard"><a class="header" href="#keyboard">Keyboard</a></h3>
<p>Keyboard keys can be identified by Scan Code or Key Code.</p>
<p>Note: Command Key on Mac corresponds to the Super/Windows Key on PC.</p>
<p>Scan Codes represent the physical key on the keyboard, regardless of the
system layout. Key Codes represent the symbol/letter on each key and are
dependent on the keyboard layout.</p>
<p>Unfortunately, support for using Scan Codes in Bevy is limited. This can be
annoying for people with non-QWERTY keyboard layouts.</p>
<p>Checking the state of specific keys can currently only be done by Key Code,
using the <code>Input&lt;KeyCode&gt;</code> resource:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_input(
    keys: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Space) {
        // Space was pressed
    }
    if keys.just_released(KeyCode::LControl) {
        // Left Ctrl was released
    }
    if keys.pressed(KeyCode::W) {
        // W is being held down
    }
}
</code></pre>
<p>To get all keyboard activity, you can use <code>KeyboardInput</code> events:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_events(
    mut key_evr: EventReader&lt;KeyboardInput&gt;,
) {
    use bevy::input::ElementState;

    for ev in key_evr.iter() {
        match ev.state {
            ElementState::Pressed =&gt; {
                println!(&quot;Key press: {:?} ({})&quot;, ev.key_code, ev.scan_code);
            }
            ElementState::Released =&gt; {
                println!(&quot;Key release: {:?} ({})&quot;, ev.key_code, ev.scan_code);
            }
        }
    }
}
</code></pre>
<p>These events give you both the Key Code and Scan Code, but unfortunately,
the Scan Code is just represented as an arbitrary <code>u32</code> integer ID (which
means it is difficult to figure out what actual physical key it represents).</p>
<h3 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h3>
<p>Similar to keyboard input, mouse buttons are available as an <code>Input</code> state
resource, as well as events.</p>
<p>You can check the state of specific mouse buttons using <code>Input&lt;MouseButton&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_input(
    buttons: Res&lt;Input&lt;MouseButton&gt;&gt;,
) {
    if buttons.just_pressed(MouseButton::Left) {
        // Left button was pressed
    }
    if buttons.just_released(MouseButton::Left) {
        // Left Button was released
    }
    if buttons.pressed(MouseButton::Right) {
        // Right Button is being held down
    }
}
</code></pre>
<p>To get all press/release activity, use <code>MouseButtonInput</code> events:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_events(
    mut mousebtn_evr: EventReader&lt;MouseButtonInput&gt;,
) {
    use bevy::input::ElementState;

    for ev in mousebtn_evr.iter() {
        match ev.state {
            ElementState::Pressed =&gt; {
                println!(&quot;Mouse button press: {:?}&quot;, ev.button);
            }
            ElementState::Released =&gt; {
                println!(&quot;Mouse button release: {:?}&quot;, ev.button);
            }
        }
    }
}
</code></pre>
<h3 id="mouse-motion"><a class="header" href="#mouse-motion">Mouse Motion</a></h3>
<p>If you need to detect relative mouse motion, you can use <code>MouseMotion</code> events.
Whenever the mouse is moved, you will get an event with the delta.</p>
<pre><code class="language-rust no_run noplayground">fn mouse_motion(
    mut motion_evr: EventReader&lt;MouseMotion&gt;,
) {
    for ev in motion_evr.iter() {
        println!(&quot;Mouse moved: X: {} px, Y: {} px&quot;, ev.delta.x, ev.delta.y);
    }
}
</code></pre>
<p>You might want to <a href="features/../cookbook/mouse-grab.html">grab/lock the mouse inside the game
window</a>.</p>
<h3 id="mouse-cursor"><a class="header" href="#mouse-cursor">Mouse Cursor</a></h3>
<p>You can get the current coordinates of the mouse pointer, from the respective
<code>Window</code>:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_position(
    windows: Res&lt;Windows&gt;,
) {
    // Games typically only have one window (the primary window).
    // For multi-window applications, you need to use a specific window ID here.
    let window = windows.get_primary().unwrap();

    if let Some(_position) = window.cursor_position() {
        // cursor is inside the window, position given
    } else {
        // cursor is not inside the window
    }
}
</code></pre>
<p>To detect when the pointer is moved, use <code>CursorMoved</code> events to get the
updated coordinates:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_events(
    mut cursor_evr: EventReader&lt;CursorMoved&gt;,
) {
    for ev in cursor_evr.iter() {
        println!(
            &quot;New cursor position: X: {}, Y: {}, in Window ID: {:?}&quot;,
            ev.position.x, ev.position.y, ev.id
        );
    }
}
</code></pre>
<p>Note that you can only get the position of the mouse inside a window;
you cannot get the global position of the mouse in the whole OS Desktop /
on the screen as a whole.</p>
<h3 id="scrolling--mouse-wheel"><a class="header" href="#scrolling--mouse-wheel">Scrolling / Mouse Wheel</a></h3>
<p>To detect scrolling input, use <code>MouseWheel</code> events:</p>
<pre><code class="language-rust no_run noplayground">fn scroll_events(
    mut scroll_evr: EventReader&lt;MouseWheel&gt;,
) {
    use bevy::input::mouse::MouseScrollUnit;
    for ev in scroll_evr.iter() {
        match ev.unit {
            MouseScrollUnit::Line =&gt; {
                println!(&quot;Scroll (line units): vertical: {}, horizontal: {}&quot;, ev.y, ev.x);
            }
            MouseScrollUnit::Pixel =&gt; {
                println!(&quot;Scroll (pixel units): vertical: {}, horizontal: {}&quot;, ev.y, ev.x);
            }
        }
    }
}
</code></pre>
<p>The <code>MouseScrollUnit</code> enum is important: it tells you the type of scroll
input.  <code>Line</code> is for hardware with fixed steps, like the wheel on desktop
mice. <code>Pixel</code> is for hardware with smooth (fine-grained) scrolling, like
laptop touchpads.</p>
<p>You should probably handle each of these differently (with different
sensitivity settings), to provide a good experience on both types of hardware.</p>
<h3 id="controller--gamepad--joystick"><a class="header" href="#controller--gamepad--joystick">Controller / Gamepad / Joystick</a></h3>
<p>You can detect when controllers/gamepads are connected or disconnected using
<code>GamepadEvent</code>. Do this to get the ID of the device and assign it to a
&quot;player&quot; in your game. You can easily support local multiplayer.</p>
<pre><code class="language-rust no_run noplayground">/// Simple resource to store the ID of the connected gamepad.
/// We need to know which gamepad to use for player input.
struct MyGamepad(Gamepad);

fn gamepad_connections(
    mut commands: Commands,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut gamepad_evr: EventReader&lt;GamepadEvent&gt;,
) {
    for GamepadEvent(id, kind) in gamepad_evr.iter() {
        match kind {
            GamepadEventType::Connected =&gt; {
                println!(&quot;New gamepad connected with ID: {:?}&quot;, id);

                // if we don't have any gamepad yet, use this one
                if my_gamepad.is_none() {
                    commands.insert_resource(MyGamepad(*id));
                }
            }
            GamepadEventType::Disconnected =&gt; {
                println!(&quot;Lost gamepad connection with ID: {:?}&quot;, id);

                // if it's the one we previously associated with the player,
                // disassociate it:
                if let Some(MyGamepad(old_id)) = my_gamepad.as_deref() {
                    if old_id == id {
                        commands.remove_resource::&lt;MyGamepad&gt;();
                    }
                }
            }
            // other events are irrelevant
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>The other event types are for changes to axes and buttons. They are not
shown above, because handling gamepad input via events is inconvenient.</p>
<p>You can handle the analog sticks with <code>Axis&lt;GamepadAxis&gt;</code>. Buttons can be
handled with <code>Input&lt;GamepadButton&gt;</code> (similar to mouse buttons or keyboard
keys).</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input(
    axes: Res&lt;Axis&lt;GamepadAxis&gt;&gt;,
    buttons: Res&lt;Input&lt;GamepadButton&gt;&gt;,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
) {
    let gamepad = if let Some(gp) = my_gamepad {
        // a gamepad is connected, we have the id
        gp.0
    } else {
        // no gamepad is connected
        return;
    };

    // The joysticks are represented using a separate axis for X and Y

    let axis_lx = GamepadAxis(gamepad, GamepadAxisType::LeftStickX);
    let axis_ly = GamepadAxis(gamepad, GamepadAxisType::LeftStickY);

    if let (Some(x), Some(y)) = (axes.get(axis_lx), axes.get(axis_ly)) {
        // combine X and Y into one vector
        let left_stick_pos = Vec2::new(x, y);

        // implement a dead-zone to ignore small inputs
        if left_stick_pos.length() &gt; 0.1 {
            // do something with the position of the left stick
        }
    }

    let jump_button = GamepadButton(gamepad, GamepadButtonType::South);
    let heal_button = GamepadButton(gamepad, GamepadButtonType::East);

    if buttons.just_pressed(jump_button) {
        // button pressed: make the player jump
    }

    if buttons.pressed(heal_button) {
        // button being held down: heal the player
    }
}
</code></pre>
<p>Notice that the names of buttons in the <code>enum</code> are vendor-neutral (like
<code>South</code> and <code>East</code> instead of X/O or A/B). Many different kinds of hardware
should work, but if your device is not supported, you should file an issue
with the <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> project.</p>
<h3 id="touchscreen"><a class="header" href="#touchscreen">Touchscreen</a></h3>
<p>Multi-touch touchscreens are supported. You can track multiple fingers on
the screen, with position and pressure/force information. Bevy does not
offer gesture recognition.</p>
<p>The <code>Touches</code> resource allows you to track any fingers currently on the screen:</p>
<pre><code class="language-rust no_run noplayground">fn touches(
    touches: Res&lt;Touches&gt;,
) {
    // There is a lot more information available, see the API docs.
    // This example only shows some very basic things.

    for finger in touches.iter() {
        if touches.just_pressed(finger.id()) {
            println!(&quot;A new touch with ID {} just began.&quot;, finger.id());
        }
        println!(
            &quot;Finger {} is at position ({},{}), started from ({},{}).&quot;,
            finger.id(),
            finger.position().x,
            finger.position().y,
            finger.start_position().x,
            finger.start_position().y,
        );
    }
}
</code></pre>
<p>Alternatively, you can use <code>TouchInput</code> events, but this is often harder
to use:</p>
<pre><code class="language-rust no_run noplayground">fn touch_events(
    mut touch_evr: EventReader&lt;TouchInput&gt;,
) {
    use bevy::input::touch::TouchPhase;
    for ev in touch_evr.iter() {
        match ev.phase {
            TouchPhase::Started =&gt; {
                println!(&quot;Touch {} started at: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Moved =&gt; {
                println!(&quot;Touch {} moved to: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Ended =&gt; {
                println!(&quot;Touch {} ended at: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Cancelled =&gt; {
                println!(&quot;Touch {} cancelled at: {:?}&quot;, ev.id, ev.position);
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3d-models-gltf"><a class="header" href="#3d-models-gltf">3D Models (GLTF)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/3d/load_gltf.rs"><code>load_gltf</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/3d/update_gltf_scene.rs"><code>update_gltf_scene</code></a>.</p>
<hr />
<p>Bevy uses the GLTF 2.0 file format for 3D assets.</p>
<p>(other formats such as Wavefront OBJ may be unofficially available via 3rd-party plugins)</p>
<h2 id="quick-start-spawning-3d-models-into-your-world"><a class="header" href="#quick-start-spawning-3d-models-into-your-world">Quick-Start: Spawning 3D Models into your World</a></h2>
<p>The simplest use case is to just load a &quot;3D model&quot; and spawn it into the game world.</p>
<p>&quot;3D models&quot; can often be complex, consisting of multiple parts. Think of a
house: the windows, roof, doors, etc., are separate pieces, that are likely
made of multiple <a href="features/./meshes.html">meshes</a>, <a href="features/./materials.html">materials</a>, and
<a href="features/./textures.html">textures</a>. Bevy would technically need multiple ECS Entities
to represent and render the whole thing.</p>
<p>This is why your GLTF &quot;model&quot; is represented by Bevy as a <a href="features/./scenes.html">Scene</a>.
This way, you can easily spawn it, and Bevy will create all the relevant <a href="features/../programming/parent-child.html">child
entities</a> and configure them correctly.</p>
<p>So that you can treat the whole thing as &quot;a single object&quot; and position
it in the world, you can just <a href="features/./transforms.html#bevys-transforms">spawn it under a parent entity, and use its
<code>Transform</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn spawn_gltf(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    // note that we have to include the `Scene0` label
    let my_gltf = ass.load(&quot;my.glb#Scene0&quot;);

    // to be able to position our 3d model:
    // spawn a parent entity with a Transform and GlobalTransform
    // and spawn our gltf as a scene under it
    commands.spawn_bundle((
        Transform::from_xyz(2.0, 0.0, -5.0),
        GlobalTransform::identity(),
    )).with_children(|parent| {
        parent.spawn_scene(my_gltf);
    });
}
</code></pre>
<p>If your GLTF Scene represents &quot;a whole level/map&quot;, rather than &quot;an individual
3d model&quot;, and you don't need to move it around, you can just spawn the
scene directly, without creating a parent entity.</p>
<p>Also, this example assumes that you have a simple GLTF file containing only
one &quot;default scene&quot;. GLTF is a very flexible file format. A single file can
contain many &quot;models&quot; or more complex &quot;scenes&quot;. To get a better understanding
of GLTF and possible workflows, read the rest of this page. :)</p>
<h2 id="introduction-to-gltf"><a class="header" href="#introduction-to-gltf">Introduction to GLTF</a></h2>
<p>GLTF is a modern open standard for exchanging 3D assets between different
3D software applications, like game engines and 3D modeling software.</p>
<p>The GLTF file format has two variants: human-readable ascii/text (<code>*.gltf</code>)
and binary (<code>*.glb</code>). The binary format is more compact and preferable
for packaging the assets with your game. The text format may be useful for
development, as it can be easier to manually inspect using a text editor.</p>
<p>A GLTF file can contain many objects (sub-assets): meshes, materials, textures,
scenes. When loading a GLTF file, Bevy will load all of the assets contained
inside. They will be mapped to the appropriate Bevy-internal asset types.</p>
<h2 id="the-gltf-sub-assets"><a class="header" href="#the-gltf-sub-assets">The GLTF sub-assets</a></h2>
<p>GLTF terminology can be confusing, as it sometimes uses the same words to
refer to different things, compared to Bevy. This section will try explain
the various GLTF terms.</p>
<p>To understand everything, it helps to mentally consider how these concepts are
represented in different places: in your 3D modeling software (like Blender),
in the GLTF file itself, and in Bevy.</p>
<p>GLTF <strong>Scenes</strong> are what you spawn into your game world. This is typically
what you see on the screen in your 3D modeling software. Scenes combine
all of the data needed for the game engine to create all the needed
entities to represent what you want. Conceptually, think of a scene as one
&quot;unit&quot;. Depending on your use case, this could be one &quot;3d model&quot;,
or even a whole map or game level. In Bevy, these are represented as Bevy
<a href="features/./scenes.html">Scenes</a> with all the child ECS entities.</p>
<p>GLTF Scenes are composed of GLTF <strong>Nodes</strong>. These describe the &quot;objects&quot; in
the scene, typically GLTF Meshes, but can also be other things like Cameras
and Lights. Each GLTF Node has a transform for positioning it in the scene.
GLTF Nodes do not have a core Bevy equivalent; Bevy just uses this data to
create the ECS Entities inside of a Scene. Bevy has a special <code>GltfNode</code>
asset type, if you need access to this data.</p>
<p>GLTF <strong>Meshes</strong> represent one conceptual &quot;3D object&quot;. These correspond to
the &quot;objects&quot; in your 3D modeling software. GLTF Meshes may be complex and
composed of multiple smaller pieces, called GLTF Primitives, each of which
may use a different Material. GLTF Meshes do not have a core Bevy equivalent,
but there is a special <code>GltfMesh</code> asset type, which describes the primitives.</p>
<p>GLTF <strong>Primitives</strong> are individual &quot;units of 3D geometry&quot;, for the purposes of
rendering. They contain the actual geometry / vertex data, and reference the
Material to be used when drawing. In Bevy, each GLTF Primitive is represented
as a Bevy <a href="features/./meshes.html">Mesh</a> asset, and must be spawned as a separate
<a href="features/./pbr.html">PBR</a> ECS Entity to be rendered.</p>
<p>GLTF <strong>Materials</strong> describe the shading parameters for the surfaces of
your 3D models. They have full support for <a href="features/./pbr.html">Physically-Based Rendering
(PBR)</a>. They also reference the textures to use. In Bevy, they are
represented as <code>StandardMaterial</code> assets, as used by the Bevy PBR 3D renderer.</p>
<p>GLTF <strong>Textures</strong> (images) can be embedded inside the GLTF file, or stored
externally in separate image files alongside it. For example, you can have
your textures as separate PNG or JPEG files for ease of development, or
package them all inside the GLTF file for ease of distribution. In Bevy,
GLTF textures are loaded as Bevy <code>Texture</code> assets.</p>
<p>GLTF <strong>Samplers</strong> describe the settings for how the GPU should use a
given Texture. Bevy does not keep these separate; this data is stored inside
the Bevy <code>Texture</code> asset (the <code>sampler</code> field of type <code>SamplerDescriptor</code>).</p>
<h2 id="gltf-usage-patterns"><a class="header" href="#gltf-usage-patterns">GLTF Usage Patterns</a></h2>
<p>Because GLTF is so flexible, it is up to you how to structure your assets.</p>
<p>A single GLTF file might be used:</p>
<ul>
<li>To represent a single &quot;3D model&quot;, containing a single
GLTF Scene with the model, so you can spawn it into your game.</li>
<li>To represent a whole level, as a GLTF Scene, possibly also including
the camera. This lets you load and spawn a whole level/map at once.</li>
<li>To represent a piece of a level/map, such as a room.</li>
<li>To contain a set of many different &quot;3D models&quot;, each as a separate GLTF Scene.
This lets you load and manage the whole collection at once and spawn them individually as needed.</li>
<li>... others?</li>
</ul>
<h2 id="tools-for-creating-gltf-assets"><a class="header" href="#tools-for-creating-gltf-assets">Tools for Creating GLTF Assets</a></h2>
<p>If you are using a recent version of Blender (2.8+) for 3D modeling, GLTF
is supported out of the box. Just export and choose GLTF as the format.</p>
<p>For other tools, you can try these exporter plugins:</p>
<ul>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Blender_to_glTF">Old Blender (2.79)</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/3DSMax_to_glTF">3DSMax</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Maya_to_glTF">Autodesk Maya</a>
<ul>
<li>(or this <a href="https://kashika.co.jp/product/gltfexporter/">alternative</a>)</li>
</ul>
</li>
</ul>
<h2 id="using-gltf-sub-assets-in-bevy"><a class="header" href="#using-gltf-sub-assets-in-bevy">Using GLTF Sub-Assets in Bevy</a></h2>
<p>The various sub-assets contained in a GLTF file can be addressed in two ways:</p>
<ul>
<li>by index (integer id, in the order they appear in the file)</li>
<li>by name (text string, the names you set in your 3D modeling software
when creating the asset, which can be exported into the GLTF)</li>
</ul>
<p>To get handles to the respective assets in Bevy, you can use the <code>Gltf</code> &quot;master
asset&quot;, or alternatively, <a href="features/./assets.html#assetpath-and-labels">AssetPath with Labels</a>.</p>
<h3 id="gltf-master-asset"><a class="header" href="#gltf-master-asset"><code>Gltf</code> master asset</a></h3>
<p>If you have a complex GLTF file, this is likely the most flexible and useful
way of navigating its contents and using the different things inside.</p>
<p>You have to wait for the GLTF file to load, and then use the <code>Gltf</code> asset.</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::Gltf;

/// Helper resource for tracking our asset
struct MyAssetPack(Handle&lt;Gltf&gt;);

fn load_gltf(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    let gltf = ass.load(&quot;my_asset_pack.glb&quot;);
    commands.insert_resource(MyAssetPack(gltf));
}

fn spawn_gltf_objects(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
) {
    // if the GLTF has loaded, we can navigate its contents
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // spawn the first scene in the file
        commands.spawn_scene(gltf.scenes[0].clone());

        // spawn the scene named &quot;YellowCar&quot;
        // do it under a parent entity, to position it in the world
        commands.spawn_bundle((
            Transform::from_xyz(1.0, 2.0, 3.0),
            GlobalTransform::identity(),
        )).with_children(|parent| {
            parent.spawn_scene(gltf.named_scenes[&quot;YellowCar&quot;].clone());
        });

        // PERF: the `.clone()`s are just for asset handles, don't worry :)
    }
}
</code></pre>
<p>For a more convoluted example, say we want to directly create a 3D PBR
entity, for whatever reason. (This is not recommended; you should probably
just use scenes)</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::GltfMesh;

fn gltf_manual_entity(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
    assets_gltfmesh: Res&lt;Assets&lt;GltfMesh&gt;&gt;,
) {
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // Get the GLTF Mesh named &quot;CarWheel&quot;
        // (unwrap safety: we know the GLTF has loaded already)
        let carwheel = assets_gltfmesh.get(&amp;gltf.named_meshes[&quot;CarWheel&quot;]).unwrap();

        // Spawn a PBR entity with the mesh and material of the first GLTF Primitive
        commands.spawn_bundle(PbrBundle {
            mesh: carwheel.primitives[0].mesh.clone(),
            // (unwrap: material is optional, we assume this primitive has one)
            material: carwheel.primitives[0].material.clone().unwrap(),
            ..Default::default()
        });
    }
}
</code></pre>
<h3 id="assetpath-with-labels"><a class="header" href="#assetpath-with-labels">AssetPath with Labels</a></h3>
<p>This is another way to access specific sub-assets. It is less reliable,
but may be easier to use in some cases.</p>
<p>Use the <code>AssetServer</code> to convert a path string into a <code>Handle</code>.</p>
<p>The advantage is that you can get handles to your sub-assets immediately,
even if your GLTF file hasn't loaded yet.</p>
<p>The disadvantage is that it is more error-prone. If you specify a sub-asset
that doesn't actually exist in the file, or mis-type the label, or use the
wrong label, it will just silently not work. Also, currently only using a
numerial index is supported. You cannot address sub-assets by name.</p>
<pre><code class="language-rust no_run noplayground">fn use_gltf_things(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    // spawn the first scene in the file
    let scene0 = ass.load(&quot;my_asset_pack.glb#Scene0&quot;);
    commands.spawn_scene(scene0);

    // spawn the second scene under a parent entity
    // (to move it)
    let scene1 = ass.load(&quot;my_asset_pack.glb#Scene1&quot;);
    commands.spawn_bundle((
        Transform::from_xyz(1.0, 2.0, 3.0),
        GlobalTransform::identity(),
    )).with_children(|parent| {
        parent.spawn_scene(scene1);
    });
}
</code></pre>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <code>Scene</code></li>
<li><code>Node{}</code>: GLTF Node as <code>GltfNode</code></li>
<li><code>Mesh{}</code>: GLTF Mesh as <code>GltfMesh</code></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <code>Mesh</code></li>
<li><code>Material{}</code>: GLTF Material as Bevy <code>StandardMaterial</code></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <code>Texture</code></li>
</ul>
<p>The <code>GltfNode</code> and <code>GltfMesh</code> asset types are only useful to help you navigate
the contents of your GLTF file. They are not core Bevy renderer types, and
not used by Bevy in any other way. The Bevy renderer expects Entities with
<code>PbrBundle</code>; for that you need the <code>Mesh</code> and <code>StandardMaterial</code>.</p>
<h2 id="bevy-limitations"><a class="header" href="#bevy-limitations">Bevy Limitations</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are not supported. Your asset should still load/render,
but without mipmapping.</li>
<li>Bevy's renderer requires all meshes/primitives to have per-vertex positions,
UVs, and normals. Make sure all of this data is included.</li>
<li>Meshes/primitives without textures (if the material is just a solid color)
must still include UVs regardless. Bevy will not render meshes without UVs.</li>
<li>When using normal maps in your material, tangents must also be included in the mesh.
Meshes with normal maps but without tangents are valid; other software would
typically autogenerate the tangents if they are missing, but Bevy does not support
this yet. Be sure to tick the checkbox for including tangents when exporting.</li>
<li>Bevy does not have built-in skeletal animation support yet. Animations are
completely ignored.</li>
<li>Bevy does not support loading GLTF Lights. GLTF Scenes containing Light Nodes
will be spawned without the lights.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixed-timestep"><a class="header" href="#fixed-timestep">Fixed Timestep</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/ecs/fixed_timestep.rs"><code>fixed_timestep</code></a>.</p>
<hr />
<p>If you need something to happen at fixed time intervals (a common
use case is Physics updates), you can use Bevy's <code>FixedTimestep</code>
<a href="features/../programming/run-criteria.html">Run Criteria</a>.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core::FixedTimestep;

// The timestep says how many times to run the SystemSet every second
// For TIMESTEP_1, it's once every second
// For TIMESTEP_2, it's twice every second

const TIMESTEP_1_PER_SECOND: f64 = 60.0 / 60.0;
const TIMESTEP_2_PER_SECOND: f64 = 30.0 / 60.0;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system_set(
            SystemSet::new()
                // This prints out &quot;hello world&quot; once every second
                .with_run_criteria(FixedTimestep::step(TIMESTEP_1_PER_SECOND))
                .with_system(slow_timestep)
        )
        .add_system_set(
            SystemSet::new()
                // This prints out &quot;goodbye world&quot; twice every second
                .with_run_criteria(FixedTimestep::step(TIMESTEP_2_PER_SECOND))
                .with_system(fast_timestep)
        )
        .run();
}

fn slow_timestep() {
    println!(&quot;hello world&quot;);
}

fn fast_timestep() {
    println!(&quot;goodbye world&quot;);
}
</code></pre>
<p>(thanks <strong>@billyb2</strong> for <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/pull/64">contributing this example</a>)</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>You can check the current state of the fixed timestep trackers, by accessing
the <code>FixedTimesteps</code> <a href="features/../programming/res.html">resource</a>. This lets you know
how much time remains until the next time it triggers, or how much it has
overstepped. You need to label your fixed timesteps.</p>
<p>See the [official example], which illustrates this.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>Note that, as this feature is implemented using Run Criteria, the systems
are still called as part of the regular frame-update cycle, along with all
of the normal systems. So, the timing is not exact.</p>
<p>The <code>FixedTimestep</code> run criteria simply checks how much time passed since the
last time your systems were ran, and decides whether to run them during the
current frame, or not, or run them multiple times, as needed.</p>
<h3 id="danger-lost-events"><a class="header" href="#danger-lost-events"><strong>Danger!</strong> Lost events!</a></h3>
<p>By default, Bevy's <a href="features/../programming/events.html">events</a> are <em>not reliable!</em> They
only persist for 2 frames, after which they are lost. If your fixed-timestep
systems receive events, beware that you may miss some events if the framerate
is higher than 2x the fixed timestep.</p>
<p>One way around that is to use <a href="features/../patterns/manual-event-clear.html">events with manual
clearing</a>. This gives you control over
how long events persist, but can also leak / waste memory if you forget to
clear them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-2"><a class="header" href="#audio-2">Audio</a></h1>
<p>Bevy's own built-in audio support is extremely barebones and limited. It
can play sounds, but that's about it. It doesn't even have volume control.</p>
<p>Instead, we recommend that you try the
<a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a> community
plugin, which integrates the Kira sound library with bevy. Kira is much
more feature-rich, including support for managing many audio tracks (like
background music and sound effects), with volume control, stereo panning,
playback rate, and streaming. It also has <a href="features/../platforms/wasm.html">web</a> support.</p>
<p>The community largely considers Bevy's audio to be obsolete and useless;
it will probably be removed and replaced with something else (maybe
<code>bevy_kira_audio</code>).</p>
<p>Using <code>bevy_kira_audio</code> in your project requires some extra configuration,
because you need to disable Bevy's own audio. Bevy's audio is a cargo feature
that is enabled by default, but must be disabled. Cargo does not let you
disable individual default features, so you need to disable all default bevy
features and re-enable the ones you need.</p>
<p>You must not include the <code>bevy_audio</code> feature, or any of the audio file
formats (such as the default <code>vorbis</code>). Enable the file formats you care
about on <code>bevy_kira_audio</code> instead of Bevy.</p>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.6&quot;
default-features = false
# These are the remaining default features other than `bevy_audio` and `mp3`
features = [
  &quot;render&quot;,
  &quot;bevy_winit&quot;,
  &quot;bevy_gilrs&quot;,
  &quot;png&quot;,
  &quot;hdr&quot;,
  &quot;filesystem_watcher&quot;,
  &quot;x11&quot;
]

[dependencies.bevy_kira_audio]
version = &quot;0.7.0&quot;
# `ogg` format support is enabled by default, disable if you don't want it
default-features = false
# enable the features you care about
features = [
  &quot;wav&quot;,
  &quot;flac&quot;,
  &quot;mp3&quot;,
  &quot;ogg&quot;,
]
</code></pre>
<p>See <a href="features/../setup/bevy-modular.html#bevy-cargo-features">this page</a> for more
information about Bevy's cargo features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h1>
<p>This chapter covers some common issues or surprises that you might be
likely to encounter when working with Bevy, with specific advice about how
to address them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strange-build-errors"><a class="header" href="#strange-build-errors">Strange Build Errors</a></h1>
<p>Sometimes, you can get strange and confusing build errors when trying to
compile your project.</p>
<h2 id="update-your-rust"><a class="header" href="#update-your-rust">Update your Rust</a></h2>
<p>First, make sure your Rust is up-to-date. When using Bevy, you must use at
least the latest stable version of Rust (or nightly).</p>
<p>If you are using <code>rustup</code> to manage your Rust installation, you can run</p>
<pre><code class="language-shell">rustup update
</code></pre>
<h2 id="fix-clear-the-cargo-state"><a class="header" href="#fix-clear-the-cargo-state">Fix: Clear the cargo state</a></h2>
<p>Many kinds of build errors can often be fixed by forcing <code>cargo</code> to regenerate
its internal state (recompute dependencies, etc.). You can do this by deleting
the <code>Cargo.lock</code> file and the <code>target</code> directory.</p>
<pre><code class="language-shell">rm -rf target Cargo.lock
</code></pre>
<p>Try building your project again after doing this. It is likely that the
mysterious errors will go away.</p>
<p>This trick often fixes the broken build, but if it doesn't help you,
your issue might require further investigation. Reach out to the Bevy
community via GitHub or Discord, and ask for help.</p>
<p>If you are using bleeding-edge Bevy (&quot;main&quot;), and the above does not solve
the problem, your errors might be caused by 3rd-party plugins. See <a href="pitfalls/../setup/bevy-git.html#how-to-use-bleeding-edge-bevy">this
page</a> for solutions.</p>
<h2 id="what-errors"><a class="header" href="#what-errors">What errors?</a></h2>
<p>One common example is the &quot;failed to select a version&quot; error, which can
look something like this:</p>
<pre><code>error: failed to select a version for `web-sys`.
    ... required by package `wgpu v0.9.0`
    ... which is depended on by `bevy_wgpu v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_internal v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy-scratchpad v0.1.0 (C:\Users\Alice\Documents\bevy-scratchpad)`
versions that meet the requirements `=0.3.50` are: 0.3.50

all possible versions conflict with previously selected packages.

  previously selected package `web-sys v0.3.46`
    ... which is depended on by `bevy_app v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_asset v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_audio v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy_internal v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy v0.5.0 (https://github.com/bevyengine/bevy#6a8a8c9d)`
    ... which is depended on by `bevy-scratchpad v0.1.0 (C:\Users\Alice\Documents\bevy-scratchpad)`

failed to select a version for `web-sys` which could resolve this conflict
</code></pre>
<p>(there are many variations, yours might not be identical to the example above)</p>
<p>Another related error are seemingly-nonsensical compiler messages about
conflicts with Bevy's internal types (like &quot;expected type <code>Transform</code>,
found type <code>Transform</code>&quot;).</p>
<h2 id="why-does-this-happen"><a class="header" href="#why-does-this-happen">Why does this happen?</a></h2>
<p>Such errors are often caused by <code>cargo</code>'s internal state being broken. Usually,
it is because of dependencies not being resolved properly, causing cargo to
try to link multiple versions of Bevy into your project. This often occurs when
transitioning your project between the release and the git version of Bevy. Cargo
remembers the versions it was previously using, and gets confused.</p>
<p>See this <a href="https://github.com/rust-lang/cargo/issues/9994">cargo issue</a> about
this bug. If you have any interesting information to add, you can help
by contributing to that issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-adding-function-as-system"><a class="header" href="#error-adding-function-as-system">Error adding function as system</a></h1>
<p>You can sometimes get confusing arcane compiler errors when you try to add
systems to your Bevy app.</p>
<p>The errors can look like this:</p>
<pre><code>no method named `system` found for fn item `for&lt;'r, 's&gt; fn(...) {my_system}` in the current scope
`my_system` is a function, perhaps you wish to call it
</code></pre>
<p>This is caused by your function having incompatible parameters. Bevy can
only accept special types as system parameters.</p>
<p>You might also errors that look like this:</p>
<pre><code>the trait bound `Component: WorldQuery` is not satisfied
the trait `WorldQuery` is not implemented for `Component`
</code></pre>
<pre><code>this struct takes at most 2 type arguments but 3 type arguments were supplied
</code></pre>
<p>These errors are caused by a malformed query.</p>
<h2 id="common-beginner-mistakes"><a class="header" href="#common-beginner-mistakes">Common beginner mistakes</a></h2>
<ul>
<li>Using <code>&amp;mut Commands</code> (bevy 0.4 syntax) instead of <code>Commands</code>.</li>
<li>Using <code>Query&lt;MyStuff&gt;</code> instead of <code>Query&lt;&amp;MyStuff&gt;</code> or <code>Query&lt;&amp;mut MyStuff&gt;</code>.</li>
<li>Using <code>Query&lt;&amp;ComponentA, &amp;ComponentB&gt;</code> instead of <code>Query&lt;(&amp;ComponentA, &amp;ComponentB)&gt;</code>
(forgetting the tuple)</li>
<li>Using your resource types directly without <code>Res</code> or <code>ResMut</code>.</li>
<li>Using your component types directly without putting them in a <code>Query</code>.</li>
<li>Using other arbitrary types in your function.</li>
</ul>
<p>Note that <code>Query&lt;Entity&gt;</code> is correct, because the Entity ID is special;
it is not a component.</p>
<h2 id="supported-types"><a class="header" href="#supported-types">Supported types</a></h2>
<p>It can be difficult to figure out what types are supported from the <a href="https://docs.rs/bevy/0.6.0/bevy/ecs/trait.SystemParam.html">API
docs</a>, so here
is a list:</p>
<p>Only the following types are supported as system parameters:</p>
<ul>
<li><code>Commands</code></li>
<li><code>Res&lt;T&gt;</code> / <code>ResMut&lt;T&gt;</code></li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code> / <code>Option&lt;ResMut&lt;T&gt;&gt;</code></li>
<li><code>Local&lt;T&gt;</code></li>
<li><code>EventReader&lt;T&gt;</code></li>
<li><code>EventWriter&lt;T&gt;</code></li>
<li><code>Query&lt;T, F = ()&gt;</code>; can contain tuples of up to 15 types</li>
<li><code>QuerySet</code> with up to 4 queries</li>
<li><code>NonSend&lt;T&gt;</code> / <code>NonSendMut&lt;T&gt;</code></li>
<li><code>Entities</code></li>
<li><code>Components</code></li>
<li><code>Bundles</code></li>
<li><code>Archetypes</code></li>
<li><code>RemovedComponents&lt;T&gt;</code></li>
<li><code>Arc&lt;parking_lot::Mutex&lt;Commands&gt;&gt;</code></li>
<li><code>DrawContext</code></li>
<li>tuples containing any of these types, with up to 16 members</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more, group
them into tuples to work around the limit.</p>
<p>You can nest tuples as much as you want, to avoid running into the limits
on the maximum numbers of parameters, or simply to organize your parameters
into groups.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrow-multiple-fields-from-struct"><a class="header" href="#borrow-multiple-fields-from-struct">Borrow multiple fields from struct</a></h1>
<p>When you have a component or resource, that is larger struct with multiple
fields, sometimes you want to borrow several of the fields at the same time,
possibly mutably. This can result in a compiler error about conflicting borrows:</p>
<pre><code class="language-rust no_run noplayground">struct MyThing {
    a: Foo,
    b: Bar,
}

fn helper_func(foo: &amp;Foo, bar: &amp;mut Bar) {
    // do something
}

fn my_system(mut q: Query&lt;&amp;mut MyThing&gt;) {
    for thing in q.iter_mut() {
        helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    }
}
</code></pre>
<p>The error:</p>
<pre><code>error[E0502]: cannot borrow `thing` as mutable because it is also borrowed as immutable
    |
    |         helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    |         -----------  -----         ^^^^^ mutable borrow occurs here
    |         |            |
    |         |            immutable borrow occurs here
    |         immutable borrow later used by call
</code></pre>
<p>The solution is to use the &quot;reborrow&quot; idiom, a common but non-obvious trick in Rust programming:</p>
<pre><code class="language-rust no_run noplayground">        // add this at the start of the for loop, before using `thing`:
        let thing = &amp;mut *thing;
</code></pre>
<p>Note that this line triggers <a href="pitfalls/../programming/change-detection.html">change detection</a>.
Even if you don't modify the data afterwards, the component gets marked as changed.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>Bevy typically gives you access to your data via special wrapper types
(like <code>Res&lt;T&gt;</code>, <code>ResMut&lt;T&gt;</code>, and <code>Mut&lt;T&gt;</code> (when querying for components
mutably)). This lets Bevy track access to the data.</p>
<p>These are &quot;smart pointer&quot; types that use the Rust <code>Deref</code> trait to dereference
to your data. They usually work seamlessly and you don't even notice them.</p>
<p>However, in a sense, they are opaque to the compiler. The Rust language
allows fields of a struct to be borrowed individually, when you have direct
access to the struct, but this does not work when it is wrapped in another type.</p>
<p>The &quot;reborrow&quot; trick shown above, effectively converts the wrapper into a regular
Rust reference. <code>*thing</code> dereferences the wrapper via <code>Deref</code>, and then <code>&amp;mut</code>
borrows it mutably. You now have <code>&amp;mut MyStuff</code> instead of <code>Mut&lt;MyStuff&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-1"><a class="header" href="#performance-1">Performance</a></h1>
<p>This page is a summary of performance issues when working with Bevy.</p>
<p>(WIP)</p>
<h2 id="unoptimized-debug-builds"><a class="header" href="#unoptimized-debug-builds">Unoptimized debug builds</a></h2>
<p>Rust without compiler optimizations is <em>very slow</em>. With Bevy in
particular, the default debug build settings will lead to <em>awful</em> runtime
performance. Assets are slow to load and FPS is low.</p>
<p>Common symptoms:</p>
<ul>
<li>Loading high-res 3D models with a lot of large textures, from GLTF
files, can take over 20 seconds! This can trick you into thinking
that your code is not working, because you will not see anything on
the screen until it is ready.</li>
<li>After spawning some 2D sprites or 3D models, framerate may drop to
unplayable levels.</li>
</ul>
<p>However, fully-optimized release builds can be slow to compile.</p>
<p>Solutions:</p>
<pre><code class="language-toml"># in `Cargo.toml` or `.cargo/config.toml`

# Enable optimizations for dependencies (incl. Bevy), but not for our code:
[profile.dev.package.&quot;*&quot;]
opt-level = 3

# Maybe also enable only a small amount of optimization for our code:
[profile.dev]
opt-level = 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-cant-see-my-ui"><a class="header" href="#i-cant-see-my-ui">I can't see my UI!</a></h1>
<p>If you are trying to build a UI, but it is not showing on the screen, you
probably forgot to spawn a UI Camera. The UI Camera is required for Bevy to
render UI.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn_bundle(UiCameraBundle::default());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cannot-see-sprites-in-2d"><a class="header" href="#cannot-see-sprites-in-2d">Cannot see sprites in 2D</a></h1>
<p>Bevy's 2D <a href="pitfalls/../features/transforms.html">coordinate space</a> is set up so that
your background can be at Z=0.0, and other sprite layers can be at positive
+Z coordinates above that.</p>
<p>However, this means that, to see your scene, the camera needs to be placed
far away, at a large +Z coordinate, looking towards -Z.</p>
<p>If you are overriding the camera transform / creating your own transform, <em>you
need to do this!</em> The default transform (with Z=0.0) will place the camera so
that your sprites (at positive +Z coordinates) would be behind the camera,
and you wouldn't see them! You need to either set a large Z coordinate, or
preserve/copy the Z value from the <code>Transform</code> that is generated by Bevy's
builtin Bundle constructor (<code>OrthographicCameraBundle::new_2d()</code>).</p>
<p>By default, when you create a 2D camera using Bevy's built-in Bundle
constructor (<code>OrthographicCameraBundle::new_2d()</code>), Bevy sets the camera
<code>Transform</code> to have Z=999.9. This is close to the default clipping plane
(visible range of Z axis), which is set to 1000.0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cannot-see-3d-model"><a class="header" href="#cannot-see-3d-model">Cannot see 3D model</a></h1>
<p>This page will list some common issues that you may encounter, if you are
trying to spawn a 3D object, but cannot see it on the screen.</p>
<h2 id="incorrect-usage-of-bevy-gltf-assets"><a class="header" href="#incorrect-usage-of-bevy-gltf-assets">Incorrect usage of Bevy GLTF assets</a></h2>
<p>Refer to the <a href="pitfalls/../features/gltf.html">GLTF page</a> to learn how to correctly
use GLTF with Bevy.</p>
<p>GLTF files are complex. They contain many sub-assets, represented by
different Bevy types. Make sure you are using the correct thing.</p>
<p>Make sure you are spawning a GLTF Scene, or using the correct <code>Mesh</code> and
<code>StandardMaterial</code> associated with the correct GLTF Primitive.</p>
<p>If you are using an asset path, be sure to include a label for the sub-asset you want:</p>
<pre><code class="language-rust no_run noplayground">asset_server.load(&quot;my.gltf#Scene0&quot;);
</code></pre>
<p>If you are spawning the top-level <code>Gltf</code> master asset, it won't work.</p>
<p>If you are spawning a GLTF Mesh, it won't work.</p>
<p>If you are using the top-level <code>Gltf</code> master asset or a <code>GltfMesh</code> on a Bevy
<code>PbrBundle</code> entity that you have created yourself, it won't work. You need
a specific GLTF Primitive. Or just use Scenes. :)</p>
<h2 id="unsupported-gltf"><a class="header" href="#unsupported-gltf">Unsupported GLTF</a></h2>
<p>Bevy's GLTF support is still limited in features. See the <a href="pitfalls/../features/gltf.html#bevy-limitations">Limitations
section in the GLTF page</a> for some
considerations.</p>
<h2 id="unoptimized--debug-builds"><a class="header" href="#unoptimized--debug-builds">Unoptimized / Debug builds</a></h2>
<p>Maybe your asset just takes a while to load? Bevy (and Rust in general)
is very slow without compiler optimizations. It's actually possible that
complex GLTF files with big textures can take over a minute to load and
show up on the screen. It would be almost instant in optimized builds. <a href="pitfalls/./performance.html">See
here</a>.</p>
<h2 id="vertex-order-and-culling"><a class="header" href="#vertex-order-and-culling">Vertex Order and Culling</a></h2>
<p>By default, the Bevy renderer assumes Counter-Clockwise vertex order and has
back-face culling enabled.</p>
<p>If you are generating your <a href="pitfalls/../features/meshes.html">Mesh</a> from code, make sure
your vertices are in the correct order.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="support-for-loading-different-file-formats"><a class="header" href="#support-for-loading-different-file-formats">Support for loading different file formats</a></h1>
<p>By default, only a few asset file formats are enabled:</p>
<ul>
<li>Images: PNG and HDR</li>
<li>Audio: OGG/Vorbis</li>
</ul>
<p>You can enable more formats with cargo features:</p>
<ul>
<li>Images: JPEG, TGA, BMP, DDS</li>
<li>Audio: FLAC, OGG/Vorbis, WAV</li>
</ul>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.6&quot;
features = [&quot;jpeg&quot;, &quot;tga&quot;, &quot;bmp&quot;, &quot;dds&quot;, &quot;flac&quot;, &quot;vorbis&quot;, &quot;wav&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-time-vs-rustos-time"><a class="header" href="#bevy-time-vs-rustos-time">Bevy Time vs. Rust/OS time</a></h1>
<p>Do <em>not</em> use <code>std::time::Instant::now()</code> to get the current time. Use Bevy's
<code>Res&lt;Time&gt;</code>.</p>
<p>Rust (and the OS) give you the precise time of the moment you call that
function. However, that's not what you want.</p>
<p>Your game systems are run by Bevy's parallel scheduler, which means that they
could be called at vastly different instants every frame! This will result in
inconsistent / jittery timings and make your game misbehave or look stuttery.</p>
<p>Bevy's <code>Time</code> gives you timing information that is correct and consistent. It's
designed to be used for game logic.</p>
<p>This is not Bevy-specific, but applies to game development in general. Always
get your time from your game engine, not from your programming language or
operating system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui-layout-is-inverted"><a class="header" href="#ui-layout-is-inverted">UI layout is inverted</a></h1>
<p><a href="pitfalls/../features/transforms.html">In bevy, the Y axis always points <em>UP</em>. When working with UI, the origin
is at the <em>bottom left</em> corner of the screen.</a></p>
<p>This means that UI is laid out from bottom to top.</p>
<p>This is the opposite of the typical behavior of web pages and other UI
toolkits, where layout works from top to bottom.</p>
<p>Bevy uses the Flexbox layout model for UI, but unlike in web pages / CSS,
the vertical axis is inverted.</p>
<p>Unintuitively, this means that to build UIs that flow from top to bottom,
you need to use <code>FlexDirection::ColumnReverse</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uv-coordinates-in-bevy"><a class="header" href="#uv-coordinates-in-bevy">UV coordinates in Bevy</a></h1>
<p>In Bevy, the vertical axis for the pixels of textures / images, and when
sampling textures in a shader, points <em>downwards</em>, from top to bottom. The
origin is at the top left.</p>
<p>This is consistent with how most image file formats store pixel data, and
with how most graphics APIs work (including DirectX, Vulkan, Metal, WebGPU,
but <em>not</em> OpenGL).</p>
<p>This is different from OpenGL (and frameworks based on it). If your prior
experience is with these, you may find that the textures on your meshes are
flipped vertically. You will have to reexport / regenerate your meshes in
the correct UV format.</p>
<p>This is also inconsistent with the <a href="pitfalls/../features/transforms.html">World-coordinate
system used everywhere else in Bevy</a>, where the
Y axis points up.</p>
<p>If the images of your 2D sprites are flipped (for whatever reason), you can
correct that using Bevy's sprite-flipping feature:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn_bundle(SpriteBundle {
    sprite: Sprite {
        flip_y: true,
        flip_x: false,
        ..Default::default()
    },
    ..Default::default()
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h1>
<p>This chapter is about any non-obvious tricks, programming techniques, or
other advanced uses of Bevy.</p>
<p>These topics are intended for people already comfortable with
<a href="patterns/../programming/_index.html">Bevy Programming</a>.</p>
<p>They may or may not be applicable to your project. The things covered in
this chapter may be controversial or not universally good practice. Form
your own opinions and use at your own discretion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-systems"><a class="header" href="#generic-systems">Generic Systems</a></h1>
<p>Bevy systems are just plain rust functions, which means they can be
generic. You can add the same system multiple times, parametrized to work
on different Rust types or values.</p>
<h2 id="generic-over-component-types"><a class="header" href="#generic-over-component-types">Generic over Component types</a></h2>
<p>You can use the generic type parameter to specify what compnent types (and
hence what entities) your system should operate on.</p>
<p>This can be useful when combined with Bevy <a href="patterns/../programming/states.html">states</a>.
You can do the same thing to different sets of entities depending on state.</p>
<h3 id="example-cleanup"><a class="header" href="#example-cleanup">Example: Cleanup</a></h3>
<p>One straightforward use-case is for cleanup. We can make a generic cleanup
system that just despawns all entities that have a certain component
type. Then, trivially run it on exiting different states.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::component::Component;

fn cleanup_system&lt;T: Component&gt;(
    mut commands: Commands,
    q: Query&lt;Entity, With&lt;T&gt;&gt;,
) {
    for e in q.iter() {
        commands.entity(e).despawn_recursive();
    }
}
</code></pre>
<p>Menu entities can be tagged with <code>cleanup::MenuExit</code>, entities from the game
map can be tagged with <code>cleanup::LevelUnload</code>.</p>
<p>We can add the generic cleanup system to our state transitions, to take care
of the respective entities:</p>
<pre><code class="language-rust no_run noplayground">/// Marker components to group entities for cleanup
mod cleanup {
    use bevy::prelude::*;
    #[derive(Component)]
    pub struct LevelUnload;
    #[derive(Component)]
    pub struct MenuClose;
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_state(AppState::MainMenu)
        // add the cleanup systems
        .add_system_set(SystemSet::on_exit(AppState::MainMenu)
            .with_system(cleanup_system::&lt;cleanup::MenuClose&gt;))
        .add_system_set(SystemSet::on_exit(AppState::InGame)
            .with_system(cleanup_system::&lt;cleanup::LevelUnload&gt;))
        .run();
}
</code></pre>
<h2 id="using-traits"><a class="header" href="#using-traits">Using Traits</a></h2>
<p>You can use this in combination with Traits, for when you need some sort of varying
implementation/functionality for each type.</p>
<h3 id="example-bevys-camera-projections"><a class="header" href="#example-bevys-camera-projections">Example: Bevy's Camera Projections</a></h3>
<p>(this is a use-case within Bevy itself)</p>
<p>Bevy has a <code>CameraProjection</code> trait. Different projection types like <code>PerspectiveProjection</code> and
<code>OrthographicProjection</code> implement that trait, providing the correct logic for how to respond
to resizing the window, calculating the projection matrix, etc.</p>
<p>There is a generic system <code>fn camera_system::&lt;T: CameraProjection + Component&gt;</code>, which handles
all the cameras with a given projection type. It will call the trait methods when appropriate
(like on window resize events).</p>
<p>The <a href="patterns/../cookbook/custom-projection.html">Bevy Cookbook Custom Camera Projection Example</a> shows
this API in action.</p>
<h2 id="using-const-generics"><a class="header" href="#using-const-generics">Using Const Generics</a></h2>
<p>Now that Rust has support for Const Generics, functions can also be parametrized by values,
not just types.</p>
<pre><code class="language-rust no_run noplayground">fn process_layer&lt;const LAYER_ID: usize&gt;(
    // system params
) {
    // do something for this `LAYER_ID`
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(process_layer::&lt;1&gt;)
        .add_system(process_layer::&lt;2&gt;)
        .add_system(process_layer::&lt;3&gt;)
        .run();
}
</code></pre>
<p>Note that these values are static / constant at compile-time. This can be a severe limitation. In
some cases, when you might suspect that you could use const generics, you might realize that
you actually want a runtime value.</p>
<p>If you need to &quot;configure&quot; your system by passing in some data, you could, instead, use a
<a href="patterns/../programming/res.html">Resource</a> or <a href="patterns/../programming/local.html">Local</a>.</p>
<p>Note: As of Rust 1.53, support for using <code>enum</code> values as const generics is not yet stable. To
use <code>enum</code>s, you need Rust Nightly, and to enable the experimental/unstable feature (put this
at the top of your <code>main.rs</code> or <code>lib.rs</code>):</p>
<pre><code class="language-rust no_run noplayground">#![feature(const_generics)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-event-clearing"><a class="header" href="#manual-event-clearing">Manual Event Clearing</a></h1>
<p><a href="patterns/../code/examples/manual-event-clear.rs">Click here to download a full example file with the code from this page.</a></p>
<hr />
<p>The <a href="patterns/../programming/events.html">event</a> queue needs to be cleared periodically,
so that it does not grow indefinitely and waste unbounded memory.</p>
<p>Bevy's default cleanup strategy is to clear events every frame, but with double
buffering, so that events from the previous frame update stay available. This
means that you can handle the events only until the end of the next frame
after the one when they are sent.</p>
<p>This default works well for systems that run every frame and check for events
every time, which is the typical usage pattern.</p>
<p>However, if you have systems that do not read events every frame, they might
miss some events. Some common scenarios where this occurs are:</p>
<ul>
<li>systems with an early-return, that don't read events every time they run</li>
<li>when using <a href="patterns/../features/fixed-timestep.html">fixed timestep</a></li>
<li>systems that only run in specific <a href="patterns/../programming/states.html">states</a>,
such as if your game has a pause state</li>
<li>when using custom <a href="patterns/../programming/run-criteria.html">run criteria</a> to control
your systems</li>
</ul>
<p>To be able to reliably manage events in such circumstances, you might want
to have manual control over how long the events are held in memory.</p>
<p>You can replace Bevy's default cleanup strategy with your own.</p>
<p>To do this, simply add your event type (wrapped as <code>Events&lt;T&gt;</code>) to the
<a href="patterns/../programming/app-builder.html">app builder</a> using <code>.init_resource</code>,
instead of <code>.add_event</code>.</p>
<p>(<code>.add_event</code> is actually just a convenience method that
initializes the resource and adds Bevy's built-in system
(<a href="patterns/./generic-systems.html">generic</a> over your event type) for the default
cleanup strategy)</p>
<p>You must then clear the events at your discretion. If you don't do this often
enough, your events might pile up and waste memory.</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::Events;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // add the `Events&lt;T&gt;` resource manually
        // these events will not have automatic cleanup
        .init_resource::&lt;Events&lt;MySpecialEvent&gt;&gt;()

        // this is a regular event type with automatic cleanup
        .add_event::&lt;MyRegularEvent&gt;()

        // add the cleanup systems
        .add_system(my_event_manager)
        .run();
}

fn my_event_manager(
    mut events: ResMut&lt;Events&lt;MySpecialEvent&gt;&gt;,
) {
    // TODO: implement your custom logic
    // for deciding when to clear the events

    // clear all events like this:
    events.clear();

    // or with double-buffering
    // (this is what Bevy's default strategy does)
    events.update();

    // or drain them, if you want to iterate,
    // to access the values:
    for event in events.drain() {
        // TODO do something with each event
    }
}
</code></pre>
<p><strong>Hint</strong>: <a href="patterns/./generic-systems.html">generic systems</a> could be very useful for
this. You could implement your custom event management strategy as a system
generic over the event type, and then add that system to your App as many
times as you need, for each event type where you want to use your custom
behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-cookbook"><a class="header" href="#bevy-cookbook">Bevy Cookbook</a></h1>
<p>This chapter shows you how to do various practical things using Bevy.</p>
<p>Indended as a supplement to Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official
examples</a>.</p>
<p>The examples are written to only focus on the relevant information for the
task at hand.</p>
<p>Only the relevant parts of the code are shown. Full compilable example files
are available and linked on each page.</p>
<p>It is assumed that you are already familiar with
<a href="cookbook/../programming/_index.html">Bevy Programming</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quitting-the-app"><a class="header" href="#quitting-the-app">Quitting the App</a></h1>
<p><a href="cookbook/../code/examples/quit.rs">Click here for the full example code.</a></p>
<hr />
<p>To cleanly shut down bevy, send an <code>AppExit</code> event from any system:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::AppExit;

fn exit_system(mut exit: EventWriter&lt;AppExit&gt;) {
    exit.send(AppExit);
}
</code></pre>
<p>For prototyping, bevy provides a system you can add, to exit on pressing
the <code>Esc</code> key:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(bevy::input::system::exit_on_esc_system)
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changing-the-background-color"><a class="header" href="#changing-the-background-color">Changing the Background Color</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/latest/examples/window/clear_color.rs"><code>clear_color</code></a>.</p>
<hr />
<p><a href="cookbook/../code/examples/clear-color.rs">Click here for the full example code.</a></p>
<hr />
<p>Use the <code>ClearColor</code> resource to choose the background color.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .insert_resource(ClearColor(Color::rgb(0.4, 0.4, 0.4)))
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="show-framerate-in-console"><a class="header" href="#show-framerate-in-console">Show Framerate in Console</a></h1>
<p><a href="cookbook/../code/examples/print-framerate.rs">Click here for the full example code.</a></p>
<hr />
<p>You can use bevy's builtin diagnostics system to print framerate (FPS)
to the console, for monitoring performance.</p>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin};

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugin(LogDiagnosticsPlugin::default())
        .add_plugin(FrameTimeDiagnosticsPlugin::default())
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grabbing-the-mouse"><a class="header" href="#grabbing-the-mouse">Grabbing the Mouse</a></h1>
<p><a href="cookbook/../code/examples/mouse-grab.rs">Click here for the full example code.</a></p>
<hr />
<p>You can lock/release the mouse cursor using bevy's <a href="https://github.com/bevyengine/bevy/blob/latest/examples/window/window_settings.rs">window settings
API</a>.</p>
<p>Here is an example that locks and hides the cursor in the primary window on
mouse click and releases it when pressing <code>Esc</code>:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_grab_system(
    mut windows: ResMut&lt;Windows&gt;,
    btn: Res&lt;Input&lt;MouseButton&gt;&gt;,
    key: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    let window = windows.get_primary_mut().unwrap();

    if btn.just_pressed(MouseButton::Left) {
        window.set_cursor_lock_mode(true);
        window.set_cursor_visibility(false);
    }

    if key.just_pressed(KeyCode::Escape) {
        window.set_cursor_lock_mode(false);
        window.set_cursor_visibility(true);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-the-window-icon"><a class="header" href="#setting-the-window-icon">Setting the Window Icon</a></h1>
<p><a href="cookbook/../code/examples/window-icon.rs">Click here for the full example code.</a></p>
<hr />
<p>You might want to set a custom Window Icon. On Windows and Linux, this is
the icon image shown in the window title bar (if any) and task bar (if any).</p>
<p>Unfortunately, Bevy does not yet provide an easy and ergonomic built-in way
to do this. However, it can be done via the <code>winit</code> APIs.</p>
<p>The way shown here is quite hacky. To save on code complexity, instead of
using Bevy's asset system to load the image in the background, we bypass
the assets system and directly load the file using the <code>image</code> library.</p>
<p>There is some WIP on adding a proper API for this to Bevy; see
<a href="https://github.com/bevyengine/bevy/pull/2268">PR #2268</a> and
<a href="https://github.com/bevyengine/bevy/issues/1031">Issue #1031</a>.</p>
<p>This example shows how to set the icon for the primary/main window, from
a Bevy startup system.</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::WindowId;
use bevy::winit::WinitWindows;
use winit::window::Icon;

fn set_window_icon(
    windows: Res&lt;WinitWindows&gt;,
) {
    let primary = windows.get_window(WindowId::primary()).unwrap();

    // here we use the `image` crate to load our icon data from a png file
    // this is not a very bevy-native solution, but it will do
    let (icon_rgba, icon_width, icon_height) = {
        let image = image::open(&quot;my_icon.png&quot;)
            .expect(&quot;Failed to open icon path&quot;)
            .into_rgba8();
        let (width, height) = image.dimensions();
        let rgba = image.into_raw();
        (rgba, width, height)
    };

    let icon = Icon::from_rgba(icon_rgba, icon_width, icon_height).unwrap();

    primary.set_window_icon(Some(icon));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(set_window_icon)
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="track-assets-loading"><a class="header" href="#track-assets-loading">Track Assets Loading</a></h1>
<p><a href="cookbook/../code/examples/assets-ready.rs">Click here for the full example code.</a></p>
<hr />
<p>You might want to use a 3rd-party library for this. See <a href="cookbook/../setup/unofficial-plugins.html#code-helpers">my recommendations
for helper crates</a> that can do
this for you. Otherwise, this page shows you how to roll your own.</p>
<hr />
<p>You might want to know when your various assets have all finished loading, and
take some action, such as exiting your loading screen and starting gameplay.</p>
<p>To do this, we can convert our various handles into <code>HandleUntyped</code>s, so we can
add them all into a single collection.</p>
<p>We can then ask the <code>AssetServer</code> about the loading state of the collection.</p>
<pre><code class="language-rust no_run noplayground">struct AssetsLoading(Vec&lt;HandleUntyped&gt;);

fn setup(server: Res&lt;AssetServer&gt;, mut loading: ResMut&lt;AssetsLoading&gt;) {
    // we can have different asset types
    let font: Handle&lt;Font&gt; = server.load(&quot;my_font.ttf&quot;);
    let menu_bg: Handle&lt;Image&gt; = server.load(&quot;menu.png&quot;);
    let scene: Handle&lt;Scene&gt; = server.load(&quot;level01.gltf#Scene0&quot;);

    // add them all to our collection for tracking
    loading.0.push(font.clone_untyped());
    loading.0.push(menu_bg.clone_untyped());
    loading.0.push(scene.clone_untyped());
}

fn check_assets_ready(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
    loading: Res&lt;AssetsLoading&gt;
) {
    use bevy::asset::LoadState;

    match server.get_group_load_state(loading.0.iter().map(|h| h.id)) {
        LoadState::Failed =&gt; {
            // one of our assets had an error
        }
        LoadState::Loaded =&gt; {
            // all assets are now ready

            // this might be a good place to transition into your in-game state

            // remove the resource to drop the tracking handles
            commands.remove_resource::&lt;AssetsLoading&gt;();
            // (note: if you don't have any other handles to the assets
            // elsewhere, they will get unloaded after this)
        }
        _ =&gt; {
            // NotLoaded/Loading: not fully ready yet
        }
    }
}
</code></pre>
<p>It is also possible to query the load state of a single asset, by passing an
individual handle to <code>AssetServer.get_load_state()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convert-cursor-to-world-coordinates"><a class="header" href="#convert-cursor-to-world-coordinates">Convert cursor to world coordinates</a></h1>
<p><a href="cookbook/../code/examples/cursor2world.rs">Click here for the full example code.</a></p>
<hr />
<p>Bevy does not yet provide built-in functions to help with finding out what
the cursor is pointing at.</p>
<h2 id="3d-games"><a class="header" href="#3d-games">3D games</a></h2>
<p>There is a good (unofficial) plugin:
<a href="https://github.com/aevyrie/bevy_mod_picking"><code>bevy_mod_picking</code></a>.</p>
<h2 id="2d-games"><a class="header" href="#2d-games">2D games</a></h2>
<p>Simple hacky solution, for a game using the default Bevy 2d orthographic camera:</p>
<pre><code class="language-rust no_run noplayground">/// Used to help identify our main camera
#[derive(Component)]
struct MainCamera;

fn setup(mut commands: Commands) {
    commands.spawn()
        .insert_bundle(OrthographicCameraBundle::new_2d())
        .insert(MainCamera);
}

fn my_cursor_system(
    // need to get window dimensions
    wnds: Res&lt;Windows&gt;,
    // query to get camera transform
    q_camera: Query&lt;&amp;Transform, With&lt;MainCamera&gt;&gt;
) {
    // get the primary window
    let wnd = wnds.get_primary().unwrap();

    // check if the cursor is in the primary window
    if let Some(pos) = wnd.cursor_position() {
        // get the size of the window
        let size = Vec2::new(wnd.width() as f32, wnd.height() as f32);

        // the default orthographic projection is in pixels from the center;
        // just undo the translation
        let p = pos - size / 2.0;

        // assuming there is exactly one main camera entity, so this is OK
        let camera_transform = q_camera.single();

        // apply the camera transform
        let pos_wld = camera_transform.compute_matrix() * p.extend(0.0).extend(1.0);
        eprintln!(&quot;World coords: {}/{}&quot;, pos_wld.x, pos_wld.y);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-camera-projection"><a class="header" href="#custom-camera-projection">Custom Camera Projection</a></h1>
<p><a href="cookbook/../code/examples/custom-projection.rs">Click here for the full example code.</a></p>
<hr />
<p>Camera with a custom projection (not using one of Bevy's standard perspective
or orthographic projections).</p>
<p>You could also use this to change the coordinate system, if you
insist on using something other than <a href="cookbook/../features/transforms.html">Bevy's default coordinate
system</a>, for whatever reason.</p>
<p>Here we implement a simple orthographic projection that maps <code>-1.0</code> to <code>1.0</code>
to the vertical axis of the window, and respects the window's aspect ratio
for the horizontal axis:</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::{Camera, CameraProjection, DepthCalculation, CameraPlugin};
use bevy::render::view::VisibleEntities;

#[derive(Component)]
struct SimpleOrthoProjection {
    far: f32,
    aspect: f32,
}

impl CameraProjection for SimpleOrthoProjection {
    fn get_projection_matrix(&amp;self) -&gt; Mat4 {
        Mat4::orthographic_rh(
            -self.aspect, self.aspect, -1.0, 1.0, 0.0, self.far
        )
    }

    // what to do on window resize
    fn update(&amp;mut self, width: f32, height: f32) {
        self.aspect = width / height;
    }

    fn depth_calculation(&amp;self) -&gt; DepthCalculation {
        // for 2D (camera doesn't rotate)
        //DepthCalculation::ZDifference

        // otherwise
        DepthCalculation::Distance
    }

    fn far(&amp;self) -&gt; f32 {
        self.far
    }
}

impl Default for SimpleOrthoProjection {
    fn default() -&gt; Self {
        Self { far: 1000.0, aspect: 1.0 }
    }
}

fn setup(mut commands: Commands) {
    // same components as bevy's Camera2dBundle,
    // but with our custom projection

    let projection = SimpleOrthoProjection::default();

    // Need to set the camera name to one of the bevy-internal magic constants,
    // depending on which camera we are implementing (2D, 3D, or UI).
    // Bevy uses this name to find the camera and configure the rendering.
    // Since this example is a 2d camera:

    let cam_name = CameraPlugin::CAMERA_2D;

    let mut camera = Camera::default();
    camera.name = Some(cam_name.to_string());

    commands.spawn_bundle((
        // position the camera like bevy would do by default for 2D:
        Transform::from_translation(Vec3::new(0.0, 0.0, projection.far - 0.1)),
        GlobalTransform::default(),
        VisibleEntities::default(),
        camera,
        projection,
    ));
}

fn main() {
    // need to add a bevy-internal camera system to update
    // the projection on window resizing

    use bevy::render::camera::camera_system;

    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup)
        .add_system_to_stage(
            CoreStage::PostUpdate,
            camera_system::&lt;SimpleOrthoProjection&gt;,
        )
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pan--orbit-camera"><a class="header" href="#pan--orbit-camera">Pan + Orbit Camera</a></h1>
<p><a href="cookbook/../code/examples/pan-orbit-camera.rs">Click here for the full example code.</a></p>
<hr />
<p>This code is a community contribution.</p>
<p>Current version developed by <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/pull/1"><strong>@mirenbharta</strong></a>.
Initial work by <a href="https://github.com/inodentry/bevy-cookbook/pull/2"><strong>@skairunner</strong></a>.</p>
<hr />
<p>This is a camera controller similar to the ones in 3D editors like Blender.</p>
<p>Use the right mouse button to rotate, middle button to pan, scroll wheel to
move inwards/outwards.</p>
<pre><code class="language-rust no_run noplayground">/// Tags an entity as capable of panning and orbiting.
#[derive(Component)]
struct PanOrbitCamera {
    /// The &quot;focus point&quot; to orbit around. It is automatically updated when panning the camera
    pub focus: Vec3,
    pub radius: f32,
    pub upside_down: bool,
}

impl Default for PanOrbitCamera {
    fn default() -&gt; Self {
        PanOrbitCamera {
            focus: Vec3::ZERO,
            radius: 5.0,
            upside_down: false,
        }
    }
}

/// Pan the camera with middle mouse click, zoom with scroll wheel, orbit with right mouse click.
fn pan_orbit_camera(
    windows: Res&lt;Windows&gt;,
    mut ev_motion: EventReader&lt;MouseMotion&gt;,
    mut ev_scroll: EventReader&lt;MouseWheel&gt;,
    input_mouse: Res&lt;Input&lt;MouseButton&gt;&gt;,
    mut query: Query&lt;(&amp;mut PanOrbitCamera, &amp;mut Transform, &amp;PerspectiveProjection)&gt;,
) {
    // change input mapping for orbit and panning here
    let orbit_button = MouseButton::Right;
    let pan_button = MouseButton::Middle;

    let mut pan = Vec2::ZERO;
    let mut rotation_move = Vec2::ZERO;
    let mut scroll = 0.0;
    let mut orbit_button_changed = false;

    if input_mouse.pressed(orbit_button) {
        for ev in ev_motion.iter() {
            rotation_move += ev.delta;
        }
    } else if input_mouse.pressed(pan_button) {
        // Pan only if we're not rotating at the moment
        for ev in ev_motion.iter() {
            pan += ev.delta;
        }
    }
    for ev in ev_scroll.iter() {
        scroll += ev.y;
    }
    if input_mouse.just_released(orbit_button) || input_mouse.just_pressed(orbit_button) {
        orbit_button_changed = true;
    }

    for (mut pan_orbit, mut transform, projection) in query.iter_mut() {
        if orbit_button_changed {
            // only check for upside down when orbiting started or ended this frame
            // if the camera is &quot;upside&quot; down, panning horizontally would be inverted, so invert the input to make it correct
            let up = transform.rotation * Vec3::Y;
            pan_orbit.upside_down = up.y &lt;= 0.0;
        }

        let mut any = false;
        if rotation_move.length_squared() &gt; 0.0 {
            any = true;
            let window = get_primary_window_size(&amp;windows);
            let delta_x = {
                let delta = rotation_move.x / window.x * std::f32::consts::PI * 2.0;
                if pan_orbit.upside_down { -delta } else { delta }
            };
            let delta_y = rotation_move.y / window.y * std::f32::consts::PI;
            let yaw = Quat::from_rotation_y(-delta_x);
            let pitch = Quat::from_rotation_x(-delta_y);
            transform.rotation = yaw * transform.rotation; // rotate around global y axis
            transform.rotation = transform.rotation * pitch; // rotate around local x axis
        } else if pan.length_squared() &gt; 0.0 {
            any = true;
            // make panning distance independent of resolution and FOV,
            let window = get_primary_window_size(&amp;windows);
            pan *= Vec2::new(projection.fov * projection.aspect_ratio, projection.fov) / window;
            // translate by local axes
            let right = transform.rotation * Vec3::X * -pan.x;
            let up = transform.rotation * Vec3::Y * pan.y;
            // make panning proportional to distance away from focus point
            let translation = (right + up) * pan_orbit.radius;
            pan_orbit.focus += translation;
        } else if scroll.abs() &gt; 0.0 {
            any = true;
            pan_orbit.radius -= scroll * pan_orbit.radius * 0.2;
            // dont allow zoom to reach zero or you get stuck
            pan_orbit.radius = f32::max(pan_orbit.radius, 0.05);
        }

        if any {
            // emulating parent/child to make the yaw/y-axis rotation behave like a turntable
            // parent = x and y rotation
            // child = z-offset
            let rot_matrix = Mat3::from_quat(transform.rotation);
            transform.translation = pan_orbit.focus + rot_matrix.mul_vec3(Vec3::new(0.0, 0.0, pan_orbit.radius));
        }
    }
}

fn get_primary_window_size(windows: &amp;Res&lt;Windows&gt;) -&gt; Vec2 {
    let window = windows.get_primary().unwrap();
    let window = Vec2::new(window.width() as f32, window.height() as f32);
    window
}

/// Spawn a camera like this
fn spawn_camera(mut commands: Commands) {
    let translation = Vec3::new(-2.0, 2.5, 5.0);
    let radius = translation.length();

    commands.spawn_bundle(PerspectiveCameraBundle {
        transform: Transform::from_translation(translation)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..Default::default()
    }).insert(PanOrbitCamera {
        radius,
        ..Default::default()
    });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-all-resource-types"><a class="header" href="#list-all-resource-types">List All Resource Types</a></h1>
<p><a href="cookbook/../code/examples/print-resources.rs">Click here for the full example code.</a></p>
<hr />
<p>We can access the metadata stored inside Bevy ECS to learn about the types
of things currently stored.</p>
<p>This example shows how to print a list of all types that have been added as
<a href="cookbook/../programming/res.html">resources</a>.</p>
<pre><code class="language-rust no_run noplayground">fn print_resources(archetypes: &amp;Archetypes, components: &amp;Components) {
    let mut r: Vec&lt;String&gt; = archetypes
        .resource()
        .components()
        .map(|id| components.get_info(id).unwrap())
        // get_short_name removes the path information
        // i.e. `bevy_audio::audio::Audio` -&gt; `Audio`
        // if you want to see the path info replace
        // `TypeRegistration::get_short_name` with `String::from`
        .map(|info| TypeRegistration::get_short_name(info.name()))
        .collect();

    // sort list alphebetically
    r.sort();
    r.iter().for_each(|name| println!(&quot;{}&quot;, name));
}
</code></pre>
<p>Note that this does <em>not</em> give you a comprehensive list of every Bevy-provided
type that is useful as a resource. It lists the types of all the resources
<em>currently added</em> to the app (by all registered plugins, your own, etc.).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-on-different-platforms"><a class="header" href="#bevy-on-different-platforms">Bevy on Different Platforms</a></h1>
<p>This chapter is a collection of platform-specific information, about using
Bevy with different operating systems or environments.</p>
<p>If you know of anything that would be nice to add, please file an issue on
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a> or ping me
on Discord (<code>@Ida Iyes#0981</code>).</p>
<hr />
<p>Bevy trivially works out-of-the-box on the major desktop operating systems:
Linux, macOS, Windows. No special configuration is required.</p>
<p>See the following pages for specific tips/advice when developing for the
desktop platforms:</p>
<ul>
<li><a href="platforms/./linux.html">Linux</a></li>
<li><a href="platforms/./macos.html">macOS</a></li>
<li><a href="platforms/./windows.html">Windows</a></li>
</ul>
<p>Bevy aims to also make it easy to target other platforms, such as web browsers
(via WebAssembly), mobile (Android and iOS), and game consoles. Your Bevy
code can be the same for all platforms, with differences only in the build
process and environment setup.</p>
<p>However, that vision is not fully met yet. Currently, support for non-desktop
platforms is limited, and requires more complex configuration:</p>
<ul>
<li><a href="platforms/./wasm.html">Web Browsers</a>: It is possible to make a web game, with some caveats.</li>
<li>Mobile: support is minimal and broken. It will build, but may or may not run.
Expect to immediately encounter major issues.</li>
<li>Game consoles: support is still completely non-existent yet.</li>
</ul>
<p>If you are interested in these other platforms and you'd like to help improve
Bevy's cross-platform support, your contributions would be greatly welcomed!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-desktop"><a class="header" href="#linux-desktop">Linux Desktop</a></h1>
<p>If you have any additional Linux-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Desktop Linux is one of the best-supported platforms by Bevy.</p>
<h2 id="gpu-drivers"><a class="header" href="#gpu-drivers">GPU Drivers</a></h2>
<p>Support for the Vulkan graphics API is required to run Bevy apps. You (and your
users) must ensure that you have compatible hardware and drivers installed.</p>
<p>On most modern distributions and computers, this should be no problem.</p>
<p>If Bevy apps refuse to run and print an error to the console about not being
able to find a compatible GPU, the problem is most likely with the Vulkan
components of your graphics driver not being installed correctly. You may
need to install some extra packages or reinstall your graphics drivers. Check
with your Linux distribution for what to do.</p>
<h2 id="x11-and-wayland"><a class="header" href="#x11-and-wayland">X11 and Wayland</a></h2>
<p>As of the year 2021, the Linux desktop ecosystem is fragmented between
the legacy X11 stack and the modern Wayland stack. Many distributions are
switching to Wayland-based desktop environments by default.</p>
<p>Bevy supports both, but only X11 support is enabled by default. If you are
running a Wayland-based desktop, this means your Bevy app will run in the
XWayland compatibility layer.</p>
<p>To enable native Wayland support for Bevy, enable the <code>wayland</code> cargo feature:</p>
<pre><code class="language-toml">[dependencies]
bevy = { version = &quot;0.6&quot;, features = [&quot;wayland&quot;] }
</code></pre>
<p>Now your app will be built with support for both X11 and Wayland.</p>
<p>If you want to remove X11 support for whatever reason, disable the <code>x11</code>
cargo default feature.</p>
<p>You can override which display protocol to use at runtime, using an
environment variable:</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=x11
</code></pre>
<p>(to run using X11/XWayland on a Wayland desktop)</p>
<p>or</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=wayland
</code></pre>
<p>(to require the use of Wayland)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos-desktop"><a class="header" href="#macos-desktop">macOS Desktop</a></h1>
<p>If you have any additional macOS-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>(this page is currently empty; please help!)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-desktop"><a class="header" href="#windows-desktop">Windows Desktop</a></h1>
<p>If you have any additional Windows-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Windows is one of the best-supported platforms by Bevy.</p>
<p>Both the MSVC and the GNU compiler toolchains should work.</p>
<h2 id="distributing-your-app"><a class="header" href="#distributing-your-app">Distributing Your App</a></h2>
<p>The EXE built with <code>cargo build</code> can work standalone without any extra files or DLLs.</p>
<p>Your <code>assets</code> folder needs be distributed alongside it. Bevy will search for it in
the same directory as the EXE on the user's computer.</p>
<p>The easiest way to give your game to other people to play is to put them
together in a ZIP file. If you use some other method of installation,
install the <code>assets</code> folder and the EXE to the same path.</p>
<h2 id="creating-an-icon-for-your-app"><a class="header" href="#creating-an-icon-for-your-app">Creating an icon for your app</a></h2>
<p>There are two places where you might want to put your application icon:</p>
<ul>
<li>The EXE file (how it looks in the file explorer)</li>
<li>The window at runtime (how it looks in the taskbar and the window title bar)</li>
</ul>
<h3 id="setting-the-exe-icon"><a class="header" href="#setting-the-exe-icon">Setting the EXE icon</a></h3>
<p>(adapted from <a href="https://github.com/NiklasEi/bevy_game_template">here</a>)</p>
<p>The EXE icon can be set using a cargo build script.</p>
<p>Add a build dependency of <code>embed_resources</code> to your <code>Cargo.toml</code> allow embedding assets into your compiled executables</p>
<pre><code class="language-toml">[build-dependencies]
embed-resource = &quot;1.6.3&quot;
</code></pre>
<p>Create a <code>build.rs</code> file in your project folder:</p>
<pre><pre class="playground"><code class="language-rust">extern crate embed_resource;

fn main() {
    let target = std::env::var(&quot;TARGET&quot;).unwrap();
    if target.contains(&quot;windows&quot;) {
        embed_resource::compile(&quot;icon.rc&quot;);
    }
}
</code></pre></pre>
<p>Create a <code>icon.rc</code> file in your project folder:</p>
<pre><code>app_icon ICON &quot;icon.ico&quot;
</code></pre>
<p>Create your icon as <code>icon.ico</code> in your project folder.</p>
<h3 id="setting-the-window-icon-1"><a class="header" href="#setting-the-window-icon-1">Setting the Window Icon</a></h3>
<p>See <a href="platforms/../cookbook/window-icon.html">Bevy Cookbook: Setting the Window Icon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browser-webassembly"><a class="header" href="#browser-webassembly">Browser (WebAssembly)</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>You can make web browser games using Bevy. This chapter will help you with
the things you need to know to do it. This page gives an overview of Bevy's
Web support.</p>
<p>Your Bevy app will be compiled for WebAssembly (WASM), which allows it to
be embedded in a web page and run inside the browser.</p>
<p>Performance will be limited, as WebAssembly is slower than native code and
does not currently support multithreading.</p>
<p>Not all 3rd-party plugins are compatible. If you need extra unofficial plugins,
you will have to check if they are compatible with WASM.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The same Bevy project, without any special code modifications, can be built
for either web or desktop/native.</p>
<p>However, you will need a &quot;website&quot; with some HTML and JavaScript to load and
run your game. For development and testing, this could be just a minimal shim.
It can be easily autogenerated.</p>
<p>To deploy, you will need a server to host your website for other
people to access. You could use GitHub's hosting service: <a href="platforms/./wasm/gh-pages.html">GitHub
Pages</a>.</p>
<h2 id="additional-caveats"><a class="header" href="#additional-caveats">Additional Caveats</a></h2>
<p>When users load your site to play your game, their browser will need to
download the files. <a href="platforms/./wasm/size-opt.html">Optimizing for size</a> is important,
so that your game can load fast and not waste data bandwidth.</p>
<p>Some minor extra configuration is needed to be able to:</p>
<ul>
<li><a href="platforms/./wasm/panic-console.html">See Rust panic messages</a></li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>First, add WASM support to your Rust installation. Using Rustup:</p>
<pre><code class="language-sh">rustup target install wasm32-unknown-unknown
</code></pre>
<p>Now, to run your Bevy project in the browser.</p>
<h3 id="wasm-server-runner"><a class="header" href="#wasm-server-runner"><code>wasm-server-runner</code></a></h3>
<p>The easiest and most automatic way to get started is the
<a href="https://github.com/jakobhellermann/wasm-server-runner"><code>wasm-server-runner</code></a> tool.</p>
<p>Install it:</p>
<pre><code class="language-sh">cargo install wasm-server-runner
</code></pre>
<p>Set up <code>cargo</code> to use it, in <code>.cargo/config.toml</code> (in your project folder,
or globally in your user home folder):</p>
<pre><code class="language-toml">[target.wasm32-unknown-unknown]
runner = &quot;wasm-server-runner&quot;
</code></pre>
<p>Now you can just run your game with:</p>
<pre><code class="language-sh">cargo run --target wasm32-unknown-unknown
</code></pre>
<p>It will automatically run a minimal local webserver and open your game in your browser.</p>
<h3 id="wasm-bindgen"><a class="header" href="#wasm-bindgen"><code>wasm-bindgen</code></a></h3>
<p><code>wasm-bindgen</code> is the tool to generate all the files needed to put the game on your website.</p>
<p>Run:</p>
<pre><code class="language-sh">cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --out-dir ./out/ --target web ./target/
</code></pre>
<p><code>./out/</code> is the directory where it will place the output files.</p>
<p>You need to put these on your web server.</p>
<h3 id="higher-level-tools"><a class="header" href="#higher-level-tools">Higher-level Tools</a></h3>
<p>Here are some higher-level alternatives. These tools can do more for you
and automate more of your workflow, but are more opinionated in how they work.</p>
<ul>
<li><a href="https://trunkrs.dev/">Trunk</a></li>
<li><a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-messages"><a class="header" href="#panic-messages">Panic Messages</a></h1>
<p>Unless we do something about it, you will not be able to see Rust panic
messages when running in a web browser. This means that, if your game crashes,
you will not know why.</p>
<p>To fix this, we can set up a panic hook that will cause
the messages to appear in the browser console, using the
<a href="https://github.com/rustwasm/console_error_panic_hook">console_error_panic_hook</a>
crate.</p>
<p>Add the crate to your dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
console_error_panic_hook = &quot;0.1&quot;
</code></pre>
<p>At the start of your main function, before doing anything else, add this:</p>
<pre><code class="language-rust no_run noplayground">    // When building for WASM, print panics to the browser console
    #[cfg(target_arch = &quot;wasm32&quot;)]
    console_error_panic_hook::set_once();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimize-for-size"><a class="header" href="#optimize-for-size">Optimize for Size</a></h1>
<p>When serving a WASM binary, the smaller it is, the faster the browser can
download it. Faster downloads means faster page load times and less data
bandwidth use, and that means happier users.</p>
<p>This page gives some suggestions for how to make your WASM files smaller.</p>
<p><em>Do not prematurely optimize!</em> You probably don't need small WASM files during
development, and many of these techniques can get in the way of your workflow!
They may come at the cost of longer compile times or less debuggability.</p>
<p>Depending on the nature of your application, your mileage may vary, and
performing measurements of binary size and execution speed is recommended.</p>
<p><a href="https://github.com/rustwasm/twiggy">Twiggy</a> is a code size profiler for
WASM binaries, which you can use to make measurements.</p>
<p>For additional information and more techniques,
refer to the Code Size chapter in the <a href="https://rustwasm.github.io/docs/book/reference/code-size.html">Rust WASM
book</a>.</p>
<h2 id="compiling-for-size-instead-of-speed"><a class="header" href="#compiling-for-size-instead-of-speed">Compiling for size instead of speed</a></h2>
<p>You can change the optimization profile of the compiler, to tell it to
prioritize small output size, rather than performance.</p>
<p>(although in some rare cases, optimizing for size can actually improve speed)</p>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>These are two different profiles for size optimization. Usually, <code>z</code> produces
smaller files than <code>s</code>, but sometimes it can be the opposite. Measure to
confirm which one works better for you.</p>
<h2 id="link-time-optimization-lto"><a class="header" href="#link-time-optimization-lto">Link-Time Optimization (LTO)</a></h2>
<p>In <code>Cargo.toml</code>, add the following:</p>
<pre><code class="language-toml">[profile.release]
lto = &quot;thin&quot;
</code></pre>
<p>LTO tells the compiler to optimize all code together, considering all
crates as if they were one. It may be able to inline and prune functions
much more aggressively.</p>
<p>This typically results in smaller size <em>and</em> better performance, but do
measure to confirm. Sometimes, the size can actually be larger.</p>
<p>The downside here is that compilation will take much longer. Do this only
for release builds you publish for other users.</p>
<h2 id="use-the-wasm-opt-tool"><a class="header" href="#use-the-wasm-opt-tool">Use the <code>wasm-opt</code> tool</a></h2>
<p>The <a href="https://github.com/WebAssembly/binaryen">binaryen</a> toolkit is a set of
extra tools for working with WASM. One of them is <code>wasm-opt</code>. It goes much
further than what the compiler can do, and can be used to further optimize
for either speed or size:</p>
<pre><code class="language-shell"># Optimize for size (s profile).
wasm-opt -Os -o output.wasm input.wasm

# Optimize for size (z profile).
wasm-opt -Oz -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<h2 id="use-the-wee-alloc-memory-allocator"><a class="header" href="#use-the-wee-alloc-memory-allocator">Use the <code>wee-alloc</code> memory allocator</a></h2>
<p>You can replace Rust's default memory allocator with
<a href="https://github.com/rustwasm/wee_alloc">wee-alloc</a>, which is slower, but is
less than a single kilobyte in size.</p>
<p>This may result in a significant performance hit. If your game runs fast
enough with it, the smaller download size may be more important.</p>
<p>In <code>Cargo.toml</code>, add the following:</p>
<pre><code class="language-toml">[dependencies]
wee_alloc = &quot;0.4&quot;
</code></pre>
<p>And now add the following to <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = &quot;wasm32&quot;)]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;
<span class="boring">}
</span></code></pre></pre>
<hr />
<p>Do you know of more WASM size-optimization techniques? Post about them in the
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue Tracker</a>
so that they can be added to this page!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hosting-on-github-pages"><a class="header" href="#hosting-on-github-pages">Hosting on GitHub Pages</a></h1>
<p>GitHub Pages is a hosting service that allows you to publish your website
on GitHub's servers.</p>
<p>For more details, visit the official <a href="https://docs.github.com/en/pages">GitHub Pages
documentation</a>.</p>
<p>Deploying a website (like your WASM game) to GitHub pages is done by
putting the files in a special branch in a GitHub repository. You could
create a separate repository for this, but you could also do it from the
same repository as your source code.</p>
<p>You will need the final website files for deployment.</p>
<hr />
<p>Create an empty branch in your git repository:</p>
<pre><code class="language-shell">git checkout --orphan web
git reset --hard
</code></pre>
<p>You should now be in an empty working directory.</p>
<p>Put all files necessary for hosting, including your HTML, WASM, JavaScript,
and <code>assets</code> files, and commit them into git:</p>
<pre><code class="language-shell">git add *
git commit
</code></pre>
<p>(or better, manually list your files in the above command, in place of the <code>*</code> wildcard)</p>
<p>Push your new branch to GitHub:</p>
<pre><code class="language-shell">git push -u origin web --force
</code></pre>
<p>In the GitHub Web UI, go to the repository settings, go to the &quot;GitHub Pages&quot;
section, then under &quot;Source&quot; pick the branch &quot;web&quot; and the <code>/</code> (root) folder.
Then click &quot;Save&quot;.</p>
<p>Wait a little bit, and your site should become available at
<code>https://your-name.github.io/your-repo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Be civil. If you need a code of conduct, have a look at Bevy's.</p>
<p>If you have any suggestions for the book, such as ideas for new content, or
if you notice anything that is incorrect or misleading, please file issues in
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">the GitHub repository</a>!</p>
<h2 id="contributing-code"><a class="header" href="#contributing-code">Contributing Code</a></h2>
<p>If you simply want to contribute code examples to the book, feel free to
make a PR. I can take care of writing the book text / page that your code
will be displayed on.</p>
<h3 id="cookbook-examples"><a class="header" href="#cookbook-examples">Cookbook Examples</a></h3>
<p>The code for cookbook examples should be provided as a full, runnable,
example file, under <code>src/code/examples</code>. The book page will only show the
relevant parts of the code, without unnecessary boilerplate.</p>
<p>Always use <a href="https://rust-lang.github.io/mdBook/format/mdbook.html#including-portions-of-a-file">mdbook anchor syntax</a>,
not line numbers, to denote the parts of the code to be shown on the page.</p>
<h3 id="credits"><a class="header" href="#credits">Credits</a></h3>
<p>If you contribute a cookbook example, I will credit you in the book by your
github username with a link to the PR. Please let me know if you prefer not
to be credited, or if you would like to be credited in another way (but no
commercial self-promotion allowed).</p>
<h2 id="contributing-book-text"><a class="header" href="#contributing-book-text">Contributing Book Text</a></h2>
<p>I do not directly merge book text written by other people. This is because
I want the book to follow a consistent editorial style.</p>
<p>If you would like to write new content for the book, feel free to make a
PR with the content to be included, but note that it will likely not be
preserved exactly as you wrote it.</p>
<p>I will likely merge it into a temporary branch and then edit or rewrite it
as I see fit, for publishing into the book.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<p>To avoid complications with copyright and licensing, you agree to provide
any contributions you make to the project under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 No Attribution
License</a>.</p>
<p>Note that this allows your work to be relicensed without preserving your
copyright.</p>
<p>As described previously, the actual published content in the book will be my
own derivative work based on your contributions. I will license it consistently
with the rest of the book; see: <a href="./introduction.html#license">License</a>.</p>
<h2 id="bevy-version"><a class="header" href="#bevy-version">Bevy version</a></h2>
<p>Content written for the current Bevy release, is accepted for the <code>main</code>
branch of the book.</p>
<p>Content written for new developments in Bevy's main branch, is accepted for the
<code>next</code> branch of the book, in preparation for the next upcoming Bevy release.</p>
<h2 id="style-guidelines"><a class="header" href="#style-guidelines">Style Guidelines</a></h2>
<p>Aim for simplicity and minimalism. Do not include things irrelevant to
getting the point across.</p>
<p>&quot;Perfection is achieved not when there is nothing more to add, but when
there is nothing more to remove.&quot;</p>
<p>Don't forget to point out potential gotchas and other relevant practical
considerations.</p>
<p>Try to use the most common/standard terminology and keywords, to make things
easy to find. Don't come up with new/extra terminology of your own.</p>
<p>Avoid repeating information found elsewhere in the book, prefer linking to
it instead.</p>
<h3 id="code-style"><a class="header" href="#code-style">Code Style</a></h3>
<p>Code snippets in the Cheatsheet should be as concise as possible. Feel free
to use meaningless placeholder names; don't try to make them &quot;realistic&quot;.</p>
<p>Code in other sections, however, should aim to &quot;look realistic&quot;, as to
illustrate what the feature might actually be used for.</p>
<p>Avoid long lines of code, to keep it readable on small screens.</p>
<p>Use reasonable formatting that does not deviate much from the common
conventions used by the Rust language community. I don't enforce it strictly;
there is no need to use <code>rustfmt</code>. If deviating from those standards allows
for the code to be presented better in the context of the book, then doing
so is preferable.</p>
<h3 id="text-style"><a class="header" href="#text-style">Text Style</a></h3>
<p>Make it easy to read.</p>
<ul>
<li>Be brief. Try to cover all important information without verbose explanations.</li>
<li>Prefer simple English with short sentences.</li>
<li>Avoid information overload:
<ul>
<li>Split things into short paragraphs.</li>
<li>Avoid introducing many (even if related) topics at the same time.</li>
<li>Cover advanced usage separately from the basics.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="nagbar.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
