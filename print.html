<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unofficial Bevy Cheat Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="cheatsheet/_index.html"><strong aria-hidden="true">1.</strong> Bevy Cheatsheet</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cheatsheet/release.html"><strong aria-hidden="true">1.1.</strong> for bevy 0.4</a></li><li class="chapter-item expanded "><a href="cheatsheet/master.html"><strong aria-hidden="true">1.2.</strong> for bevy git</a></li></ol></li><li class="chapter-item expanded "><a href="pitfalls.html"><strong aria-hidden="true">2.</strong> Common Pitfalls</a></li><li class="chapter-item expanded "><a href="basics/_index.html"><strong aria-hidden="true">3.</strong> Bevy Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/ec.html"><strong aria-hidden="true">3.1.</strong> Entities and Components</a></li><li class="chapter-item expanded "><a href="basics/res.html"><strong aria-hidden="true">3.2.</strong> Resources</a></li><li class="chapter-item expanded "><a href="basics/systems.html"><strong aria-hidden="true">3.3.</strong> Systems</a></li><li class="chapter-item expanded "><a href="basics/queries.html"><strong aria-hidden="true">3.4.</strong> Queries</a></li><li class="chapter-item expanded "><a href="basics/commands.html"><strong aria-hidden="true">3.5.</strong> Commands</a></li><li class="chapter-item expanded "><a href="basics/local.html"><strong aria-hidden="true">3.6.</strong> Local Resources</a></li><li class="chapter-item expanded "><a href="basics/events.html"><strong aria-hidden="true">3.7.</strong> Events</a></li><li class="chapter-item expanded "><a href="basics/app-builder.html"><strong aria-hidden="true">3.8.</strong> App Builder (main function)</a></li><li class="chapter-item expanded "><a href="basics/assets.html"><strong aria-hidden="true">3.9.</strong> Assets</a></li><li class="chapter-item expanded "><a href="basics/change-detection.html"><strong aria-hidden="true">3.10.</strong> Change Detection</a></li><li class="chapter-item expanded "><a href="basics/parent-child.html"><strong aria-hidden="true">3.11.</strong> Hierarchical Entities</a></li><li class="chapter-item expanded "><a href="basics/system-chaining.html"><strong aria-hidden="true">3.12.</strong> System Chaining</a></li><li class="chapter-item expanded "><a href="basics/stages.html"><strong aria-hidden="true">3.13.</strong> Stages</a></li><li class="chapter-item expanded "><a href="basics/states.html"><strong aria-hidden="true">3.14.</strong> States</a></li><li class="chapter-item expanded "><a href="basics/plugins.html"><strong aria-hidden="true">3.15.</strong> Plugins</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/_index.html"><strong aria-hidden="true">4.</strong> Advanced Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/generic-systems.html"><strong aria-hidden="true">4.1.</strong> Generic Systems</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook/_index.html"><strong aria-hidden="true">5.</strong> Bevy Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/input-handling.html"><strong aria-hidden="true">5.1.</strong> Input Handling</a></li><li class="chapter-item expanded "><a href="cookbook/quit.html"><strong aria-hidden="true">5.2.</strong> Quitting the App</a></li><li class="chapter-item expanded "><a href="cookbook/clear-color.html"><strong aria-hidden="true">5.3.</strong> Changing the Background Color</a></li><li class="chapter-item expanded "><a href="cookbook/print-framerate.html"><strong aria-hidden="true">5.4.</strong> Show Framerate in Console</a></li><li class="chapter-item expanded "><a href="cookbook/assets-ready.html"><strong aria-hidden="true">5.5.</strong> Track Assets Loading</a></li><li class="chapter-item expanded "><a href="cookbook/mouse-grab.html"><strong aria-hidden="true">5.6.</strong> Grabbing the Mouse</a></li><li class="chapter-item expanded "><a href="cookbook/cursor2world.html"><strong aria-hidden="true">5.7.</strong> Convert cursor to world coordinates</a></li><li class="chapter-item expanded "><a href="cookbook/custom-projection.html"><strong aria-hidden="true">5.8.</strong> Custom Camera Projection</a></li><li class="chapter-item expanded "><a href="cookbook/pan-orbit-camera.html"><strong aria-hidden="true">5.9.</strong> Pan+Orbit Camera</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Unofficial Bevy Cheat Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unofficial-bevy-cheat-book"><a class="header" href="#unofficial-bevy-cheat-book">Unofficial Bevy Cheat Book</a></h1>
<p>Concise reference to programming in the <a href="https://github.com/bevyengine/bevy">Bevy game engine</a>.</p>
<p>Covers useful syntax, features, programming patterns, and solutions (&quot;recipes&quot;) for common game development tasks.</p>
<p>Designed to be easy to read, straight to the point, using simple language to focus on the important information.</p>
<p>The book has several sections:</p>
<ul>
<li><a href="./cheatsheet/_index.html">Bevy Cheatsheet</a>: condensed one-page summary of common bevy syntax and features</li>
<li><a href="./pitfalls.html">Common Pitfalls</a>: common issues to watch out for, if you are new to Bevy</li>
<li><a href="./basics/_index.html">Bevy Basics</a>: overview of the basics of programming in Bevy</li>
<li>Advanced Patterns: good practices for using bevy effectively</li>
<li>Bevy Cookbook: examples covering common game development problems</li>
</ul>
<p>The book is not intended to be read in order. Jump to whatever is useful to you!</p>
<p><em><strong>Welcome! Hope this book serves you well!</strong></em></p>
<p>P.S: also check out the <a href="https://github.com/bevyengine/awesome-bevy">awesome-bevy</a> list,
for additional resources to help you on your bevy journey!</p>
<h2 id="maintenance"><a class="header" href="#maintenance">Maintenance</a></h2>
<p>This version of the book is for Bevy release 0.4.</p>
<p>The cheatsheet also has a version for bevy git. An attempt is made to keep it reasonably up-to-date.</p>
<h2 id="contributions-welcome"><a class="header" href="#contributions-welcome">Contributions Welcome!</a></h2>
<p>Development of the book happens on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<p>See the <a href="./contributing.html">Contributing</a> section for advice!</p>
<h1 id="bevy-cheatsheet"><a class="header" href="#bevy-cheatsheet">Bevy Cheatsheet</a></h1>
<p>One-page overview of common bevy syntax and features.</p>
<p>Concise listing of the syntax + important usage notes, no explanations.</p>
<p>Intended for people who are familiar with the core concepts.</p>
<p>If you are new to bevy or need a refresher, see
<a href="cheatsheet/../cheatsheet/_index.html">Bevy Basics</a>
for brief explanations of each feature.</p>
<h2 id="versions"><a class="header" href="#versions">Versions</a></h2>
<p><a href="cheatsheet/release.html">Click here for Bevy 0.4</a>.</p>
<p><a href="cheatsheet/master.html">Click here for Bevy git</a>.</p>
<h1 id="bevy-cheatsheet-for-bevy-04"><a class="header" href="#bevy-cheatsheet-for-bevy-04">Bevy Cheatsheet (for bevy 0.4)</a></h1>
<p>One-page overview of common bevy syntax and features.</p>
<p>Concise listing of the syntax + important usage notes, no explanations.</p>
<p>Intended for people who are familiar with the core concepts.</p>
<p>If you are new to bevy or need a refresher, see
<a href="cheatsheet/../cheatsheet/_index.html">Bevy Basics</a>
for brief explanations of each feature.</p>
<hr />
<p>Click on &quot;[explain]&quot; links to go to the relevant <a href="cheatsheet/../basics/_index.html">Bevy Basics</a> page!</p>
<hr />
<h2 id="systems"><a class="header" href="#systems">Systems</a></h2>
<p>[<a href="cheatsheet/../basics/systems.html">explain</a>]</p>
<h2 id="entities-and-components"><a class="header" href="#entities-and-components">Entities and Components</a></h2>
<p>[<a href="cheatsheet/../basics/ec.html">explain</a>]</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a component.</p>
<p>Type must be unique; only one instance per type per entity can exist. Use newtypes.</p>
<p>See <a href="cheatsheet/release.html#commands"><code>Commands</code></a> for how to add components to entities and spawn entities.</p>
<p>Component bundles:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Bundle)]
struct AbBundle {
    a: ComponentA,
    b: ComponentB,
}
</code></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>[<a href="cheatsheet/../basics/res.html">explain</a>]</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a resource.</p>
<p>Type must be unique; only one instance per type can exist. Use newtypes.</p>
<p>Access from system:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(a: Res&lt;MyResourceA&gt;, mut b: ResMut&lt;MyResourceB&gt;) {
    // do something with `a` and `b`
}
</code></pre>
<p>Add when <a href="cheatsheet/release.html#app-builder-main-function">building the app</a>:</p>
<pre><code class="language-rust no_run noplayground">    fn main() {
        App::build()
            // specific resource value
            .add_resource(MyResource::new())
            // auto-init using `Default` or `FromResources`
            .init_resource::&lt;MyAutoResource&gt;()
            .run();
    }
</code></pre>
<p>Add (or replace existing) using <a href="cheatsheet/release.html#commands"><code>Commands</code></a>:</p>
<pre><code class="language-rust no_run noplayground">    commands.insert_resource(MyData::default());
</code></pre>
<p>For complex resource initialization, implement <code>FromResources</code>:</p>
<pre><code class="language-rust no_run noplayground">impl FromResources for MyFancyResource {
    fn from_resources(resources: &amp;Resources) -&gt; Self {
        // you have full access to any other resources you need here,
        // you can even mutate them:
        let mut x = resources.get_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
</code></pre>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>[<a href="cheatsheet/../basics/queries.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn my_system(mut query: Query&lt;(Entity, &amp;ComponentA, &amp;mut ComponentB)&gt;) {
    // operate on all matching entities
    for (entity, a, mut b) in query.iter_mut() {
        // do something with `a` and `b`; `entity` is the Entity id
    }
}
</code></pre>
<p>To operate on a specific entity:</p>
<pre><code class="language-rust no_run noplayground">    if let Ok((a, mut b)) = query.get_mut(entity) {
        // do something with `a` and `b`
    } else {
        // entity does not match the query
    }
</code></pre>
<p>Add query filters:</p>
<pre><code class="language-rust no_run noplayground">fn with_filter(query: Query&lt;&amp;MyData, (Without&lt;ComponentA&gt;, Or&lt;(With&lt;Foo&gt;, With&lt;Bar&gt;)&gt;)&gt;) {
    // only get `data` for entities that match the filter criteria
    for data in query.iter() {
        // use data
    }
}
</code></pre>
<p>Query sets (to resolve component access conflicts):</p>
<pre><code class="language-rust no_run noplayground">fn conflicting_queries(
    mut set: QuerySet&lt;(
        // these queries cannot be used at the same time, due to mutability conflict
        Query&lt;&amp;mut MyData, With&lt;ComponentA&gt;&gt;,
        Query&lt;&amp;mut MyData, With&lt;ComponentB&gt;&gt;,
    )&gt;,
) {
    for data in set.q0_mut().iter_mut() {
        // access `data` of entities that match the first query
    }
    for data in set.q1_mut().iter_mut() {
        // access `data` of entities that match the second query
    }
}
</code></pre>
<h2 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h2>
<p>[<a href="cheatsheet/../basics/change-detection.html">explain</a>]</p>
<p>Query filters:</p>
<ul>
<li><code>Added&lt;T&gt;</code>: detect adding new components to existing entities</li>
<li><code>Mutated&lt;T&gt;</code>: detect mutation of existing components</li>
<li><code>Changed&lt;T&gt;</code>: detect any change (added or mutated)</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn with_change_detection(query: Query&lt;&amp;MyData, Changed&lt;MyData&gt;&gt;) {
    // only get `data` if it changed
    for data in query.iter() {
        // use data
    }
}
</code></pre>
<p><strong>WARNING!</strong> The detecting system must run after the changing system, <em>during the same frame</em>.</p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>[<a href="cheatsheet/../basics/commands.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn manage_entities_components_resources(commands: &amp;mut Commands) {
    // build and spawn an entity
    let entity = commands.spawn(MyBundle::default())
        .with(ExtraComponent)
        .with_bundle(ExtraBundle::default())
        // get the entity id
        .current_entity().unwrap();

    // despawn a single entity
    commands.despawn(entity);

    // replaces any existing resource of this type
    commands.insert_resource(MyData::default());

    // add components to existing entity
    commands.insert_one(entity, MyComponent);
    commands.insert(entity, MyBundle::default());

    // remove
    commands.remove_one::&lt;MyComponent&gt;(entity);
    commands.remove::&lt;MyBundle&gt;(entity);
}
</code></pre>
<p>These actions are applied at the end of the stage.</p>
<h2 id="local-per-system-resources"><a class="header" href="#local-per-system-resources">Local (per-system) Resources</a></h2>
<p>[<a href="cheatsheet/../basics/local.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn with_local(local: Local&lt;MyData&gt;) {
    // `local` is an instance of `MyData` uniquely for this system
}
</code></pre>
<p>The type must implement <code>Default</code> or <code>FromResources</code>. It is automatically initialized.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>[<a href="cheatsheet/../basics/events.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">struct MyEvent;

fn sender(mut events: ResMut&lt;Events&lt;MyEvent&gt;&gt;) {
    events.send(MyEvent);
}

fn receiver(
    events: Res&lt;Events&lt;MyEvent&gt;&gt;,
    mut reader: Local&lt;EventReader&lt;MyEvent&gt;&gt;,
) {
    for event in reader.iter(&amp;events) {
        // handle event
    }
}

fn main() {
    App::build()
        .add_plugins(MinimalPlugins)
        .add_event::&lt;MyEvent&gt;()
        // ...
        .run();
}
</code></pre>
<p>Events don't persist. If you don't handle them every frame, they will be lost.</p>
<h2 id="entity-hierarchies-parentchild"><a class="header" href="#entity-hierarchies-parentchild">Entity Hierarchies (Parent/Child)</a></h2>
<p>[<a href="cheatsheet/../basics/parent-child.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn spawn_nested(commands: &amp;mut Commands) {
    let parent = commands.spawn(MyParentBundle::default())
        .with_children(|parent| {
            parent.spawn(MyChildBundle::default());
        }).current_entity().unwrap();

    // despawn a parent and all its children
    commands.despawn_recursive(parent);
}
</code></pre>
<p>Reparent an existing entity:</p>
<pre><code class="language-rust no_run noplayground">    commands.insert_one(child, Parent(parent));
</code></pre>
<p>If you are using <code>Transform</code>s, ensure both the parent and the child also have a <code>GlobalTransform</code>.</p>
<p>Child <code>Transform</code> is relative to the parent. <code>GlobalTransform</code> is internally managed by bevy.</p>
<h2 id="system-chaining"><a class="header" href="#system-chaining">System Chaining</a></h2>
<p>[<a href="cheatsheet/../basics/system-chaining.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn output_system(/* system params */) -&gt; MyData {
    MyData::default()
}

fn input_system(In(data): In&lt;MyData&gt;) {
    // use `data`
}

fn main() {
    App::build()
        .add_system(output_system.system().chain(input_system.system()))
        .run();
}
</code></pre>
<h2 id="app-builder-main-function"><a class="header" href="#app-builder-main-function">App Builder (main function)</a></h2>
<p>[<a href="cheatsheet/../basics/app-builder.html">explain</a>, <a href="cheatsheet/../basics/stages.html">stages</a>, <a href="cheatsheet/../basics/plugins.html">plugins</a>]</p>
<p>App builder:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    // labels for custom stages:
    static DEBUG: &amp;str = &quot;debug&quot;;
    static MY_START: &amp;str = &quot;my_start&quot;;

    App::build()
        // bevy
        .add_plugins(DefaultPlugins)
        // custom plugin
        .add_plugin(MyPlugin::default())
        // specific resource value
        .add_resource(MyResource::new())
        // auto-init using `Default` or `FromResources`
        .init_resource::&lt;MyAutoResource&gt;()
        // add a custom event type:
        .add_event::&lt;MyEvent&gt;()
        // run once at startup:
        .add_startup_system(setup.system())
        // run each frame (in `UPDATE` stage):
        .add_system(game_update.system())
        // add custom stage:
        .add_stage_before(stage::UPDATE, MY_START, SystemStage::parallel())
        // serial stage (parallel system execution disabled)
        .add_stage_after(stage::UPDATE, DEBUG, SystemStage::serial())
        // run system in specific stage:
        .add_system_to_stage(DEBUG, debug_system.system())
        // enter the bevy runtime
        .run();

}
</code></pre>
<p>Custom plugin:</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        // use `app` builder
    }
}
</code></pre>
<h2 id="states"><a class="header" href="#states">States</a></h2>
<p>[<a href="cheatsheet/../basics/states.html">explain</a>]</p>
<p>App builder with States:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, PartialEq, Eq)]
enum MyState {
    MainMenu,
    InGame,
}

fn main() {
    // label for the state stage
    static STATE: &amp;str = &quot;state&quot;;

    App::build()
        // add the app state resource with initial state
        .add_resource(State::new(MyState::MainMenu))
        // add the state stage
        .add_stage_before(
            stage::UPDATE, STATE,
            StateStage::&lt;MyState&gt;::default()
        )
        // this one goes in `UPDATE` as normal
        .add_system(state_independent.system())
        // add systems to states
        .on_state_enter(STATE, MyState::MainMenu, setup_menu.system())
        .on_state_update(STATE, MyState::MainMenu, handle_buttons.system())
        .on_state_exit(STATE, MyState::MainMenu, close_menu.system())
        .run();
}
</code></pre>
<p>Change or check States:</p>
<pre><code class="language-rust no_run noplayground">fn manage_state(mut state: ResMut&lt;State&lt;MyState&gt;&gt;) {
    if *state.current() == MyState::MainMenu {
        state.set_next(MyState::InGame).unwrap();
        // ^ error if another state change is pending
        // or if already in the target state
    }
}
</code></pre>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>[<a href="cheatsheet/../basics/assets.html">explain</a>]</p>
<p>Load asset:</p>
<pre><code class="language-rust no_run noplayground">fn asset_setup(server: Res&lt;AssetServer&gt;) {
    // load path as an asset of specified type
    let handle: Handle&lt;MyAssetType&gt; = server.load(&quot;path/to/asset.file&quot;);
    // autodetect type based on file extension
    let untyped = server.load_untyped(&quot;path/to/file.png&quot;);
    // load a whole folder
    let handles = server.load_folder(&quot;path/to/folder&quot;);
}
</code></pre>
<p>Access assets from systems:</p>
<pre><code class="language-rust no_run noplayground">// store the handle somewhere (in a component or resource)
struct MyAsset(Handle&lt;MyAssetType&gt;);

fn asset_use(assets: Res&lt;Assets&lt;MyAssetType&gt;&gt;, my: Res&lt;MyAsset&gt;) {
    // the asset might not have finished loading yet
    if let Some(data) = assets.get(&amp;my.0) {
        // it's ready
    } else {
        // it's not ready
    }
}
</code></pre>
<p>Create assets from code:</p>
<pre><code class="language-rust no_run noplayground">fn generate_asset(mut assets: ResMut&lt;Assets&lt;MyAssetType&gt;&gt;) {
    assets.add(MyAssetType::new());
}
</code></pre>
<p>Asset events:</p>
<pre><code class="language-rust no_run noplayground">fn asset_events(
    events: Res&lt;Events&lt;AssetEvent&lt;MyAssetType&gt;&gt;&gt;,
    mut reader: Local&lt;EventReader&lt;AssetEvent&lt;MyAssetType&gt;&gt;&gt;
) {
    for event in reader.iter(&amp;events) {
        match event {
            AssetEvent::Created { handle } =&gt; {
                // asset just finished loading
            }
            AssetEvent::Modified { handle } =&gt; {
                // asset was changed
            }
            AssetEvent::Removed { handle } =&gt; {
                // asset was unloaded
            }
        }
    }
}
</code></pre>
<h1 id="bevy-cheatsheet-for-bevy-git"><a class="header" href="#bevy-cheatsheet-for-bevy-git">Bevy Cheatsheet (for bevy git)</a></h1>
<p>One-page overview of common bevy syntax and features.</p>
<p>Concise listing of the syntax + important usage notes, no explanations.</p>
<p>Intended for people who are familiar with the core concepts.</p>
<p>If you are new to bevy or need a refresher, see
<a href="cheatsheet/../cheatsheet/_index.html">Bevy Basics</a>
for brief explanations of each feature.</p>
<hr />
<p>Click on &quot;[explain]&quot; links to go to the relevant <a href="cheatsheet/../basics/_index.html">Bevy Basics</a> page!</p>
<hr />
<h2 id="systems-1"><a class="header" href="#systems-1">Systems</a></h2>
<p>[<a href="cheatsheet/../basics/systems.html">explain</a>]</p>
<h2 id="entities-and-components-1"><a class="header" href="#entities-and-components-1">Entities and Components</a></h2>
<p>[<a href="cheatsheet/../basics/ec.html">explain</a>]</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a component.</p>
<p>Type must be unique; only one instance per type per entity can exist. Use newtypes.</p>
<p>See <a href="cheatsheet/master.html#commands"><code>Commands</code></a> for how to add components to entities and spawn entities.</p>
<p>Component bundles:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Bundle)]
struct AbBundle {
    a: ComponentA,
    b: ComponentB,
}
</code></pre>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>[<a href="cheatsheet/../basics/res.html">explain</a>]</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a resource.</p>
<p>Type must be unique; only one instance per type can exist. Use newtypes.</p>
<p>Access from system:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(a: Res&lt;MyResourceA&gt;, mut b: ResMut&lt;MyResourceB&gt;) {
    // do something with `a` and `b`
}
</code></pre>
<p>Add when <a href="cheatsheet/master.html#app-builder-main-function">building the app</a>:</p>
<pre><code class="language-rust no_run noplayground">    fn main() {
        App::build()
            // specific resource value
            .insert_resource(MyResource::new())
            // auto-init using `Default` or `FromResources`
            .init_resource::&lt;MyAutoResource&gt;()
            .run();
    }
</code></pre>
<p>Add (or replace existing) using <a href="cheatsheet/master.html#commands"><code>Commands</code></a>:</p>
<pre><code class="language-rust no_run noplayground">    commands.insert_resource(MyData::default());
</code></pre>
<p>For complex resource initialization, implement <code>FromResources</code>:</p>
<pre><code class="language-rust no_run noplayground">impl FromResources for MyFancyResource {
    fn from_resources(resources: &amp;Resources) -&gt; Self {
        // you have full access to any other resources you need here,
        // you can even mutate them:
        let mut x = resources.get_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
</code></pre>
<h2 id="queries-1"><a class="header" href="#queries-1">Queries</a></h2>
<p>[<a href="cheatsheet/../basics/queries.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn my_system(mut query: Query&lt;(Entity, &amp;ComponentA, &amp;mut ComponentB)&gt;) {
    // operate on all matching entities
    for (entity, a, mut b) in query.iter_mut() {
        // do something with `a` and `b`; `entity` is the Entity id
    }
}
</code></pre>
<p>To operate on a specific entity:</p>
<pre><code class="language-rust no_run noplayground">    if let Ok((a, mut b)) = query.get_mut(entity) {
        // do something with `a` and `b`
    } else {
        // entity does not match the query
    }
</code></pre>
<p>Add query filters:</p>
<pre><code class="language-rust no_run noplayground">fn with_filter(query: Query&lt;&amp;MyData, (Without&lt;ComponentA&gt;, Or&lt;(With&lt;Foo&gt;, With&lt;Bar&gt;)&gt;)&gt;) {
    // only get `data` for entities that match the filter criteria
    for data in query.iter() {
        // use data
    }
}
</code></pre>
<p>Query sets (to resolve component access conflicts):</p>
<pre><code class="language-rust no_run noplayground">fn conflicting_queries(
    mut set: QuerySet&lt;(
        // these queries cannot be used at the same time, due to mutability conflict
        Query&lt;&amp;mut MyData, With&lt;ComponentA&gt;&gt;,
        Query&lt;&amp;mut MyData, With&lt;ComponentB&gt;&gt;,
    )&gt;,
) {
    for data in set.q0_mut().iter_mut() {
        // access `data` of entities that match the first query
    }
    for data in set.q1_mut().iter_mut() {
        // access `data` of entities that match the second query
    }
}
</code></pre>
<h2 id="change-detection-1"><a class="header" href="#change-detection-1">Change Detection</a></h2>
<p>[<a href="cheatsheet/../basics/change-detection.html">explain</a>]</p>
<p>Query filters:</p>
<ul>
<li><code>Added&lt;T&gt;</code>: detect adding new components to existing entities</li>
<li><code>Mutated&lt;T&gt;</code>: detect mutation of existing components</li>
<li><code>Changed&lt;T&gt;</code>: detect any change (added or mutated)</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn with_change_detection(query: Query&lt;&amp;MyData, Changed&lt;MyData&gt;&gt;) {
    // only get `data` if it changed
    for data in query.iter() {
        // use data
    }
}
</code></pre>
<p><strong>WARNING!</strong> The detecting system must run after the changing system, <em>during the same frame</em>.</p>
<h2 id="commands-1"><a class="header" href="#commands-1">Commands</a></h2>
<p>[<a href="cheatsheet/../basics/commands.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn manage_entities_components_resources(commands: &amp;mut Commands) {
    // build and spawn an entity
    let entity = commands.spawn(MyBundle::default())
        .with(ExtraComponent)
        .with_bundle(ExtraBundle::default())
        // get the entity id
        .current_entity().unwrap();

    // despawn a single entity
    commands.despawn(entity);

    // replaces any existing resource of this type
    commands.insert_resource(MyData::default());

    // add components to existing entity
    commands.insert_one(entity, MyComponent);
    commands.insert(entity, MyBundle::default());

    // remove
    commands.remove_one::&lt;MyComponent&gt;(entity);
    commands.remove::&lt;MyBundle&gt;(entity);
}
</code></pre>
<p>These actions are applied at the end of the stage.</p>
<h2 id="local-per-system-resources-1"><a class="header" href="#local-per-system-resources-1">Local (per-system) Resources</a></h2>
<p>[<a href="cheatsheet/../basics/local.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn with_local(local: Local&lt;MyData&gt;) {
    // `local` is an instance of `MyData` uniquely for this system
}
</code></pre>
<p>The type must implement <code>Default</code> or <code>FromResources</code>. It is automatically initialized.</p>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<p>[<a href="cheatsheet/../basics/events.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">struct MyEvent;

fn sender(mut events: ResMut&lt;Events&lt;MyEvent&gt;&gt;) {
    events.send(MyEvent);
}

fn receiver(mut reader: EventReader&lt;MyEvent&gt;) {
    for event in reader.iter() {
        // handle event
    }
}

fn main() {
    App::build()
        .add_plugins(MinimalPlugins)
        .add_event::&lt;MyEvent&gt;()
        // ...
        .run();
}
</code></pre>
<p>Events don't persist. If you don't handle them every frame, they will be lost.</p>
<h2 id="entity-hierarchies-parentchild-1"><a class="header" href="#entity-hierarchies-parentchild-1">Entity Hierarchies (Parent/Child)</a></h2>
<p>[<a href="cheatsheet/../basics/parent-child.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn spawn_nested(commands: &amp;mut Commands) {
    let parent = commands.spawn(MyParentBundle::default())
        .with_children(|parent| {
            parent.spawn(MyChildBundle::default());
        }).current_entity().unwrap();

    // despawn a parent and all its children
    commands.despawn_recursive(parent);
}
</code></pre>
<p>Reparent an existing entity:</p>
<pre><code class="language-rust no_run noplayground">    commands.insert_one(child, Parent(parent));
</code></pre>
<p>If you are using <code>Transform</code>s, ensure both the parent and the child also have a <code>GlobalTransform</code>.</p>
<p>Child <code>Transform</code> is relative to the parent. <code>GlobalTransform</code> is internally managed by bevy.</p>
<h2 id="system-chaining-1"><a class="header" href="#system-chaining-1">System Chaining</a></h2>
<p>[<a href="cheatsheet/../basics/system-chaining.html">explain</a>]</p>
<pre><code class="language-rust no_run noplayground">fn output_system(/* system params */) -&gt; MyData {
    MyData::default()
}

fn input_system(In(data): In&lt;MyData&gt;) {
    // use `data`
}

fn main() {
    App::build()
        .add_system(output_system.system().chain(input_system.system()))
        .run();
}
</code></pre>
<h2 id="app-builder-main-function-1"><a class="header" href="#app-builder-main-function-1">App Builder (main function)</a></h2>
<p>[<a href="cheatsheet/../basics/app-builder.html">explain</a>, <a href="cheatsheet/../basics/stages.html">stages</a>, <a href="cheatsheet/../basics/plugins.html">plugins</a>]</p>
<p>App builder:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    // labels for custom stages:
    static DEBUG: &amp;str = &quot;debug&quot;;
    static MY_START: &amp;str = &quot;my_start&quot;;

    App::build()
        // bevy
        .add_plugins(DefaultPlugins)
        // custom plugin
        .add_plugin(MyPlugin::default())
        // specific resource value
        .insert_resource(MyResource::new())
        // auto-init using `Default` or `FromResources`
        .init_resource::&lt;MyAutoResource&gt;()
        // add a custom event type:
        .add_event::&lt;MyEvent&gt;()
        // run once at startup:
        .add_startup_system(setup.system())
        // run each frame (in `UPDATE` stage):
        .add_system(game_update.system())
        // add custom stage:
        .add_stage_before(CoreStage::Update, MY_START, SystemStage::parallel())
        // serial stage (parallel system execution disabled)
        .add_stage_after(CoreStage::Update, DEBUG, SystemStage::single_threaded())
        // run system in specific stage:
        .add_system_to_stage(DEBUG, debug_system.system())
        // enter the bevy runtime
        .run();

}
</code></pre>
<p>Custom plugin:</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        // use `app` builder
    }
}
</code></pre>
<h2 id="states-1"><a class="header" href="#states-1">States</a></h2>
<p>[<a href="cheatsheet/../basics/states.html">explain</a>]</p>
<p>App builder with States:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, PartialEq, Eq)]
enum MyState {
    MainMenu,
    InGame,
}

fn main() {
    // label for the state stage
    static STATE: &amp;str = &quot;state&quot;;

    App::build()
        // add the app state resource with initial state
        .insert_resource(State::new(MyState::MainMenu))
        // add the state stage
        .add_stage_before(
            CoreStage::Update, STATE,
            StateStage::&lt;MyState&gt;::default()
        )
        // this one goes in `UPDATE` as normal
        .add_system(state_independent.system())
        // add systems to states
        .on_state_enter(STATE, MyState::MainMenu, setup_menu.system())
        .on_state_update(STATE, MyState::MainMenu, handle_buttons.system())
        .on_state_exit(STATE, MyState::MainMenu, close_menu.system())
        .run();
}
</code></pre>
<p>Change or check States:</p>
<pre><code class="language-rust no_run noplayground">fn manage_state(mut state: ResMut&lt;State&lt;MyState&gt;&gt;) {
    if *state.current() == MyState::MainMenu {
        state.set_next(MyState::InGame).unwrap();
        // ^ error if another state change is pending
        // or if already in the target state
    }
}
</code></pre>
<h2 id="assets-1"><a class="header" href="#assets-1">Assets</a></h2>
<p>[<a href="cheatsheet/../basics/assets.html">explain</a>]</p>
<p>Load asset:</p>
<pre><code class="language-rust no_run noplayground">fn asset_setup(server: Res&lt;AssetServer&gt;) {
    // load path as an asset of specified type
    let handle: Handle&lt;MyAssetType&gt; = server.load(&quot;path/to/asset.file&quot;);
    // autodetect type based on file extension
    let untyped = server.load_untyped(&quot;path/to/file.png&quot;);
    // load a whole folder
    let handles = server.load_folder(&quot;path/to/folder&quot;);
}
</code></pre>
<p>Access assets from systems:</p>
<pre><code class="language-rust no_run noplayground">// store the handle somewhere (in a component or resource)
struct MyAsset(Handle&lt;MyAssetType&gt;);

fn asset_use(assets: Res&lt;Assets&lt;MyAssetType&gt;&gt;, my: Res&lt;MyAsset&gt;) {
    // the asset might not have finished loading yet
    if let Some(data) = assets.get(&amp;my.0) {
        // it's ready
    } else {
        // it's not ready
    }
}
</code></pre>
<p>Create assets from code:</p>
<pre><code class="language-rust no_run noplayground">fn generate_asset(mut assets: ResMut&lt;Assets&lt;MyAssetType&gt;&gt;) {
    assets.add(MyAssetType::new());
}
</code></pre>
<p>Asset events:</p>
<pre><code class="language-rust no_run noplayground">fn asset_events(mut reader: EventReader&lt;AssetEvent&lt;MyAssetType&gt;&gt;) {
    for event in reader.iter() {
        match event {
            AssetEvent::Created { handle } =&gt; {
                // asset just finished loading
            }
            AssetEvent::Modified { handle } =&gt; {
                // asset was changed
            }
            AssetEvent::Removed { handle } =&gt; {
                // asset was unloaded
            }
        }
    }
}
</code></pre>
<h1 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h1>
<h2 id="slow-performance-in-debug-builds"><a class="header" href="#slow-performance-in-debug-builds">Slow performance in debug builds</a></h2>
<p>Rust without compiler optimizations is <em>very slow</em>. With Bevy in particular, the default debug build settings will lead to <em>awful</em> runtime performance. Assets are slow to load and FPS is low.</p>
<p>Common symptoms:</p>
<ul>
<li>Loading 3D models from GLB files can take over 20 seconds! This can trick you into thinking that your code is not working, because you will not see anything on the screen until it is ready.</li>
<li>After spawning some 2D sprites or 3D models, framerate may drop to unplayable levels.</li>
</ul>
<p>However, fully-optimized release builds can be slow to compile.</p>
<p>Solutions:</p>
<pre><code class="language-toml"># in `Cargo.toml` or `.cargo/config`

# Enable only a small amount of optimization:
[profile.dev]
opt-level = 1

# Enable optimizations for dependencies (incl. Bevy),
# but not for our own code:
[profile.dev.package.&quot;*&quot;]
opt-level = 3
</code></pre>
<h2 id="support-for-loading-different-file-formats"><a class="header" href="#support-for-loading-different-file-formats">Support for loading different file formats</a></h2>
<p>By default, only a few asset file formats are enabled:</p>
<ul>
<li>Images: PNG and HDR</li>
<li>Audio: MP3</li>
</ul>
<p>You can enable more formats with cargo features:</p>
<ul>
<li>Images: JPEG, TGA, BMP, DDS</li>
<li>Audio: FLAC, OGG, WAV</li>
</ul>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.4&quot;
features = [&quot;jpeg&quot;, &quot;tga&quot;, &quot;bmp&quot;, &quot;dds&quot;, &quot;flac&quot;, &quot;ogg&quot;, &quot;wav&quot;]
</code></pre>
<h2 id="wayland-support"><a class="header" href="#wayland-support">Wayland support</a></h2>
<p>For Linux builds, enable Wayland support (in addition to X11), with cargo feature:</p>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.4&quot;
features = [&quot;wayland&quot;]
</code></pre>
<h2 id="android-support"><a class="header" href="#android-support">Android support</a></h2>
<p>MSAA does not work. If you get crashes or a black screen, ensure MSAA is <em>not</em> enabled.</p>
<p>Running in the background isn't handled properly. Switching out of the app may cause a crash.</p>
<p>Track the status of Android support <a href="https://github.com/bevyengine/bevy/issues/86">here</a>.</p>
<h1 id="bevy-basics"><a class="header" href="#bevy-basics">Bevy Basics</a></h1>
<p>Overview of the basics of programming in Bevy.</p>
<p>Includes brief explanations of each core concept, with example code to show how
it might be used in a game.</p>
<p>Intended for people learning how to use Bevy.</p>
<p>If you are already familiar with the concepts, check out
<a href="basics/../cheatsheet/_index.html">Bevy Cheatsheet</a>
for a condensed listing of just the syntax + important usage notes.</p>
<h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>Conceptually, an &quot;object&quot; in the game.</p>
<p>Technically, entities are just simple unique integer IDs, that you can use to access component data.</p>
<h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components are data that you can attach to entities.</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a component.</p>
<pre><code class="language-rust no_run noplayground">struct Health {
    hp: f32,
    boost: f32,
    stamina: f32,
}
</code></pre>
<p>Types must be unique -- an entity can only have one of each type.</p>
<p>Use wrapper (newtype) structs to make unique components out of simpler types:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct PlayerXp(u32);

struct PlayerName(String);
</code></pre>
<p>Use empty structs as marker components (tags). Useful with <a href="basics/./queries.html#filter-by-component">query filters</a>.</p>
<pre><code class="language-rust no_run noplayground">/// Add this to all menu ui entities to help identify them
struct MainMenuUI;
/// Marker to help identify the player
struct Player;
/// Marker for hostiles
struct Enemy;
</code></pre>
<p>Components can be accessed from systems, using <a href="basics/./queries.html">queries</a>. </p>
<h1 id="component-bundles"><a class="header" href="#component-bundles">Component Bundles</a></h1>
<p>Bundles are like &quot;templates&quot;, to make it easy to spawn entities with a common set of components.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Bundle)]
struct PlayerBundle {
    xp: PlayerXp,
    name: PlayerName,
    health: Health,
    _p: Player,
}
</code></pre>
<h1 id="resources-2"><a class="header" href="#resources-2">Resources</a></h1>
<p>Akin to &quot;global variables&quot; or &quot;singletons&quot;, used to hold data independent of entities.</p>
<p>Any Rust type (<code>struct</code> or <code>enum</code>) can be used as a resource.</p>
<p>Types must be unique; there can only be one resource of a given type.</p>
<pre><code class="language-rust no_run noplayground">struct GoalsReached {
    main_goal: bool,
    bonus: bool,
}
</code></pre>
<p>Resources can be accessed from systems, using <code>Res</code>/<code>ResMut</code>.</p>
<h2 id="resource-initialization"><a class="header" href="#resource-initialization">Resource Initialization</a></h2>
<p>Implement <code>Default</code> for simple resources:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Default)]
struct StartingLevel(usize);
</code></pre>
<p>For resources that need complex initialization, implement <code>FromResources</code>:</p>
<pre><code class="language-rust no_run noplayground">struct MyFancyResource { /* stuff */ }

impl FromResources for MyFancyResource {
    fn from_resources(resources: &amp;Resources) -&gt; Self {
        // you have full access to any other resources you need here,
        // you can even mutate them:
        let mut x = resources.get_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
</code></pre>
<p>You can create your resources at <a href="basics/./app-builder.html"><code>App</code> creation</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::build()
        // if it implements `Default` or `FromResources`
        .init_resource::&lt;MyFancyResource&gt;()
        // if not, or if you want to set a specific value
        .add_resource(StartingLevel(3))
        // ...
        .run();
}
</code></pre>
<p>Or using <a href="basics/./commands.html"><code>Commands</code></a> from inside a system:</p>
<pre><code class="language-rust no_run noplayground">commands.insert_resource(GoalsReached { main_goal: false, bonus: false });
</code></pre>
<p>If a resource of this type already exists, it will be overwritten.</p>
<h1 id="systems-2"><a class="header" href="#systems-2">Systems</a></h1>
<p>Systems are functions you write, which are run by Bevy.</p>
<p>This is where you implement all your game logic.</p>
<p>These functions can only take special parameter types, to specify what game data you want to access.</p>
<pre><code class="language-rust no_run noplayground">fn debug_start(
    // access resource
    start: Res&lt;StartingLevel&gt;
) {
    eprintln!(&quot;Starting on level {:?}&quot;, *start);
}
</code></pre>
<p>System parameters can be grouped into tuples. This is useful for organization,
or to overcome the limits on the maximum number of parameters (if you get a
compiler error after adding more parameters to your system):</p>
<pre><code class="language-rust no_run noplayground">fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    mut c: ResMut&lt;ResourceC&gt;,
) {}
</code></pre>
<h1 id="queries-2"><a class="header" href="#queries-2">Queries</a></h1>
<p>Queries let you access components of entities.</p>
<pre><code class="language-rust no_run noplayground">fn check_zero_health(
    // access entities that have `Health` and `Transform` components
    // get read-only access to `Health` and mutable access to `Transform`
    mut query: Query&lt;(&amp;Health, &amp;mut Transform)&gt;,
) {
    // get all matching entities
    for (health, mut transform) in query.iter_mut() {
        eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);

        // center if hp is zero
        if health.hp &lt;= 0.0 {
            transform.translation = Vec3::zero();
        }
    }
}
</code></pre>
<p>Get the components associated with a specific entity:</p>
<pre><code class="language-rust no_run noplayground">    if let Ok((health, mut transform)) = query.get_mut(entity) {
        // do something with the components
    } else {
        // the entity does not have the components from the query
    }
</code></pre>
<p>Get the IDs of the entities you access with your queries:</p>
<pre><code class="language-rust no_run noplayground">// add `Entity` to `Query` to get Entity IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
    for (e, /* ... */) in q.iter() {
        // `e` is the Entity ID of the entity we are accessing
    }
}
</code></pre>
<h2 id="query-filters"><a class="header" href="#query-filters">Query Filters</a></h2>
<p>Add query filters to narrow down the entities you get from the query.</p>
<p>Multiple filters can be combined:</p>
<ul>
<li>in a tuple to apply all of them (AND logic)</li>
<li>using the Or&lt;...&gt; wrapper to detect any of them (OR logic).</li>
</ul>
<p>Use <code>With</code>/<code>Without</code> to only get entities that have specific components.</p>
<pre><code class="language-rust no_run noplayground">fn debug_player_hp(
    // access the health, only for friendly players, optionally with name
    query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
    // get all matching entities
    for (health, name) in query.iter() {
        if let Some(name) = name {
            eprintln!(&quot;Player {} has {} HP.&quot;, name.0, health.hp);
        } else {
            eprintln!(&quot;Unknown player has {} HP.&quot;, health.hp);
        }
    }
}
</code></pre>
<h2 id="query-sets"><a class="header" href="#query-sets">Query Sets</a></h2>
<p>For safety reasons, a system cannot have multiple queries with mutability conflicts on the same components.</p>
<p>The solution is to wrap them in a <code>QuerySet</code>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    // access the health of enemies and the health of players
    // (note: some entities could be both!)
    mut q: QuerySet&lt;(Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;, Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;)&gt;,
) {
    // set health of enemies
    for mut health in q.q0_mut().iter_mut() {
        health.hp = 50.0;
    }

    // set health of players
    for mut health in q.q1_mut().iter_mut() {
        health.hp = 100.0;
    }
}
</code></pre>
<p>This ensures that only one of the conflicting queries can be used at the same time.</p>
<h1 id="commands-2"><a class="header" href="#commands-2">Commands</a></h1>
<p>Use <code>Commands</code> to spawn/despawn entities, add/remove components on existing entities, insert resources.</p>
<p>These actions only take effect at the end of the stage, not immediately.</p>
<p>(if you are not using stages, that means your systems will see them the next frame, not the current)</p>
<pre><code class="language-rust no_run noplayground">fn spawn_player(
    commands: &amp;mut Commands,
) {
    // `spawn` takes a Bundle
    commands.spawn(PlayerBundle {
        name: PlayerName(&quot;Henry&quot;.into()),
        xp: PlayerXp(1000),
        health: Health {
            hp: 100.0, boost: 20.0, stamina: 100.0,
        },
        _p: Player,
    })
        // add an extra bundle
        .with_bundle(MyBundle::default())
        // add an extra component
        .with(ComponentA);

    // get the entity id of the last spawned entity
    let entity = commands.current_entity().unwrap();
    // ^ unwrap is OK, `None` only returned if you haven't spawned first

    // spawn another entity
    // NOTE: tuples of arbitrary components are valid bundles
    commands.spawn((
        ComponentA::default(),
        ComponentB::default(),
        ComponentC::default(),
    ));
}

fn make_all_players_hostile(
    commands: &amp;mut Commands,
    query: Query&lt;Entity, With&lt;Player&gt;&gt;,
) {
    for entity in query.iter() {
        // add an `Enemy` component to the entity
        commands.insert_one(entity, Enemy);

        // ensure they have a `MyBundle`
        commands.insert(entity, MyBundle::default());
    }
}
</code></pre>
<h1 id="local-resources"><a class="header" href="#local-resources">Local Resources</a></h1>
<p>You can have per-system data, using <code>Local&lt;T&gt;</code>.</p>
<pre><code class="language-rust no_run noplayground">fn my_system(mut local: Local&lt;MyState&gt;) {}
</code></pre>
<p>The type must implement <code>Default</code> or <code>FromResources</code>. It is automatically initialized.</p>
<p>If the same type is used in multiple systems, they each get their own instance.</p>
<h1 id="events-2"><a class="header" href="#events-2">Events</a></h1>
<p>Send data between systems, to let your systems communicate with each other!</p>
<p>Accessed using an <code>Events&lt;T&gt;</code> resource.</p>
<p>Events don't persist. If receivers don't handle them every frame, they will be lost.</p>
<p>To receive, you need an <code>EventReader&lt;T&gt;</code>, to track the events received by the system. Put it in a <code>Local</code> resource.</p>
<pre><code class="language-rust no_run noplayground">struct LevelUpEvent(Entity);

fn player_level_up(
    mut ev_levelup: ResMut&lt;Events&lt;LevelUpEvent&gt;&gt;,
    query: Query&lt;(Entity, &amp;PlayerXp)&gt;,
) {
    for (entity, xp) in query.iter() {
        if xp.0 &gt; 1000 {
            ev_levelup.send(LevelUpEvent(entity));
        }
    }
}

fn debug_levelups(
    events: Res&lt;Events&lt;LevelUpEvent&gt;&gt;,
    mut event_reader: Local&lt;EventReader&lt;LevelUpEvent&gt;&gt;,
) {
    for ev in event_reader.iter(&amp;events) {
        eprintln!(&quot;Entity {:?} leveled up!&quot;, ev.0);
    }
}
</code></pre>
<p>Events are very flexible data flow tool. As events can be sent from any system
and received by multiple systems, they are <em>extremely</em> versatile. Use them.</p>
<h1 id="app-builder-main-function-2"><a class="header" href="#app-builder-main-function-2">App Builder (main function)</a></h1>
<p>To enter the bevy runtime, build an <code>App</code>, composed of all the plugins, event types, resources, and systems, that you want to use.</p>
<p>Everything must be registered in the <code>App</code>, or it will not work.</p>
<p>You also need to add bevy's builtin functionality: either <code>DefaultPlugins</code> if
you are making a full game/app, or <code>MinimalPlugins</code> for something like a
headless server.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::build()
        // bevy
        .add_plugins(DefaultPlugins)

        // resources:
        .add_resource(StartingLevel(3))
        // if it implements `Default` or `FromResources`
        .init_resource::&lt;MyFancyResource&gt;()

        // events:
        .add_event::&lt;LevelUpEvent&gt;()

        // systems to run once at startup:
        .add_startup_system(spawn_player.system())

        // systems to run each frame:
        .add_system(player_level_up.system())
        .add_system(debug_levelups.system())
        .add_system(debug_stats_change.system())
        // ...

        // launch the app!
        .run();
}
</code></pre>
<h1 id="assets-2"><a class="header" href="#assets-2">Assets</a></h1>
<p>Bevy has a flexible system for loading and managing your game assets
asynchronously (in the background, without causing lag spikes in your game).</p>
<p>The data of your loaded assets is stored in an <code>Assets&lt;T&gt;</code> resource.</p>
<p>To access the asset data, you need a <code>Handle&lt;T&gt;</code>. Handles are just lightweight IDs for a specific asset.</p>
<p>To load assets from files, use the <code>AssetServer</code> resource.</p>
<pre><code class="language-rust no_run noplayground">struct UiFont(Handle&lt;Font&gt;);

fn load_ui_font(
    commands: &amp;mut Commands,
    server: Res&lt;AssetServer&gt;
) {
    let handle: Handle&lt;Font&gt; = server.load(&quot;font.ttf&quot;);

    // store the handle in a resource, so we can
    // easily access it later to build UIs
    commands.insert_resource(UiFont(handle));
}
</code></pre>
<p>This queues the asset loading to happen in the background. The asset will not be
available immediately.</p>
<p>Do this in a system that runs once, either at <a href="basics/./app-builder.html">startup</a>
or when <a href="basics/./states.html">entering your game state</a>.</p>
<p>You can also create assets using code and add them to <code>Assets&lt;T&gt;</code> manually.</p>
<p>This is useful if you want to create them using code (such as for procedural
generation), or if you have gotten the data in some other way.</p>
<p>To access your assets from systems, use the <code>Handle&lt;T&gt;</code> and <code>Assets&lt;T&gt;</code> resource:</p>
<pre><code class="language-rust no_run noplayground">struct SpriteSheets {
    map_tiles: Handle&lt;TextureAtlas&gt;,
}

fn use_sprites(
    handles: Res&lt;SpriteSheets&gt;,
    assets: Res&lt;Assets&lt;TextureAtlas&gt;&gt;,
) {
    // Could be `None` if the asset isn't loaded yet
    if let Some(asset) = assets.get(&amp;handles.map_tiles) {
        // do something with the texture atlas
    }
}
</code></pre>
<h2 id="assetevent"><a class="header" href="#assetevent">AssetEvent</a></h2>
<p>If you need to perform specific actions when the asset has finished loading, is
modified, or removed, you can react to <code>AssetEvent</code>s.</p>
<pre><code class="language-rust no_run noplayground">struct MapTexture {
    handle: Handle&lt;Texture&gt;,
}

fn fixup_textures(
    ev_asset: Res&lt;Events&lt;AssetEvent&lt;Texture&gt;&gt;&gt;,
    mut evr_asset: Local&lt;EventReader&lt;AssetEvent&lt;Texture&gt;&gt;&gt;,
    mut assets: ResMut&lt;Assets&lt;Texture&gt;&gt;,
    map_tex: Res&lt;MapTexture&gt;,
) {
    for ev in evr_asset.iter(&amp;ev_asset) {
        if let AssetEvent::Created { handle } = ev {
            // a texture was just loaded!

            let texture = assets.get_mut(handle).unwrap();
            // ^ unwrap is OK, because we know it is loaded now

            if *handle == map_tex.handle {
                // it is our special map texture!
            } else {
                // it is some other texture
            }
        }
    }
}
</code></pre>
<h2 id="handles"><a class="header" href="#handles">Handles</a></h2>
<p>Handles have built-in reference counting (similar to <code>Rc</code>/<code>Arc</code> in Rust).</p>
<p>Therefore, you need to <code>.clone()</code> them to create multiple handles to the same
asset. The clone is a cheap operation, but it is explicit, to ensure that you
are aware of when your code is creating more of them.</p>
<p>Handles can be &quot;strong&quot; (default) or &quot;weak&quot;. If no more strong handles
exist, the asset's data will be freed/unloaded automatically.</p>
<p>Bevy also has a <code>HandleUntyped</code> type. Use this type of handle if you need to
be able to refer to any asset, regardless of the asset type.</p>
<p>This allows you to have a <code>Vec</code> or <code>HashMap</code> containing assets of mixed types.</p>
<p>Conveniently, the <code>AssetServer</code> supports untyped loading, if you don't know
what asset type the files are. It also supports loading entire folders.</p>
<pre><code class="language-rust no_run noplayground">struct ExtraAssets(Vec&lt;HandleUntyped&gt;);

fn load_extra_assets(
    commands: &amp;mut Commands,
    server: Res&lt;AssetServer&gt;,
) {
    if let Ok(handles) = server.load_folder(&quot;extra&quot;) {
        commands.insert_resource(ExtraAssets(handles));
    }
}
</code></pre>
<p>It will try to detect the format of each asset based on the file extension.</p>
<h1 id="change-detection-2"><a class="header" href="#change-detection-2">Change Detection</a></h1>
<p>You can optimize your systems by only operating on entities when specific components change.</p>
<p>Use query filters:</p>
<ul>
<li><code>Added&lt;T&gt;</code>: detect adding new components to existing entities</li>
<li><code>Mutated&lt;T&gt;</code>: detect mutation of existing components</li>
<li><code>Changed&lt;T&gt;</code>: detect any change (added or mutated)</li>
</ul>
<pre><code class="language-rust no_run noplayground">/// Print friendly player stats when they change
fn debug_stats_change(
    query: Query&lt;
        // components
        (&amp;Health, &amp;PlayerXp),
        // filters
        (Without&lt;Enemy&gt;, Or&lt;(Changed&lt;Health&gt;, Changed&lt;PlayerXp&gt;)&gt;), 
    &gt;,
) {
    for (health, xp) in query.iter() {
        eprintln!(
            &quot;hp: {}+{}, sta: {}, xp: {}&quot;,
            health.hp, health.boost, health.stamina, xp.0
        );
    }
}

/// detect new enemies and print their health
fn debug_new_hostiles(
    query: Query&lt;(Entity, &amp;Health), Added&lt;Enemy&gt;&gt;,
) {
    for (entity, health) in query.iter() {
        eprintln!(&quot;Entity {:?} is now an enemy! HP: {}&quot;, entity, health.hp);
    }
}
</code></pre>
<h2 id="warning"><a class="header" href="#warning">WARNING!</a></h2>
<p>Change information only persists until the end of the current frame!</p>
<p>If your detecting system runs before the changing system, it will <em>not</em> detect
the changes!</p>
<p><code>Added</code> is especially tricky to use. You need to add components using
<a href="basics/./commands.html"><code>Commands</code></a>, which are only applied at the end of each
<a href="basics/./stages.html">stage</a>. The detecting system needs to be in a <em>later stage</em> that
runs during the same frame!</p>
<h1 id="hierarchical-parentchild-entities"><a class="header" href="#hierarchical-parentchild-entities">Hierarchical (Parent/Child) Entities</a></h1>
<p>Technically, the Entities/Components themselves cannot form a hierarchy (it is a
flat data structure). However, logical hierarchies are a common pattern in games.</p>
<p>Bevy supports creating such a logical link between entities, to form a virtual
&quot;hierarchy&quot;, by simply adding <code>Parent</code> and  <code>Children</code> components on the
respective entities.</p>
<p><code>Commands</code> has methods for adding children to entities, which automatically add the correct components:</p>
<pre><code class="language-rust no_run noplayground">// spawn the parent and get its Entity id
let parent = commands.spawn(MyBundle::default())
    .current_entity().unwrap();

// do the same for the child
let child = commands.spawn(MyBundle::default())
    .current_entity().unwrap();

// connect them
commands.push_children(parent, &amp;[child]);

// you can also use `with_children`:
commands.spawn(MyBundle::default())
    .with_children(|parent| {
        parent.spawn(MyBundle::default());
    });
</code></pre>
<p>You can despawn an entire hierarchy with a single command:</p>
<pre><code class="language-rust no_run noplayground">fn close_menu(
    commands: &amp;mut Commands,
    query: Query&lt;Entity, With&lt;MainMenuUI&gt;&gt;,
) {
    for entity in query.iter() {
        // despawn the entity and its children
        commands.despawn_recursive(entity);
    }
}
</code></pre>
<h2 id="relative-transforms"><a class="header" href="#relative-transforms">Relative Transforms</a></h2>
<p>To use transforms with hierarchical entities, both the parent and the child must have a <code>GlobalTransform</code> and a <code>Transform</code>.</p>
<p>The <code>GlobalTransform</code> is managed by bevy internally; do not mutate it yourself.</p>
<p>The <code>Transform</code> is what you can manipulate directly. On the child, it will behave relative to the parent.</p>
<p>All component bundles that come with bevy provide this correctly, but if you are
not using such a bundle, you need to make sure to add both of these components to both entities.</p>
<h1 id="system-chaining-2"><a class="header" href="#system-chaining-2">System Chaining</a></h1>
<p>Systems can take an input and produce an output, and connected together as a chain.</p>
<p>Think of this as &quot;glue&quot;, for constructing larger systems out of multiple parts.</p>
<p>One useful application of this is error handling (allowing the use of <code>?</code>):</p>
<pre><code class="language-rust no_run noplayground">fn net_receive(mut netcode: ResMut&lt;MyNetProto&gt;) -&gt; std::io::Result&lt;()&gt; {
    netcode.receive_updates()?;

    Ok(())
}

fn handle_io_errors(In(result): In&lt;std::io::Result&lt;()&gt;&gt;) {
    if let Err(e) = result {
        eprintln!(&quot;I/O error occurred: {}&quot;, e);
    }
}
</code></pre>
<p>Such systems cannot be registered individually (Bevy doesn't know what to do
with the input/output). You have to connect them in a chain:</p>
<pre><code class="language-rust no_run noplayground">    fn main() {
        App::build()
            // ...
            .add_system(net_receive.system().chain(handle_io_errors.system()))
            // ...
            .run();
    }
</code></pre>
<p>Chains are a niche tool; only use them if you really want to construct large
systems out of modular parts. Avoid using them as a general-purpose data passing
mechanism. For most use cases, you probably want to use <a href="basics/./events.html">Events</a>
instead.</p>
<h2 id="performance-warning"><a class="header" href="#performance-warning">Performance Warning</a></h2>
<p>Beware that Bevy treats the whole chain as if it was a single big system, with
all the combined resources and queries. This implies that parallelism could be
limited, affecting performance.</p>
<p>Avoid adding a system that requires mutable access to anything, as part of
multiple chains. It would block all affected chains from running in parallel.</p>
<h1 id="stages"><a class="header" href="#stages">Stages</a></h1>
<p>Bevy runs multiple systems in parallel, as much as possible, using multiple CPU
cores to give you good performance.</p>
<p>You can use stages to introduce synchronization points: ensure all systems of
the previous stage have completed before any systems of the next stage begin.</p>
<p><code>Commands</code> are applied at the end of each stage.</p>
<p>Bevy provides at least these stages: <code>FIRST</code>, <code>PRE_UPDATE</code>, <code>UPDATE</code>, <code>POST_UPDATE</code>, <code>LAST</code>.</p>
<p>By default, when you add systems, they are added to <code>UPDATE</code>.</p>
<p>Bevy's internal systems are in the other stages, to ensure they are ordered
correctly relative to your game logic (for example, rendering needs to happen
after your game logic completes).</p>
<p>We can add more stages. For example, if we want our debug systems to run after our game logic:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    // label for our debug stage
    static DEBUG: &amp;str = &quot;debug&quot;;

    App::build()
        .add_plugins(DefaultPlugins)

        // add DEBUG stage after UPDATE
        // make the stage `serial` (disable parallel execution)
        // to ensure systems run in the given order
        // (useful for predictable debug messages)
        .add_stage_after(stage::UPDATE, DEBUG, SystemStage::serial())

        // systems are added to the `UPDATE` stage by default
        .add_system(player_gather_xp.system())
        .add_system(player_take_damage.system())

        // add our debug systems
        .add_system_to_stage(DEBUG, debug_player_hp.system())
        .add_system_to_stage(DEBUG, debug_stats_change.system())
        .add_system_to_stage(DEBUG, debug_new_hostiles.system())

        .run();
}
</code></pre>
<h1 id="states-2"><a class="header" href="#states-2">States</a></h1>
<p>States allow you to structure the runtime &quot;flow&quot; of your app.</p>
<p>You can have different systems running, depending on the state.</p>
<p>You can add systems that only run when transitioning between states.</p>
<p>States are built using stages.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone)]
enum AppState {
    MainMenu,
    InGame,
    Credits,
}

fn main() {
    // label for our state stage
    static STATE: &amp;str = &quot;state&quot;;

    App::build()
        .add_plugins(DefaultPlugins)

        // add the app state resource; start in menu
        .add_resource(State::new(AppState::MainMenu))

        // add stage for the state-specific systems
        // make it run before the main updates
        .add_stage_before(
            stage::UPDATE, STATE,
            StateStage::&lt;AppState&gt;::default()
        )

        // state-independent systems go in `UPDATE`, as normal
        .add_system(maintain_all_uis.system())

        // add systems to specific states and transitions

        .on_state_enter(STATE, AppState::MainMenu, spawn_main_menu.system())
        .on_state_update(STATE, AppState::MainMenu, menu_buttons.system())
        .on_state_exit(STATE, AppState::MainMenu, close_menu.system())

        .on_state_update(STATE, AppState::Credits, roll_credits.system())
        .on_state_exit(STATE, AppState::Credits, quit_app.system())

        .on_state_enter(STATE, AppState::InGame, load_map.system())
        .on_state_update(STATE, AppState::InGame, player_move.system())
        .on_state_update(STATE, AppState::InGame, player_take_damage.system())
        .on_state_update(STATE, AppState::InGame, enemy_ai.system())
        .on_state_exit(STATE, AppState::InGame, unload_level.system())

        .run();
}
</code></pre>
<p>Inside of systems, you can check and control the state using the <code>State&lt;T&gt;</code> resource:</p>
<pre><code class="language-rust no_run noplayground">fn check_app_state(app_state: Res&lt;State&lt;AppState&gt;&gt;) {
    match app_state.current() {
        AppState::MainMenu =&gt; {
            println!(&quot;In the main menu!&quot;);
        }
        AppState::InGame =&gt; {
            println!(&quot;Playing the game!&quot;);
        }
        AppState::Credits =&gt; {
            println!(&quot;Rolling the credits!&quot;);
        }
    }

    if let Some(prev) = app_state.previous() {
        println!(&quot;The previous app state was {:?}&quot;, prev);
    }

    if let Some(next) = app_state.next() {
        println!(&quot;App state is about to be changed to {:?}&quot;, next);
    }
}
</code></pre>
<p>To change to another state:</p>
<pre><code class="language-rust no_run noplayground">fn enter_game(mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;) {
    app_state.set_next(AppState::InGame).unwrap();
    // ^ this can fail if we are already in the target state
    // or if another state change is already queued
}
</code></pre>
<p>After the systems of the current state complete, bevy will transition to the next state you set.</p>
<p>Note: you can do arbitrarily many state transitions in a single frame. Bevy will
handle all of them and execute all the relevant systems before moving on to the
next stage in the app schedule.</p>
<h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>As your project grows, it can be useful to make it more modular. You can split it into plugins.</p>
<p>Plugins are simply collections of things to be added to the App Builder.</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app
            .init_resource::&lt;MyOtherResource&gt;()
            .add_event::&lt;MyEvent&gt;()
            .add_startup_system(plugin_init.system())
            .add_system(my_system.system());
    }
}

fn main() {
    App::build()
        .add_plugins(DefaultPlugins)
        .add_plugin(MyPlugin)
        .run();
}
</code></pre>
<h1 id="bevy-advanced-patterns"><a class="header" href="#bevy-advanced-patterns">Bevy Advanced Patterns</a></h1>
<p>This section of the book contains advice about general practices that help you use bevy effectively.</p>
<h1 id="generic-systems"><a class="header" href="#generic-systems">Generic Systems</a></h1>
<p><a href="patterns/../code_bevy_release/src/generic-systems.rs">Click here to download the code from this page.</a></p>
<hr />
<p>Bevy systems are just plain rust functions, which means they can be generic.</p>
<p>This is especially useful when combined with bevy states. You can do the same thing to different sets of entities depending on state.</p>
<hr />
<p>One use-case is for cleanup.</p>
<pre><code class="language-rust no_run noplayground">/// Marker components to group entities for cleanup
mod cleanup {
    pub struct LevelUnload;
    pub struct MenuExit;
}

fn cleanup_system&lt;T: Component&gt;(
    commands: &amp;mut Commands,
    q: Query&lt;Entity, With&lt;T&gt;&gt;,
) {
    for e in q.iter() {
        commands.despawn_recursive(e);
    }
}
</code></pre>
<p>Menu entities can be tagged with <code>cleanup::MenuExit</code>, entities from the game map can be tagged with <code>cleanup::LevelUnload</code>.</p>
<p>We can add the generic cleanup system to our state transitions, to take care of the respective entities:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone)]
enum AppState {
    MainMenu,
    InGame,
}

/// Label for the main stage
static MAIN: &amp;str = &quot;MainStage&quot;;

fn main() {
    App::build()
        .add_plugins(DefaultPlugins)
        // add the state stage
        .add_resource(State::new(AppState::MainMenu))
        .add_stage_before(
            stage::UPDATE, MAIN,
            StateStage::&lt;AppState&gt;::default()
        )
        // add the cleanup systems
        .on_state_exit(
            MAIN, AppState::MainMenu,
            cleanup_system::&lt;cleanup::MenuExit&gt;.system()
        )
        .on_state_exit(
            MAIN, AppState::InGame,
            cleanup_system::&lt;cleanup::LevelUnload&gt;.system()
        )
        .run();
}
</code></pre>
<h1 id="bevy-cookbook"><a class="header" href="#bevy-cookbook">Bevy Cookbook</a></h1>
<p>List of recipes for common problems and tasks in game development.</p>
<p>The recipes are written to only focus on the relevant information for the task at hand.</p>
<p>Only the relevant parts of the code are shown. Full example files are available and linked on the page of each recipe.</p>
<p>It is assumed that you are already familiar with Bevy programming. If not, check out <a href="cookbook/../basics/_index.html">Bevy Basics</a>.</p>
<h1 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/input.rs">Click here for the full example code.</a></p>
<hr />
<p>Since bevy resources and events are global and accessible from any system, you
don't need to centralize your input handling code in one place. You can consume
any relevant inputs wherever you need them.</p>
<p>If you simply need to check the current state of specific keyboard keys or mouse buttons:</p>
<pre><code class="language-rust no_run noplayground">fn my_simple_system(keys: Res&lt;Input&lt;KeyCode&gt;&gt;, btns: Res&lt;Input&lt;MouseButton&gt;&gt;) {
    // Keyboard input
    if keys.pressed(KeyCode::Space) {
        // space is being held down
    }

    // Mouse buttons
    if btns.just_pressed(MouseButton::Left) {
        // a left click just happened
    }
}
</code></pre>
<p>For more powerful input handling, to detect all activity, use input events:</p>
<pre><code class="language-rust no_run noplayground">fn my_fancy_system(
    ev_keys: Res&lt;Events&lt;KeyboardInput&gt;&gt;,
    mut evr_keys: Local&lt;EventReader&lt;KeyboardInput&gt;&gt;,

    ev_cursor: Res&lt;Events&lt;CursorMoved&gt;&gt;,
    mut evr_cursor: Local&lt;EventReader&lt;CursorMoved&gt;&gt;,

    ev_motion: Res&lt;Events&lt;MouseMotion&gt;&gt;,
    mut evr_motion: Local&lt;EventReader&lt;MouseMotion&gt;&gt;,

    ev_mousebtn: Res&lt;Events&lt;MouseButtonInput&gt;&gt;,
    mut evr_mousebtn: Local&lt;EventReader&lt;MouseButtonInput&gt;&gt;,

    ev_scroll: Res&lt;Events&lt;MouseWheel&gt;&gt;,
    mut evr_scroll: Local&lt;EventReader&lt;MouseWheel&gt;&gt;,

    ev_touch: Res&lt;Events&lt;TouchInput&gt;&gt;,
    mut evr_touch: Local&lt;EventReader&lt;TouchInput&gt;&gt;,
) {
    // Keyboard input
    for ev in evr_keys.iter(&amp;ev_keys) {
        if ev.state.is_pressed() {
            eprintln!(&quot;Just pressed key: {:?}&quot;, ev.key_code);
        } else {
            eprintln!(&quot;Just released key: {:?}&quot;, ev.key_code);
        }
    }

    // Absolute cursor position (in window coordinates)
    for ev in evr_cursor.iter(&amp;ev_cursor) {
        eprintln!(&quot;Cursor at: {}&quot;, ev.position);
    }

    // Relative mouse motion
    for ev in evr_motion.iter(&amp;ev_motion) {
        eprintln!(&quot;Mouse moved {} pixels&quot;, ev.delta);
    }

    // Mouse buttons
    for ev in evr_mousebtn.iter(&amp;ev_mousebtn) {
        if ev.state.is_pressed() {
            eprintln!(&quot;Just pressed mouse button: {:?}&quot;, ev.button);
        } else {
            eprintln!(&quot;Just released mouse button: {:?}&quot;, ev.button);
        }
    }

    // scrolling (mouse wheel, touchpad, etc.)
    for ev in evr_scroll.iter(&amp;ev_scroll) {
        eprintln!(&quot;Scrolled vertically by {} and horizontally by {}.&quot;, ev.y, ev.x);
    }

    // touch input
    for ev in evr_touch.iter(&amp;ev_touch) {
        eprintln!(&quot;Touch {} in {:?} at {}.&quot;, ev.id, ev.phase, ev.position);
    }
}
</code></pre>
<h1 id="quitting-the-app"><a class="header" href="#quitting-the-app">Quitting the App</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/quit.rs">Click here for the full example code.</a></p>
<hr />
<p>To cleanly shut down bevy, send an <code>AppExit</code> event from any system:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::AppExit;

fn exit_system(mut exit: ResMut&lt;Events&lt;AppExit&gt;&gt;) {
    exit.send(AppExit);
}
</code></pre>
<p>For prototyping, bevy provides a system you can add, to exit on pressing the Esc key:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::build()
        .add_plugins(DefaultPlugins)
        .add_system(bevy::input::system::exit_on_esc_system.system())
        .run();
}
</code></pre>
<h1 id="changing-the-background-color"><a class="header" href="#changing-the-background-color">Changing the Background Color</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/clear-color.rs">Click here for the full example code.</a></p>
<hr />
<p>Use the <code>ClearColor</code> resource to choose the background color.</p>
<p>It must be added before the default plugins.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::build()
        .add_resource(ClearColor(Color::rgb(0.4, 0.4, 0.4)))
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre>
<h1 id="show-framerate-in-console"><a class="header" href="#show-framerate-in-console">Show Framerate in Console</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/print-framerate.rs">Click here for the full example code.</a></p>
<hr />
<p>You can use bevy's builtin diagnostics system to print framerate (FPS) to the console, for monitoring performance.</p>
<p><em>Note (git master)</em>: <code>PrintDiagnosticsPlugin</code> was renamed to <code>LogDiagnosticsPlugin</code>.</p>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, PrintDiagnosticsPlugin};

fn main() {
    App::build()
        .add_plugins(DefaultPlugins)
        .add_plugin(PrintDiagnosticsPlugin::default())
        .add_plugin(FrameTimeDiagnosticsPlugin::default())
        .add_system(PrintDiagnosticsPlugin::print_diagnostics_system.system())
        .run();
}
</code></pre>
<h1 id="track-assets-loading"><a class="header" href="#track-assets-loading">Track Assets Loading</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/assets-ready.rs">Click here for the full example code.</a></p>
<hr />
<p>You might want to know when your various assets have all finished loading, and
take some action, such as exiting your loading screen and starting gameplay.</p>
<p>To do this, we can convert our various handles to <code>HandleUntyped</code>s, so we
can add them all into a single collection. Then we can loop over the collection
and ask the <code>AssetServer</code> about their status.</p>
<pre><code class="language-rust no_run noplayground">struct AssetsLoading(Vec&lt;HandleUntyped&gt;);

fn setup(
    server: Res&lt;AssetServer&gt;,
    mut loading: ResMut&lt;AssetsLoading&gt;,
) {
    // we can have different asset types
    let font: Handle&lt;Font&gt; = server.load(&quot;my_font.ttf&quot;);
    let menu_bg: Handle&lt;Texture&gt; = server.load(&quot;menu.png&quot;);
    let scene: Handle&lt;Scene&gt; = server.load(&quot;level01.gltf#Scene0&quot;);

    // add them all to our collection for tracking
    loading.0.push(font.clone_untyped());
    loading.0.push(menu_bg.clone_untyped());
    loading.0.push(scene.clone_untyped());
}

fn check_assets_ready(
    server: Res&lt;AssetServer&gt;,
    loading: Res&lt;AssetsLoading&gt;,
) {
    use bevy::asset::LoadState;

    let mut ready = true;

    for handle in loading.0.iter() {
        match server.get_load_state(handle) {
            LoadState::Failed =&gt; {
                // one of our assets had an error
            }
            LoadState::Loaded =&gt; {}
            _ =&gt; {
                ready = false;
            }
        }
    }

    if !ready {
        return;
    }

    // all assets are now ready
}
</code></pre>
<h1 id="grabbing-the-mouse"><a class="header" href="#grabbing-the-mouse">Grabbing the Mouse</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/mouse-grab.rs">Click here for the full example code.</a></p>
<hr />
<p>You can lock/release the mouse cursor using bevy's <a href="https://github.com/bevyengine/bevy/blob/master/examples/window/window_settings.rs">window settings API</a>.</p>
<p>Here is an example that locks and hides the cursor in the primary window on mouse click and releases it when pressing Esc:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_grab_system(
    mut windows: ResMut&lt;Windows&gt;,
    btn: Res&lt;Input&lt;MouseButton&gt;&gt;,
    key: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    let window = windows.get_primary_mut().unwrap();

    if btn.just_pressed(MouseButton::Left) {
        window.set_cursor_lock_mode(true);
        window.set_cursor_visibility(false);
    }

    if key.just_pressed(KeyCode::Escape) {
        window.set_cursor_lock_mode(false);
        window.set_cursor_visibility(true);
    }
}
</code></pre>
<h1 id="convert-cursor-to-world-coordinates"><a class="header" href="#convert-cursor-to-world-coordinates">Convert cursor to world coordinates</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/cursor2world.rs">Click here for the full example code.</a></p>
<hr />
<p>Bevy does not yet provide built-in functions to help with finding out what the cursor is pointing at.</p>
<h2 id="3d-games"><a class="header" href="#3d-games">3D games</a></h2>
<p>There is a good (unofficial) plugin: <a href="https://github.com/aevyrie/bevy_mod_picking"><code>bevy_mod_picking</code></a>.</p>
<h2 id="2d-games"><a class="header" href="#2d-games">2D games</a></h2>
<p>For a game using the default bevy 2d orthographic camera:</p>
<pre><code class="language-rust no_run noplayground">/// Used to help identify our main camera
struct MainCamera;

fn setup(commands: &amp;mut Commands) {
    let camera = Camera2dBundle::default();

    commands.spawn(camera)
        .with(MainCamera);
}

fn my_cursor_system(
    // events to get cursor position
    ev_cursor: Res&lt;Events&lt;CursorMoved&gt;&gt;,
    mut evr_cursor: Local&lt;EventReader&lt;CursorMoved&gt;&gt;,
    // need to get window dimensions
    wnds: Res&lt;Windows&gt;,
    // query to get camera transform
    q_camera: Query&lt;&amp;Transform, With&lt;MainCamera&gt;&gt;
) {
    // assuming there is exactly one main camera entity, so this is OK
    let camera_transform = q_camera.iter().next().unwrap();

    for ev in evr_cursor.iter(&amp;ev_cursor) {
        // get the size of the window that the event is for
        let wnd = wnds.get(ev.id).unwrap();
        let size = Vec2::new(wnd.width() as f32, wnd.height() as f32);

        // the default orthographic projection is in pixels from the center;
        // just undo the translation
        let p = ev.position - size / 2.0;

        // apply the camera transform
        let pos_wld = camera_transform.compute_matrix() * p.extend(0.0).extend(1.0);
        eprintln!(&quot;World coords: {}/{}&quot;, pos_wld.x, pos_wld.y);
    }
}
</code></pre>
<h1 id="custom-camera-projection"><a class="header" href="#custom-camera-projection">Custom Camera Projection</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/custom-projection.rs">Click here for the full example code.</a></p>
<hr />
<p>Camera with a custom projection (not using one of bevy's standard perspective or orthographic projections).</p>
<p>Here we implement a simple orthographic projection that maps <code>-1.0</code> to <code>1.0</code> to the vertical axis of the window,
and respects the window's aspect ratio for the horizontal axis:</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::{Camera, CameraProjection, DepthCalculation, VisibleEntities};

struct SimpleOrthoProjection {
    far: f32,
    aspect: f32,
}

impl CameraProjection for SimpleOrthoProjection {
    fn get_projection_matrix(&amp;self) -&gt; Mat4 {
        Mat4::orthographic_rh(
            -self.aspect, self.aspect, -1.0, 1.0, 0.0, self.far
        )
    }

    // what to do on window resize
    fn update(&amp;mut self, width: f32, height: f32) {
        self.aspect = width / height;
    }

    fn depth_calculation(&amp;self) -&gt; DepthCalculation {
        // for orthographic
        DepthCalculation::ZDifference

        // otherwise
        //DepthCalculation::Distance
    }
}

impl Default for SimpleOrthoProjection {
    fn default() -&gt; Self {
        Self { far: 1000.0, aspect: 1.0 }
    }
}

fn setup(commands: &amp;mut Commands) {
    // same components as bevy's Camera2dBundle,
    // but with our custom projection

    let projection = SimpleOrthoProjection::default();

    // Need to set the camera name to one of the bevy-internal magic constants,
    // depending on which camera we are implementing (2D, 3D, or UI).
    // Bevy uses this name to find the camera and configure the rendering.
    // Since this example is a 2d camera:

    let cam_name = bevy::render::render_graph::base::camera::CAMERA_2D;

    let mut camera = Camera::default();
    camera.name = Some(cam_name.to_string());

    commands.spawn((
        // position the camera like bevy would do by default for 2D:
        Transform::from_translation(Vec3::new(0.0, 0.0, projection.far - 0.1)),
        GlobalTransform::default(),
        VisibleEntities::default(),
        camera,
        projection,
    ));
}

fn main() {
    // need to add a bevy-internal camera system to update
    // the projection on window resizing

    use bevy::render::camera::camera_system;

    App::build()
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup.system())
        .add_system_to_stage(
            bevy::app::stage::POST_UPDATE,
            camera_system::&lt;SimpleOrthoProjection&gt;.system(),
        )
        .run();
}
</code></pre>
<h1 id="pan--orbit-camera"><a class="header" href="#pan--orbit-camera">Pan + Orbit Camera</a></h1>
<p><a href="cookbook/../code_bevy_release/examples/pan-orbit-camera.rs">Click here for the full example code.</a></p>
<hr />
<p>This code is a community contribution.</p>
<p>Current version developed by <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/pull/1">@mirenbharta</a>. Initial work by <a href="https://github.com/jamadazi/bevy-cookbook/pull/2">@skairunner</a>.</p>
<hr />
<p>This is a camera controller similar to the ones in 3D editors like Blender.</p>
<p>Use the right mouse button to rotate, middle button to pan, scroll wheel to move inwards/outwards.</p>
<pre><code class="language-rust no_run noplayground">/// Tags an entity as capable of panning and orbiting.
struct PanOrbitCamera {
    /// The &quot;focus point&quot; to orbit around. It is automatically updated when panning the camera
    pub focus: Vec3,
    pub radius: f32,
    pub upside_down: bool,
}

impl Default for PanOrbitCamera {
    fn default() -&gt; Self {
        PanOrbitCamera {
            focus: Vec3::zero(),
            radius: 5.0,
            upside_down: false,
        }
    }
}

/// Pan the camera with middle mouse click, zoom with scroll wheel, orbit with right mouse click.
fn pan_orbit_camera(
    windows: Res&lt;Windows&gt;,
    mut reader_motion: Local&lt;EventReader&lt;MouseMotion&gt;&gt;,
    mut reader_scroll: Local&lt;EventReader&lt;MouseWheel&gt;&gt;,
    ev_motion: Res&lt;Events&lt;MouseMotion&gt;&gt;,
    ev_mouse: Res&lt;Input&lt;MouseButton&gt;&gt;,
    ev_scroll: Res&lt;Events&lt;MouseWheel&gt;&gt;,
    mut query: Query&lt;(&amp;mut PanOrbitCamera, &amp;mut Transform, &amp;PerspectiveProjection)&gt;,
) {
    // change input mapping for orbit and panning here
    let orbit_button = MouseButton::Right;
    let pan_button = MouseButton::Middle;

    let mut pan = Vec2::zero();
    let mut rotation_move = Vec2::zero();
    let mut scroll = 0.0;
    let mut orbit_button_changed = false;

    if ev_mouse.pressed(orbit_button) {
        for ev in reader_motion.iter(&amp;ev_motion) {
            rotation_move += ev.delta;
        }
    } else if ev_mouse.pressed(pan_button) {
        // Pan only if we're not rotating at the moment
        for ev in reader_motion.iter(&amp;ev_motion) {
            pan += ev.delta;
        }
    }
    for ev in reader_scroll.iter(&amp;ev_scroll) {
        scroll += ev.y;
    }
    if ev_mouse.just_released(orbit_button) || ev_mouse.just_pressed(orbit_button) {
        orbit_button_changed = true;
    }

    for (mut pan_orbit, mut transform, projection) in query.iter_mut() {
        if orbit_button_changed {
            // only check for upside down when orbiting started or ended this frame
            // if the camera is &quot;upside&quot; down, panning horizontally would be inverted, so invert the input to make it correct
            let up = transform.rotation * Vec3::unit_y();
            pan_orbit.upside_down = up.y &lt;= 0.0;
        }

        let mut any = false;
        if rotation_move.length_squared() &gt; 0.0 {
            any = true;
            let window = get_primary_window_size(&amp;windows);
            let delta_x = {
                let delta = rotation_move.x / window.x * std::f32::consts::PI * 2.0;
                if pan_orbit.upside_down { -delta } else { delta }
            };
            let delta_y = rotation_move.y / window.y * std::f32::consts::PI;
            let yaw = Quat::from_rotation_y(-delta_x);
            let pitch = Quat::from_rotation_x(-delta_y);
            transform.rotation = yaw * transform.rotation; // rotate around global y axis
            transform.rotation = transform.rotation * pitch; // rotate around local x axis
        } else if pan.length_squared() &gt; 0.0 {
            any = true;
            // make panning distance independent of resolution and FOV,
            let window = get_primary_window_size(&amp;windows);
            pan *= Vec2::new(projection.fov * projection.aspect_ratio, projection.fov) / window;
            // translate by local axes
            let right = transform.rotation * Vec3::unit_x() * -pan.x;
            let up = transform.rotation * Vec3::unit_y() * pan.y;
            // make panning proportional to distance away from focus point
            let translation = (right + up) * pan_orbit.radius;
            pan_orbit.focus += translation;
        } else if scroll.abs() &gt; 0.0 {
            any = true;
            pan_orbit.radius -= scroll * pan_orbit.radius * 0.2;
            // dont allow zoom to reach zero or you get stuck
            pan_orbit.radius = f32::max(pan_orbit.radius, 0.05);
        }

        if any {
            // emulating parent/child to make the yaw/y-axis rotation behave like a turntable
            // parent = x and y rotation
            // child = z-offset
            let rot_matrix = Mat3::from_quat(transform.rotation);
            transform.translation = pan_orbit.focus + rot_matrix.mul_vec3(Vec3::new(0.0, 0.0, pan_orbit.radius));
        }
    }
}

fn get_primary_window_size(windows: &amp;Res&lt;Windows&gt;) -&gt; Vec2 {
    let window = windows.get_primary().unwrap();
    let window = Vec2::new(window.width() as f32, window.height() as f32);
    window
}

/// Spawn a camera like this
fn spawn_camera(commands: &amp;mut Commands) {
    let translation = Vec3::new(-2.0, 2.5, 5.0);
    let radius = translation.length();

    commands.spawn(Camera3dBundle {
        transform: Transform::from_translation(translation)
            .looking_at(Vec3::zero(), Vec3::unit_y()),
        ..Default::default()
    })
        .with(PanOrbitCamera {
            radius,
            ..Default::default()
        });
}
</code></pre>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Any help with maintaining or improving the book is welcome! Contribute via <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>!</p>
<p>Feel free to submit PRs for anything you consider useful. I will review them with you, so we can edit as needed to bring them to the style and quality desired for this book.</p>
<p>You should aim to adhere to the guidelines on this page, but don't worry too much about it; I'll happily work with you to improve your contributions.</p>
<p>If you prefer to only write code, that's fine. I can write the text to go with the code for you.</p>
<p>Even if you just have an idea, but don't want to write the content yourself, suggest it in an issue!</p>
<p>Be civil. If you need a code of conduct, have a look at Bevy's.</p>
<h2 id="help-wanted"><a class="header" href="#help-wanted">Help Wanted</a></h2>
<p>Specific things that I would really appreciate help with:</p>
<ul>
<li>Adding new syntax to the <a href="./cheatsheet/master.html">cheatsheet for the latest Bevy Git</a>.</li>
<li>More content for <a href="./patterns/_index.html">Advanced Patterns</a>, more <a href="./cookbook/_index.html">Cookbook</a> examples.
<ul>
<li>Especially if you frequent the Bevy Discord (or other communities) and know what kinds of things people come across.</li>
</ul>
</li>
</ul>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<p>When I merge your contributions to the book, I will mention you by your github username with a link to your PR.</p>
<p>Let me know if you don't want to be credited, or if you prefer to be credited in some other way.</p>
<h2 id="bevy-version"><a class="header" href="#bevy-version">Bevy version</a></h2>
<p>The book is targeted at the latest bevy release (0.4).</p>
<p>Content that covers new additions in bevy git, is also welcome! It needs to be clearly marked.</p>
<p>Anything that exists in both the release version and the git version, should be written for the release version.</p>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<p>All code that uses Bevy APIs should live under <code>src/code_bevy_release</code> or <code>src/code_bevy_master</code>, depending on the version of Bevy used.</p>
<p>Cookbook recipes should be independent files under <code>examples</code>. Only embed the relevant parts into the book page, without unnecessary boilerplate. Link to the full example file at the top of the page.</p>
<p>Cheatsheet code lives in <code>src/cheatsheet.rs</code>.</p>
<p>Miscellaneous code should live in <code>src/lib.rs</code>.</p>
<p>Always use mdbook anchor syntax to embed code, never line numbers.
<a href="https://rust-lang.github.io/mdBook/format/mdbook.html#including-portions-of-a-file">See here</a>.</p>
<h2 id="style-guidelines"><a class="header" href="#style-guidelines">Style Guidelines</a></h2>
<p>Code snippets in the Cheatsheet should be as concise as possible. Feel free to use meaningless placeholder names; don't try to make them &quot;realistic&quot;.</p>
<p>Code in other sections, however, should aim to &quot;look realistic&quot;, as to illustrate what the feature might actually be used for.</p>
<p>If you are writing text for the book, follow these guidelines to avoid the need for edits to your PRs and get them merged more easily:</p>
<ul>
<li>Reduce verbosity. Try to get the point across with simpler code and explanations.
<ul>
<li>&quot;Perfection is achieved not when there is nothing more to add, but when there is nothing more to remove.&quot;</li>
</ul>
</li>
<li>Avoid repeating information found elsewhere in the book.</li>
<li>Don't forget to point out gotchas, workarounds, and other relevant practical considerations.</li>
<li>Make it easy to read:
<ul>
<li>Try to cover all important information without wordy explanations.</li>
<li>Prefer simple English with short sentences.</li>
</ul>
</li>
<li>Use the most common/standard terminology and keywords, to make things easy to find.
<ul>
<li>Don't come up with new/extra terminology of your own.</li>
</ul>
</li>
<li>Avoid information overload
<ul>
<li>Cover advanced usage separately from the basics.</li>
<li>Prefer showing related features in a single code snippet (when not confusing). Avoid repeated/similar snippets.</li>
</ul>
</li>
<li>Avoid long lines of code, to keep it readable on small screens.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
